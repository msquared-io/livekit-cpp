// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: livekit_rtc.proto
// Protobuf C++ Version: 6.30.1

#ifndef livekit_5frtc_2eproto_2epb_2eh
#define livekit_5frtc_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6030001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_type_handler.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "livekit_models.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_livekit_5frtc_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_livekit_5frtc_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_livekit_5frtc_2eproto;
}  // extern "C"
namespace livekit {
enum CandidateProtocol : int;
extern const uint32_t CandidateProtocol_internal_data_[];
enum LeaveRequest_Action : int;
extern const uint32_t LeaveRequest_Action_internal_data_[];
enum RequestResponse_Reason : int;
extern const uint32_t RequestResponse_Reason_internal_data_[];
enum SignalTarget : int;
extern const uint32_t SignalTarget_internal_data_[];
enum StreamState : int;
extern const uint32_t StreamState_internal_data_[];
class AddTrackRequest;
struct AddTrackRequestDefaultTypeInternal;
extern AddTrackRequestDefaultTypeInternal _AddTrackRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull AddTrackRequest_class_data_;
class ConnectionQualityInfo;
struct ConnectionQualityInfoDefaultTypeInternal;
extern ConnectionQualityInfoDefaultTypeInternal _ConnectionQualityInfo_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ConnectionQualityInfo_class_data_;
class ConnectionQualityUpdate;
struct ConnectionQualityUpdateDefaultTypeInternal;
extern ConnectionQualityUpdateDefaultTypeInternal _ConnectionQualityUpdate_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ConnectionQualityUpdate_class_data_;
class DataChannelInfo;
struct DataChannelInfoDefaultTypeInternal;
extern DataChannelInfoDefaultTypeInternal _DataChannelInfo_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DataChannelInfo_class_data_;
class ICEServer;
struct ICEServerDefaultTypeInternal;
extern ICEServerDefaultTypeInternal _ICEServer_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ICEServer_class_data_;
class JoinResponse;
struct JoinResponseDefaultTypeInternal;
extern JoinResponseDefaultTypeInternal _JoinResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull JoinResponse_class_data_;
class LeaveRequest;
struct LeaveRequestDefaultTypeInternal;
extern LeaveRequestDefaultTypeInternal _LeaveRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull LeaveRequest_class_data_;
class MuteTrackRequest;
struct MuteTrackRequestDefaultTypeInternal;
extern MuteTrackRequestDefaultTypeInternal _MuteTrackRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MuteTrackRequest_class_data_;
class ParticipantUpdate;
struct ParticipantUpdateDefaultTypeInternal;
extern ParticipantUpdateDefaultTypeInternal _ParticipantUpdate_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ParticipantUpdate_class_data_;
class Ping;
struct PingDefaultTypeInternal;
extern PingDefaultTypeInternal _Ping_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Ping_class_data_;
class Pong;
struct PongDefaultTypeInternal;
extern PongDefaultTypeInternal _Pong_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Pong_class_data_;
class ReconnectResponse;
struct ReconnectResponseDefaultTypeInternal;
extern ReconnectResponseDefaultTypeInternal _ReconnectResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ReconnectResponse_class_data_;
class RegionInfo;
struct RegionInfoDefaultTypeInternal;
extern RegionInfoDefaultTypeInternal _RegionInfo_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RegionInfo_class_data_;
class RegionSettings;
struct RegionSettingsDefaultTypeInternal;
extern RegionSettingsDefaultTypeInternal _RegionSettings_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RegionSettings_class_data_;
class RequestResponse;
struct RequestResponseDefaultTypeInternal;
extern RequestResponseDefaultTypeInternal _RequestResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RequestResponse_class_data_;
class RoomUpdate;
struct RoomUpdateDefaultTypeInternal;
extern RoomUpdateDefaultTypeInternal _RoomUpdate_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RoomUpdate_class_data_;
class SessionDescription;
struct SessionDescriptionDefaultTypeInternal;
extern SessionDescriptionDefaultTypeInternal _SessionDescription_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SessionDescription_class_data_;
class SignalRequest;
struct SignalRequestDefaultTypeInternal;
extern SignalRequestDefaultTypeInternal _SignalRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SignalRequest_class_data_;
class SignalResponse;
struct SignalResponseDefaultTypeInternal;
extern SignalResponseDefaultTypeInternal _SignalResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SignalResponse_class_data_;
class SimulateScenario;
struct SimulateScenarioDefaultTypeInternal;
extern SimulateScenarioDefaultTypeInternal _SimulateScenario_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SimulateScenario_class_data_;
class SimulcastCodec;
struct SimulcastCodecDefaultTypeInternal;
extern SimulcastCodecDefaultTypeInternal _SimulcastCodec_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SimulcastCodec_class_data_;
class SpeakersChanged;
struct SpeakersChangedDefaultTypeInternal;
extern SpeakersChangedDefaultTypeInternal _SpeakersChanged_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SpeakersChanged_class_data_;
class StreamStateInfo;
struct StreamStateInfoDefaultTypeInternal;
extern StreamStateInfoDefaultTypeInternal _StreamStateInfo_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull StreamStateInfo_class_data_;
class StreamStateUpdate;
struct StreamStateUpdateDefaultTypeInternal;
extern StreamStateUpdateDefaultTypeInternal _StreamStateUpdate_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull StreamStateUpdate_class_data_;
class SubscribedCodec;
struct SubscribedCodecDefaultTypeInternal;
extern SubscribedCodecDefaultTypeInternal _SubscribedCodec_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SubscribedCodec_class_data_;
class SubscribedQuality;
struct SubscribedQualityDefaultTypeInternal;
extern SubscribedQualityDefaultTypeInternal _SubscribedQuality_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SubscribedQuality_class_data_;
class SubscribedQualityUpdate;
struct SubscribedQualityUpdateDefaultTypeInternal;
extern SubscribedQualityUpdateDefaultTypeInternal _SubscribedQualityUpdate_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SubscribedQualityUpdate_class_data_;
class SubscriptionPermission;
struct SubscriptionPermissionDefaultTypeInternal;
extern SubscriptionPermissionDefaultTypeInternal _SubscriptionPermission_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SubscriptionPermission_class_data_;
class SubscriptionPermissionUpdate;
struct SubscriptionPermissionUpdateDefaultTypeInternal;
extern SubscriptionPermissionUpdateDefaultTypeInternal _SubscriptionPermissionUpdate_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SubscriptionPermissionUpdate_class_data_;
class SubscriptionResponse;
struct SubscriptionResponseDefaultTypeInternal;
extern SubscriptionResponseDefaultTypeInternal _SubscriptionResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SubscriptionResponse_class_data_;
class SyncState;
struct SyncStateDefaultTypeInternal;
extern SyncStateDefaultTypeInternal _SyncState_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SyncState_class_data_;
class TrackPermission;
struct TrackPermissionDefaultTypeInternal;
extern TrackPermissionDefaultTypeInternal _TrackPermission_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TrackPermission_class_data_;
class TrackPublishedResponse;
struct TrackPublishedResponseDefaultTypeInternal;
extern TrackPublishedResponseDefaultTypeInternal _TrackPublishedResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TrackPublishedResponse_class_data_;
class TrackSubscribed;
struct TrackSubscribedDefaultTypeInternal;
extern TrackSubscribedDefaultTypeInternal _TrackSubscribed_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TrackSubscribed_class_data_;
class TrackUnpublishedResponse;
struct TrackUnpublishedResponseDefaultTypeInternal;
extern TrackUnpublishedResponseDefaultTypeInternal _TrackUnpublishedResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TrackUnpublishedResponse_class_data_;
class TrickleRequest;
struct TrickleRequestDefaultTypeInternal;
extern TrickleRequestDefaultTypeInternal _TrickleRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TrickleRequest_class_data_;
class UpdateLocalAudioTrack;
struct UpdateLocalAudioTrackDefaultTypeInternal;
extern UpdateLocalAudioTrackDefaultTypeInternal _UpdateLocalAudioTrack_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UpdateLocalAudioTrack_class_data_;
class UpdateLocalVideoTrack;
struct UpdateLocalVideoTrackDefaultTypeInternal;
extern UpdateLocalVideoTrackDefaultTypeInternal _UpdateLocalVideoTrack_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UpdateLocalVideoTrack_class_data_;
class UpdateParticipantMetadata;
struct UpdateParticipantMetadataDefaultTypeInternal;
extern UpdateParticipantMetadataDefaultTypeInternal _UpdateParticipantMetadata_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UpdateParticipantMetadata_class_data_;
class UpdateParticipantMetadata_AttributesEntry_DoNotUse;
struct UpdateParticipantMetadata_AttributesEntry_DoNotUseDefaultTypeInternal;
extern UpdateParticipantMetadata_AttributesEntry_DoNotUseDefaultTypeInternal _UpdateParticipantMetadata_AttributesEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UpdateParticipantMetadata_AttributesEntry_DoNotUse_class_data_;
class UpdateSubscription;
struct UpdateSubscriptionDefaultTypeInternal;
extern UpdateSubscriptionDefaultTypeInternal _UpdateSubscription_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UpdateSubscription_class_data_;
class UpdateTrackSettings;
struct UpdateTrackSettingsDefaultTypeInternal;
extern UpdateTrackSettingsDefaultTypeInternal _UpdateTrackSettings_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UpdateTrackSettings_class_data_;
class UpdateVideoLayers;
struct UpdateVideoLayersDefaultTypeInternal;
extern UpdateVideoLayersDefaultTypeInternal _UpdateVideoLayers_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UpdateVideoLayers_class_data_;
}  // namespace livekit
namespace google {
namespace protobuf {
template <>
internal::EnumTraitsT<::livekit::CandidateProtocol_internal_data_>
    internal::EnumTraitsImpl::value<::livekit::CandidateProtocol>;
template <>
internal::EnumTraitsT<::livekit::LeaveRequest_Action_internal_data_>
    internal::EnumTraitsImpl::value<::livekit::LeaveRequest_Action>;
template <>
internal::EnumTraitsT<::livekit::RequestResponse_Reason_internal_data_>
    internal::EnumTraitsImpl::value<::livekit::RequestResponse_Reason>;
template <>
internal::EnumTraitsT<::livekit::SignalTarget_internal_data_>
    internal::EnumTraitsImpl::value<::livekit::SignalTarget>;
template <>
internal::EnumTraitsT<::livekit::StreamState_internal_data_>
    internal::EnumTraitsImpl::value<::livekit::StreamState>;
}  // namespace protobuf
}  // namespace google

namespace livekit {
enum LeaveRequest_Action : int {
  LeaveRequest_Action_DISCONNECT = 0,
  LeaveRequest_Action_RESUME = 1,
  LeaveRequest_Action_RECONNECT = 2,
  LeaveRequest_Action_LeaveRequest_Action_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  LeaveRequest_Action_LeaveRequest_Action_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t LeaveRequest_Action_internal_data_[];
inline constexpr LeaveRequest_Action LeaveRequest_Action_Action_MIN =
    static_cast<LeaveRequest_Action>(0);
inline constexpr LeaveRequest_Action LeaveRequest_Action_Action_MAX =
    static_cast<LeaveRequest_Action>(2);
inline bool LeaveRequest_Action_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int LeaveRequest_Action_Action_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL LeaveRequest_Action_descriptor();
template <typename T>
const std::string& LeaveRequest_Action_Name(T value) {
  static_assert(std::is_same<T, LeaveRequest_Action>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Action_Name().");
  return LeaveRequest_Action_Name(static_cast<LeaveRequest_Action>(value));
}
template <>
inline const std::string& LeaveRequest_Action_Name(LeaveRequest_Action value) {
  return ::google::protobuf::internal::NameOfDenseEnum<LeaveRequest_Action_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool LeaveRequest_Action_Parse(
    absl::string_view name, LeaveRequest_Action* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<LeaveRequest_Action>(LeaveRequest_Action_descriptor(), name,
                                           value);
}
enum RequestResponse_Reason : int {
  RequestResponse_Reason_OK = 0,
  RequestResponse_Reason_NOT_FOUND = 1,
  RequestResponse_Reason_NOT_ALLOWED = 2,
  RequestResponse_Reason_LIMIT_EXCEEDED = 3,
  RequestResponse_Reason_RequestResponse_Reason_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  RequestResponse_Reason_RequestResponse_Reason_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t RequestResponse_Reason_internal_data_[];
inline constexpr RequestResponse_Reason RequestResponse_Reason_Reason_MIN =
    static_cast<RequestResponse_Reason>(0);
inline constexpr RequestResponse_Reason RequestResponse_Reason_Reason_MAX =
    static_cast<RequestResponse_Reason>(3);
inline bool RequestResponse_Reason_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int RequestResponse_Reason_Reason_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL RequestResponse_Reason_descriptor();
template <typename T>
const std::string& RequestResponse_Reason_Name(T value) {
  static_assert(std::is_same<T, RequestResponse_Reason>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Reason_Name().");
  return RequestResponse_Reason_Name(static_cast<RequestResponse_Reason>(value));
}
template <>
inline const std::string& RequestResponse_Reason_Name(RequestResponse_Reason value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RequestResponse_Reason_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool RequestResponse_Reason_Parse(
    absl::string_view name, RequestResponse_Reason* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<RequestResponse_Reason>(RequestResponse_Reason_descriptor(), name,
                                           value);
}
enum SignalTarget : int {
  PUBLISHER = 0,
  SUBSCRIBER = 1,
  SignalTarget_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SignalTarget_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t SignalTarget_internal_data_[];
inline constexpr SignalTarget SignalTarget_MIN =
    static_cast<SignalTarget>(0);
inline constexpr SignalTarget SignalTarget_MAX =
    static_cast<SignalTarget>(1);
inline bool SignalTarget_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int SignalTarget_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL SignalTarget_descriptor();
template <typename T>
const std::string& SignalTarget_Name(T value) {
  static_assert(std::is_same<T, SignalTarget>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SignalTarget_Name().");
  return SignalTarget_Name(static_cast<SignalTarget>(value));
}
template <>
inline const std::string& SignalTarget_Name(SignalTarget value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SignalTarget_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool SignalTarget_Parse(
    absl::string_view name, SignalTarget* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<SignalTarget>(SignalTarget_descriptor(), name,
                                           value);
}
enum StreamState : int {
  ACTIVE = 0,
  PAUSED = 1,
  StreamState_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  StreamState_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t StreamState_internal_data_[];
inline constexpr StreamState StreamState_MIN =
    static_cast<StreamState>(0);
inline constexpr StreamState StreamState_MAX =
    static_cast<StreamState>(1);
inline bool StreamState_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int StreamState_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL StreamState_descriptor();
template <typename T>
const std::string& StreamState_Name(T value) {
  static_assert(std::is_same<T, StreamState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to StreamState_Name().");
  return StreamState_Name(static_cast<StreamState>(value));
}
template <>
inline const std::string& StreamState_Name(StreamState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<StreamState_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool StreamState_Parse(
    absl::string_view name, StreamState* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<StreamState>(StreamState_descriptor(), name,
                                           value);
}
enum CandidateProtocol : int {
  UDP = 0,
  TCP = 1,
  TLS = 2,
  CandidateProtocol_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CandidateProtocol_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t CandidateProtocol_internal_data_[];
inline constexpr CandidateProtocol CandidateProtocol_MIN =
    static_cast<CandidateProtocol>(0);
inline constexpr CandidateProtocol CandidateProtocol_MAX =
    static_cast<CandidateProtocol>(2);
inline bool CandidateProtocol_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int CandidateProtocol_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL CandidateProtocol_descriptor();
template <typename T>
const std::string& CandidateProtocol_Name(T value) {
  static_assert(std::is_same<T, CandidateProtocol>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CandidateProtocol_Name().");
  return CandidateProtocol_Name(static_cast<CandidateProtocol>(value));
}
template <>
inline const std::string& CandidateProtocol_Name(CandidateProtocol value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CandidateProtocol_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool CandidateProtocol_Parse(
    absl::string_view name, CandidateProtocol* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<CandidateProtocol>(CandidateProtocol_descriptor(), name,
                                           value);
}

// ===================================================================


// -------------------------------------------------------------------

class UpdateTrackSettings final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.UpdateTrackSettings) */ {
 public:
  inline UpdateTrackSettings() : UpdateTrackSettings(nullptr) {}
  ~UpdateTrackSettings() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateTrackSettings* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateTrackSettings));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateTrackSettings(::google::protobuf::internal::ConstantInitialized);

  inline UpdateTrackSettings(const UpdateTrackSettings& from) : UpdateTrackSettings(nullptr, from) {}
  inline UpdateTrackSettings(UpdateTrackSettings&& from) noexcept
      : UpdateTrackSettings(nullptr, std::move(from)) {}
  inline UpdateTrackSettings& operator=(const UpdateTrackSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateTrackSettings& operator=(UpdateTrackSettings&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateTrackSettings& default_instance() {
    return *reinterpret_cast<const UpdateTrackSettings*>(
        &_UpdateTrackSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(UpdateTrackSettings& a, UpdateTrackSettings& b) { a.Swap(&b); }
  inline void Swap(UpdateTrackSettings* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateTrackSettings* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateTrackSettings* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateTrackSettings>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateTrackSettings& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateTrackSettings& from) { UpdateTrackSettings::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateTrackSettings* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.UpdateTrackSettings"; }

 protected:
  explicit UpdateTrackSettings(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UpdateTrackSettings(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UpdateTrackSettings& from);
  UpdateTrackSettings(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UpdateTrackSettings&& from) noexcept
      : UpdateTrackSettings(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTrackSidsFieldNumber = 1,
    kDisabledFieldNumber = 3,
    kQualityFieldNumber = 4,
    kWidthFieldNumber = 5,
    kHeightFieldNumber = 6,
    kFpsFieldNumber = 7,
    kPriorityFieldNumber = 8,
  };
  // repeated string track_sids = 1;
  int track_sids_size() const;
  private:
  int _internal_track_sids_size() const;

  public:
  void clear_track_sids() ;
  const std::string& track_sids(int index) const;
  std::string* PROTOBUF_NONNULL mutable_track_sids(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_track_sids(int index, Arg_&& value, Args_... args);
  std::string* PROTOBUF_NONNULL add_track_sids();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_track_sids(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& track_sids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* PROTOBUF_NONNULL mutable_track_sids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_track_sids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* PROTOBUF_NONNULL _internal_mutable_track_sids();

  public:
  // bool disabled = 3;
  void clear_disabled() ;
  bool disabled() const;
  void set_disabled(bool value);

  private:
  bool _internal_disabled() const;
  void _internal_set_disabled(bool value);

  public:
  // .livekit.VideoQuality quality = 4;
  void clear_quality() ;
  ::livekit::VideoQuality quality() const;
  void set_quality(::livekit::VideoQuality value);

  private:
  ::livekit::VideoQuality _internal_quality() const;
  void _internal_set_quality(::livekit::VideoQuality value);

  public:
  // uint32 width = 5;
  void clear_width() ;
  ::uint32_t width() const;
  void set_width(::uint32_t value);

  private:
  ::uint32_t _internal_width() const;
  void _internal_set_width(::uint32_t value);

  public:
  // uint32 height = 6;
  void clear_height() ;
  ::uint32_t height() const;
  void set_height(::uint32_t value);

  private:
  ::uint32_t _internal_height() const;
  void _internal_set_height(::uint32_t value);

  public:
  // uint32 fps = 7;
  void clear_fps() ;
  ::uint32_t fps() const;
  void set_fps(::uint32_t value);

  private:
  ::uint32_t _internal_fps() const;
  void _internal_set_fps(::uint32_t value);

  public:
  // uint32 priority = 8;
  void clear_priority() ;
  ::uint32_t priority() const;
  void set_priority(::uint32_t value);

  private:
  ::uint32_t _internal_priority() const;
  void _internal_set_priority(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.UpdateTrackSettings)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7,
                                   0, 46,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UpdateTrackSettings& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> track_sids_;
    bool disabled_;
    int quality_;
    ::uint32_t width_;
    ::uint32_t height_;
    ::uint32_t fps_;
    ::uint32_t priority_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UpdateTrackSettings_class_data_;
// -------------------------------------------------------------------

class UpdateParticipantMetadata_AttributesEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<std::string, std::string,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  UpdateParticipantMetadata_AttributesEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateParticipantMetadata_AttributesEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit UpdateParticipantMetadata_AttributesEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_UpdateParticipantMetadata_AttributesEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_livekit_5frtc_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 66,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull UpdateParticipantMetadata_AttributesEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class UpdateLocalVideoTrack final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.UpdateLocalVideoTrack) */ {
 public:
  inline UpdateLocalVideoTrack() : UpdateLocalVideoTrack(nullptr) {}
  ~UpdateLocalVideoTrack() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateLocalVideoTrack* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateLocalVideoTrack));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateLocalVideoTrack(::google::protobuf::internal::ConstantInitialized);

  inline UpdateLocalVideoTrack(const UpdateLocalVideoTrack& from) : UpdateLocalVideoTrack(nullptr, from) {}
  inline UpdateLocalVideoTrack(UpdateLocalVideoTrack&& from) noexcept
      : UpdateLocalVideoTrack(nullptr, std::move(from)) {}
  inline UpdateLocalVideoTrack& operator=(const UpdateLocalVideoTrack& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateLocalVideoTrack& operator=(UpdateLocalVideoTrack&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateLocalVideoTrack& default_instance() {
    return *reinterpret_cast<const UpdateLocalVideoTrack*>(
        &_UpdateLocalVideoTrack_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(UpdateLocalVideoTrack& a, UpdateLocalVideoTrack& b) { a.Swap(&b); }
  inline void Swap(UpdateLocalVideoTrack* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateLocalVideoTrack* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateLocalVideoTrack* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateLocalVideoTrack>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateLocalVideoTrack& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateLocalVideoTrack& from) { UpdateLocalVideoTrack::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateLocalVideoTrack* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.UpdateLocalVideoTrack"; }

 protected:
  explicit UpdateLocalVideoTrack(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UpdateLocalVideoTrack(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UpdateLocalVideoTrack& from);
  UpdateLocalVideoTrack(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UpdateLocalVideoTrack&& from) noexcept
      : UpdateLocalVideoTrack(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTrackSidFieldNumber = 1,
    kWidthFieldNumber = 2,
    kHeightFieldNumber = 3,
  };
  // string track_sid = 1;
  void clear_track_sid() ;
  const std::string& track_sid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_track_sid(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_track_sid();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_track_sid();
  void set_allocated_track_sid(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_track_sid() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_track_sid(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_track_sid();

  public:
  // uint32 width = 2;
  void clear_width() ;
  ::uint32_t width() const;
  void set_width(::uint32_t value);

  private:
  ::uint32_t _internal_width() const;
  void _internal_set_width(::uint32_t value);

  public:
  // uint32 height = 3;
  void clear_height() ;
  ::uint32_t height() const;
  void set_height(::uint32_t value);

  private:
  ::uint32_t _internal_height() const;
  void _internal_set_height(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.UpdateLocalVideoTrack)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 47,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UpdateLocalVideoTrack& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr track_sid_;
    ::uint32_t width_;
    ::uint32_t height_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UpdateLocalVideoTrack_class_data_;
// -------------------------------------------------------------------

class UpdateLocalAudioTrack final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.UpdateLocalAudioTrack) */ {
 public:
  inline UpdateLocalAudioTrack() : UpdateLocalAudioTrack(nullptr) {}
  ~UpdateLocalAudioTrack() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateLocalAudioTrack* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateLocalAudioTrack));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateLocalAudioTrack(::google::protobuf::internal::ConstantInitialized);

  inline UpdateLocalAudioTrack(const UpdateLocalAudioTrack& from) : UpdateLocalAudioTrack(nullptr, from) {}
  inline UpdateLocalAudioTrack(UpdateLocalAudioTrack&& from) noexcept
      : UpdateLocalAudioTrack(nullptr, std::move(from)) {}
  inline UpdateLocalAudioTrack& operator=(const UpdateLocalAudioTrack& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateLocalAudioTrack& operator=(UpdateLocalAudioTrack&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateLocalAudioTrack& default_instance() {
    return *reinterpret_cast<const UpdateLocalAudioTrack*>(
        &_UpdateLocalAudioTrack_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(UpdateLocalAudioTrack& a, UpdateLocalAudioTrack& b) { a.Swap(&b); }
  inline void Swap(UpdateLocalAudioTrack* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateLocalAudioTrack* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateLocalAudioTrack* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateLocalAudioTrack>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateLocalAudioTrack& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateLocalAudioTrack& from) { UpdateLocalAudioTrack::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateLocalAudioTrack* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.UpdateLocalAudioTrack"; }

 protected:
  explicit UpdateLocalAudioTrack(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UpdateLocalAudioTrack(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UpdateLocalAudioTrack& from);
  UpdateLocalAudioTrack(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UpdateLocalAudioTrack&& from) noexcept
      : UpdateLocalAudioTrack(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFeaturesFieldNumber = 2,
    kTrackSidFieldNumber = 1,
  };
  // repeated .livekit.AudioTrackFeature features = 2;
  int features_size() const;
  private:
  int _internal_features_size() const;

  public:
  void clear_features() ;
  public:
  ::livekit::AudioTrackFeature features(int index) const;
  void set_features(int index, ::livekit::AudioTrackFeature value);
  void add_features(::livekit::AudioTrackFeature value);
  const ::google::protobuf::RepeatedField<int>& features() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL mutable_features();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_features() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL _internal_mutable_features();

  public:
  // string track_sid = 1;
  void clear_track_sid() ;
  const std::string& track_sid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_track_sid(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_track_sid();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_track_sid();
  void set_allocated_track_sid(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_track_sid() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_track_sid(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_track_sid();

  public:
  // @@protoc_insertion_point(class_scope:livekit.UpdateLocalAudioTrack)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 47,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UpdateLocalAudioTrack& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<int> features_;
    ::google::protobuf::internal::CachedSize _features_cached_byte_size_;
    ::google::protobuf::internal::ArenaStringPtr track_sid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UpdateLocalAudioTrack_class_data_;
// -------------------------------------------------------------------

class TrickleRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.TrickleRequest) */ {
 public:
  inline TrickleRequest() : TrickleRequest(nullptr) {}
  ~TrickleRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TrickleRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TrickleRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TrickleRequest(::google::protobuf::internal::ConstantInitialized);

  inline TrickleRequest(const TrickleRequest& from) : TrickleRequest(nullptr, from) {}
  inline TrickleRequest(TrickleRequest&& from) noexcept
      : TrickleRequest(nullptr, std::move(from)) {}
  inline TrickleRequest& operator=(const TrickleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrickleRequest& operator=(TrickleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrickleRequest& default_instance() {
    return *reinterpret_cast<const TrickleRequest*>(
        &_TrickleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(TrickleRequest& a, TrickleRequest& b) { a.Swap(&b); }
  inline void Swap(TrickleRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrickleRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrickleRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TrickleRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrickleRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TrickleRequest& from) { TrickleRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TrickleRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.TrickleRequest"; }

 protected:
  explicit TrickleRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TrickleRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TrickleRequest& from);
  TrickleRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TrickleRequest&& from) noexcept
      : TrickleRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCandidateInitFieldNumber = 1,
    kTargetFieldNumber = 2,
    kFinalFieldNumber = 3,
  };
  // string candidateInit = 1;
  void clear_candidateinit() ;
  const std::string& candidateinit() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_candidateinit(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_candidateinit();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_candidateinit();
  void set_allocated_candidateinit(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_candidateinit() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_candidateinit(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_candidateinit();

  public:
  // .livekit.SignalTarget target = 2;
  void clear_target() ;
  ::livekit::SignalTarget target() const;
  void set_target(::livekit::SignalTarget value);

  private:
  ::livekit::SignalTarget _internal_target() const;
  void _internal_set_target(::livekit::SignalTarget value);

  public:
  // bool final = 3;
  void clear_final() ;
  bool final() const;
  void set_final(bool value);

  private:
  bool _internal_final() const;
  void _internal_set_final(bool value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.TrickleRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 44,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TrickleRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr candidateinit_;
    int target_;
    bool final_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TrickleRequest_class_data_;
// -------------------------------------------------------------------

class TrackUnpublishedResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.TrackUnpublishedResponse) */ {
 public:
  inline TrackUnpublishedResponse() : TrackUnpublishedResponse(nullptr) {}
  ~TrackUnpublishedResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TrackUnpublishedResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TrackUnpublishedResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TrackUnpublishedResponse(::google::protobuf::internal::ConstantInitialized);

  inline TrackUnpublishedResponse(const TrackUnpublishedResponse& from) : TrackUnpublishedResponse(nullptr, from) {}
  inline TrackUnpublishedResponse(TrackUnpublishedResponse&& from) noexcept
      : TrackUnpublishedResponse(nullptr, std::move(from)) {}
  inline TrackUnpublishedResponse& operator=(const TrackUnpublishedResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackUnpublishedResponse& operator=(TrackUnpublishedResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackUnpublishedResponse& default_instance() {
    return *reinterpret_cast<const TrackUnpublishedResponse*>(
        &_TrackUnpublishedResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(TrackUnpublishedResponse& a, TrackUnpublishedResponse& b) { a.Swap(&b); }
  inline void Swap(TrackUnpublishedResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackUnpublishedResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackUnpublishedResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TrackUnpublishedResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrackUnpublishedResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TrackUnpublishedResponse& from) { TrackUnpublishedResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TrackUnpublishedResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.TrackUnpublishedResponse"; }

 protected:
  explicit TrackUnpublishedResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TrackUnpublishedResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TrackUnpublishedResponse& from);
  TrackUnpublishedResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TrackUnpublishedResponse&& from) noexcept
      : TrackUnpublishedResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTrackSidFieldNumber = 1,
  };
  // string track_sid = 1;
  void clear_track_sid() ;
  const std::string& track_sid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_track_sid(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_track_sid();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_track_sid();
  void set_allocated_track_sid(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_track_sid() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_track_sid(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_track_sid();

  public:
  // @@protoc_insertion_point(class_scope:livekit.TrackUnpublishedResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 50,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TrackUnpublishedResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr track_sid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TrackUnpublishedResponse_class_data_;
// -------------------------------------------------------------------

class TrackSubscribed final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.TrackSubscribed) */ {
 public:
  inline TrackSubscribed() : TrackSubscribed(nullptr) {}
  ~TrackSubscribed() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TrackSubscribed* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TrackSubscribed));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TrackSubscribed(::google::protobuf::internal::ConstantInitialized);

  inline TrackSubscribed(const TrackSubscribed& from) : TrackSubscribed(nullptr, from) {}
  inline TrackSubscribed(TrackSubscribed&& from) noexcept
      : TrackSubscribed(nullptr, std::move(from)) {}
  inline TrackSubscribed& operator=(const TrackSubscribed& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackSubscribed& operator=(TrackSubscribed&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackSubscribed& default_instance() {
    return *reinterpret_cast<const TrackSubscribed*>(
        &_TrackSubscribed_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 42;
  friend void swap(TrackSubscribed& a, TrackSubscribed& b) { a.Swap(&b); }
  inline void Swap(TrackSubscribed* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackSubscribed* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackSubscribed* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TrackSubscribed>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrackSubscribed& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TrackSubscribed& from) { TrackSubscribed::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TrackSubscribed* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.TrackSubscribed"; }

 protected:
  explicit TrackSubscribed(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TrackSubscribed(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TrackSubscribed& from);
  TrackSubscribed(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TrackSubscribed&& from) noexcept
      : TrackSubscribed(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTrackSidFieldNumber = 1,
  };
  // string track_sid = 1;
  void clear_track_sid() ;
  const std::string& track_sid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_track_sid(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_track_sid();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_track_sid();
  void set_allocated_track_sid(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_track_sid() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_track_sid(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_track_sid();

  public:
  // @@protoc_insertion_point(class_scope:livekit.TrackSubscribed)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 41,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TrackSubscribed& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr track_sid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TrackSubscribed_class_data_;
// -------------------------------------------------------------------

class TrackPermission final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.TrackPermission) */ {
 public:
  inline TrackPermission() : TrackPermission(nullptr) {}
  ~TrackPermission() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TrackPermission* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TrackPermission));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TrackPermission(::google::protobuf::internal::ConstantInitialized);

  inline TrackPermission(const TrackPermission& from) : TrackPermission(nullptr, from) {}
  inline TrackPermission(TrackPermission&& from) noexcept
      : TrackPermission(nullptr, std::move(from)) {}
  inline TrackPermission& operator=(const TrackPermission& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackPermission& operator=(TrackPermission&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackPermission& default_instance() {
    return *reinterpret_cast<const TrackPermission*>(
        &_TrackPermission_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 30;
  friend void swap(TrackPermission& a, TrackPermission& b) { a.Swap(&b); }
  inline void Swap(TrackPermission* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackPermission* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackPermission* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TrackPermission>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrackPermission& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TrackPermission& from) { TrackPermission::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TrackPermission* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.TrackPermission"; }

 protected:
  explicit TrackPermission(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TrackPermission(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TrackPermission& from);
  TrackPermission(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TrackPermission&& from) noexcept
      : TrackPermission(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTrackSidsFieldNumber = 3,
    kParticipantSidFieldNumber = 1,
    kParticipantIdentityFieldNumber = 4,
    kAllTracksFieldNumber = 2,
  };
  // repeated string track_sids = 3;
  int track_sids_size() const;
  private:
  int _internal_track_sids_size() const;

  public:
  void clear_track_sids() ;
  const std::string& track_sids(int index) const;
  std::string* PROTOBUF_NONNULL mutable_track_sids(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_track_sids(int index, Arg_&& value, Args_... args);
  std::string* PROTOBUF_NONNULL add_track_sids();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_track_sids(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& track_sids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* PROTOBUF_NONNULL mutable_track_sids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_track_sids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* PROTOBUF_NONNULL _internal_mutable_track_sids();

  public:
  // string participant_sid = 1;
  void clear_participant_sid() ;
  const std::string& participant_sid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_participant_sid(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_participant_sid();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_participant_sid();
  void set_allocated_participant_sid(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_participant_sid() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_participant_sid(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_participant_sid();

  public:
  // string participant_identity = 4;
  void clear_participant_identity() ;
  const std::string& participant_identity() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_participant_identity(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_participant_identity();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_participant_identity();
  void set_allocated_participant_identity(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_participant_identity() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_participant_identity(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_participant_identity();

  public:
  // bool all_tracks = 2;
  void clear_all_tracks() ;
  bool all_tracks() const;
  void set_all_tracks(bool value);

  private:
  bool _internal_all_tracks() const;
  void _internal_set_all_tracks(bool value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.TrackPermission)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 77,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TrackPermission& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> track_sids_;
    ::google::protobuf::internal::ArenaStringPtr participant_sid_;
    ::google::protobuf::internal::ArenaStringPtr participant_identity_;
    bool all_tracks_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TrackPermission_class_data_;
// -------------------------------------------------------------------

class SubscriptionResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.SubscriptionResponse) */ {
 public:
  inline SubscriptionResponse() : SubscriptionResponse(nullptr) {}
  ~SubscriptionResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SubscriptionResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SubscriptionResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubscriptionResponse(::google::protobuf::internal::ConstantInitialized);

  inline SubscriptionResponse(const SubscriptionResponse& from) : SubscriptionResponse(nullptr, from) {}
  inline SubscriptionResponse(SubscriptionResponse&& from) noexcept
      : SubscriptionResponse(nullptr, std::move(from)) {}
  inline SubscriptionResponse& operator=(const SubscriptionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscriptionResponse& operator=(SubscriptionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscriptionResponse& default_instance() {
    return *reinterpret_cast<const SubscriptionResponse*>(
        &_SubscriptionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 40;
  friend void swap(SubscriptionResponse& a, SubscriptionResponse& b) { a.Swap(&b); }
  inline void Swap(SubscriptionResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscriptionResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscriptionResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SubscriptionResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SubscriptionResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SubscriptionResponse& from) { SubscriptionResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SubscriptionResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.SubscriptionResponse"; }

 protected:
  explicit SubscriptionResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SubscriptionResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SubscriptionResponse& from);
  SubscriptionResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SubscriptionResponse&& from) noexcept
      : SubscriptionResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTrackSidFieldNumber = 1,
    kErrFieldNumber = 2,
  };
  // string track_sid = 1;
  void clear_track_sid() ;
  const std::string& track_sid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_track_sid(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_track_sid();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_track_sid();
  void set_allocated_track_sid(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_track_sid() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_track_sid(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_track_sid();

  public:
  // .livekit.SubscriptionError err = 2;
  void clear_err() ;
  ::livekit::SubscriptionError err() const;
  void set_err(::livekit::SubscriptionError value);

  private:
  ::livekit::SubscriptionError _internal_err() const;
  void _internal_set_err(::livekit::SubscriptionError value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.SubscriptionResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 46,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SubscriptionResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr track_sid_;
    int err_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SubscriptionResponse_class_data_;
// -------------------------------------------------------------------

class SubscriptionPermissionUpdate final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.SubscriptionPermissionUpdate) */ {
 public:
  inline SubscriptionPermissionUpdate() : SubscriptionPermissionUpdate(nullptr) {}
  ~SubscriptionPermissionUpdate() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SubscriptionPermissionUpdate* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SubscriptionPermissionUpdate));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubscriptionPermissionUpdate(::google::protobuf::internal::ConstantInitialized);

  inline SubscriptionPermissionUpdate(const SubscriptionPermissionUpdate& from) : SubscriptionPermissionUpdate(nullptr, from) {}
  inline SubscriptionPermissionUpdate(SubscriptionPermissionUpdate&& from) noexcept
      : SubscriptionPermissionUpdate(nullptr, std::move(from)) {}
  inline SubscriptionPermissionUpdate& operator=(const SubscriptionPermissionUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscriptionPermissionUpdate& operator=(SubscriptionPermissionUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscriptionPermissionUpdate& default_instance() {
    return *reinterpret_cast<const SubscriptionPermissionUpdate*>(
        &_SubscriptionPermissionUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 32;
  friend void swap(SubscriptionPermissionUpdate& a, SubscriptionPermissionUpdate& b) { a.Swap(&b); }
  inline void Swap(SubscriptionPermissionUpdate* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscriptionPermissionUpdate* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscriptionPermissionUpdate* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SubscriptionPermissionUpdate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SubscriptionPermissionUpdate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SubscriptionPermissionUpdate& from) { SubscriptionPermissionUpdate::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SubscriptionPermissionUpdate* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.SubscriptionPermissionUpdate"; }

 protected:
  explicit SubscriptionPermissionUpdate(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SubscriptionPermissionUpdate(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SubscriptionPermissionUpdate& from);
  SubscriptionPermissionUpdate(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SubscriptionPermissionUpdate&& from) noexcept
      : SubscriptionPermissionUpdate(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kParticipantSidFieldNumber = 1,
    kTrackSidFieldNumber = 2,
    kAllowedFieldNumber = 3,
  };
  // string participant_sid = 1;
  void clear_participant_sid() ;
  const std::string& participant_sid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_participant_sid(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_participant_sid();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_participant_sid();
  void set_allocated_participant_sid(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_participant_sid() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_participant_sid(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_participant_sid();

  public:
  // string track_sid = 2;
  void clear_track_sid() ;
  const std::string& track_sid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_track_sid(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_track_sid();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_track_sid();
  void set_allocated_track_sid(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_track_sid() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_track_sid(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_track_sid();

  public:
  // bool allowed = 3;
  void clear_allowed() ;
  bool allowed() const;
  void set_allowed(bool value);

  private:
  bool _internal_allowed() const;
  void _internal_set_allowed(bool value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.SubscriptionPermissionUpdate)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 69,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SubscriptionPermissionUpdate& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr participant_sid_;
    ::google::protobuf::internal::ArenaStringPtr track_sid_;
    bool allowed_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SubscriptionPermissionUpdate_class_data_;
// -------------------------------------------------------------------

class SubscribedQuality final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.SubscribedQuality) */ {
 public:
  inline SubscribedQuality() : SubscribedQuality(nullptr) {}
  ~SubscribedQuality() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SubscribedQuality* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SubscribedQuality));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribedQuality(::google::protobuf::internal::ConstantInitialized);

  inline SubscribedQuality(const SubscribedQuality& from) : SubscribedQuality(nullptr, from) {}
  inline SubscribedQuality(SubscribedQuality&& from) noexcept
      : SubscribedQuality(nullptr, std::move(from)) {}
  inline SubscribedQuality& operator=(const SubscribedQuality& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribedQuality& operator=(SubscribedQuality&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribedQuality& default_instance() {
    return *reinterpret_cast<const SubscribedQuality*>(
        &_SubscribedQuality_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 27;
  friend void swap(SubscribedQuality& a, SubscribedQuality& b) { a.Swap(&b); }
  inline void Swap(SubscribedQuality* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribedQuality* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribedQuality* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SubscribedQuality>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SubscribedQuality& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SubscribedQuality& from) { SubscribedQuality::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SubscribedQuality* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.SubscribedQuality"; }

 protected:
  explicit SubscribedQuality(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SubscribedQuality(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SubscribedQuality& from);
  SubscribedQuality(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SubscribedQuality&& from) noexcept
      : SubscribedQuality(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kQualityFieldNumber = 1,
    kEnabledFieldNumber = 2,
  };
  // .livekit.VideoQuality quality = 1;
  void clear_quality() ;
  ::livekit::VideoQuality quality() const;
  void set_quality(::livekit::VideoQuality value);

  private:
  ::livekit::VideoQuality _internal_quality() const;
  void _internal_set_quality(::livekit::VideoQuality value);

  public:
  // bool enabled = 2;
  void clear_enabled() ;
  bool enabled() const;
  void set_enabled(bool value);

  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.SubscribedQuality)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SubscribedQuality& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int quality_;
    bool enabled_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SubscribedQuality_class_data_;
// -------------------------------------------------------------------

class StreamStateInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.StreamStateInfo) */ {
 public:
  inline StreamStateInfo() : StreamStateInfo(nullptr) {}
  ~StreamStateInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(StreamStateInfo* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(StreamStateInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StreamStateInfo(::google::protobuf::internal::ConstantInitialized);

  inline StreamStateInfo(const StreamStateInfo& from) : StreamStateInfo(nullptr, from) {}
  inline StreamStateInfo(StreamStateInfo&& from) noexcept
      : StreamStateInfo(nullptr, std::move(from)) {}
  inline StreamStateInfo& operator=(const StreamStateInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamStateInfo& operator=(StreamStateInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamStateInfo& default_instance() {
    return *reinterpret_cast<const StreamStateInfo*>(
        &_StreamStateInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(StreamStateInfo& a, StreamStateInfo& b) { a.Swap(&b); }
  inline void Swap(StreamStateInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamStateInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamStateInfo* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<StreamStateInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StreamStateInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StreamStateInfo& from) { StreamStateInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(StreamStateInfo* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.StreamStateInfo"; }

 protected:
  explicit StreamStateInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  StreamStateInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const StreamStateInfo& from);
  StreamStateInfo(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, StreamStateInfo&& from) noexcept
      : StreamStateInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kParticipantSidFieldNumber = 1,
    kTrackSidFieldNumber = 2,
    kStateFieldNumber = 3,
  };
  // string participant_sid = 1;
  void clear_participant_sid() ;
  const std::string& participant_sid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_participant_sid(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_participant_sid();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_participant_sid();
  void set_allocated_participant_sid(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_participant_sid() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_participant_sid(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_participant_sid();

  public:
  // string track_sid = 2;
  void clear_track_sid() ;
  const std::string& track_sid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_track_sid(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_track_sid();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_track_sid();
  void set_allocated_track_sid(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_track_sid() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_track_sid(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_track_sid();

  public:
  // .livekit.StreamState state = 3;
  void clear_state() ;
  ::livekit::StreamState state() const;
  void set_state(::livekit::StreamState value);

  private:
  ::livekit::StreamState _internal_state() const;
  void _internal_set_state(::livekit::StreamState value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.StreamStateInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 56,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const StreamStateInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr participant_sid_;
    ::google::protobuf::internal::ArenaStringPtr track_sid_;
    int state_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull StreamStateInfo_class_data_;
// -------------------------------------------------------------------

class SimulcastCodec final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.SimulcastCodec) */ {
 public:
  inline SimulcastCodec() : SimulcastCodec(nullptr) {}
  ~SimulcastCodec() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SimulcastCodec* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SimulcastCodec));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SimulcastCodec(::google::protobuf::internal::ConstantInitialized);

  inline SimulcastCodec(const SimulcastCodec& from) : SimulcastCodec(nullptr, from) {}
  inline SimulcastCodec(SimulcastCodec&& from) noexcept
      : SimulcastCodec(nullptr, std::move(from)) {}
  inline SimulcastCodec& operator=(const SimulcastCodec& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimulcastCodec& operator=(SimulcastCodec&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SimulcastCodec& default_instance() {
    return *reinterpret_cast<const SimulcastCodec*>(
        &_SimulcastCodec_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(SimulcastCodec& a, SimulcastCodec& b) { a.Swap(&b); }
  inline void Swap(SimulcastCodec* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimulcastCodec* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SimulcastCodec* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SimulcastCodec>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SimulcastCodec& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SimulcastCodec& from) { SimulcastCodec::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SimulcastCodec* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.SimulcastCodec"; }

 protected:
  explicit SimulcastCodec(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SimulcastCodec(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SimulcastCodec& from);
  SimulcastCodec(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SimulcastCodec&& from) noexcept
      : SimulcastCodec(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCodecFieldNumber = 1,
    kCidFieldNumber = 2,
  };
  // string codec = 1;
  void clear_codec() ;
  const std::string& codec() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_codec(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_codec();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_codec();
  void set_allocated_codec(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_codec() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_codec(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_codec();

  public:
  // string cid = 2;
  void clear_cid() ;
  const std::string& cid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cid(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_cid();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_cid();
  void set_allocated_cid(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_cid() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_cid();

  public:
  // @@protoc_insertion_point(class_scope:livekit.SimulcastCodec)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 39,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SimulcastCodec& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr codec_;
    ::google::protobuf::internal::ArenaStringPtr cid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SimulcastCodec_class_data_;
// -------------------------------------------------------------------

class SimulateScenario final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.SimulateScenario) */ {
 public:
  inline SimulateScenario() : SimulateScenario(nullptr) {}
  ~SimulateScenario() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SimulateScenario* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SimulateScenario));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SimulateScenario(::google::protobuf::internal::ConstantInitialized);

  inline SimulateScenario(const SimulateScenario& from) : SimulateScenario(nullptr, from) {}
  inline SimulateScenario(SimulateScenario&& from) noexcept
      : SimulateScenario(nullptr, std::move(from)) {}
  inline SimulateScenario& operator=(const SimulateScenario& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimulateScenario& operator=(SimulateScenario&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SimulateScenario& default_instance() {
    return *reinterpret_cast<const SimulateScenario*>(
        &_SimulateScenario_default_instance_);
  }
  enum ScenarioCase {
    kSpeakerUpdate = 1,
    kNodeFailure = 2,
    kMigration = 3,
    kServerLeave = 4,
    kSwitchCandidateProtocol = 5,
    kSubscriberBandwidth = 6,
    kDisconnectSignalOnResume = 7,
    kDisconnectSignalOnResumeNoMessages = 8,
    kLeaveRequestFullReconnect = 9,
    SCENARIO_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 35;
  friend void swap(SimulateScenario& a, SimulateScenario& b) { a.Swap(&b); }
  inline void Swap(SimulateScenario* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimulateScenario* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SimulateScenario* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SimulateScenario>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SimulateScenario& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SimulateScenario& from) { SimulateScenario::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SimulateScenario* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.SimulateScenario"; }

 protected:
  explicit SimulateScenario(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SimulateScenario(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SimulateScenario& from);
  SimulateScenario(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SimulateScenario&& from) noexcept
      : SimulateScenario(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSpeakerUpdateFieldNumber = 1,
    kNodeFailureFieldNumber = 2,
    kMigrationFieldNumber = 3,
    kServerLeaveFieldNumber = 4,
    kSwitchCandidateProtocolFieldNumber = 5,
    kSubscriberBandwidthFieldNumber = 6,
    kDisconnectSignalOnResumeFieldNumber = 7,
    kDisconnectSignalOnResumeNoMessagesFieldNumber = 8,
    kLeaveRequestFullReconnectFieldNumber = 9,
  };
  // int32 speaker_update = 1;
  bool has_speaker_update() const;
  void clear_speaker_update() ;
  ::int32_t speaker_update() const;
  void set_speaker_update(::int32_t value);

  private:
  ::int32_t _internal_speaker_update() const;
  void _internal_set_speaker_update(::int32_t value);

  public:
  // bool node_failure = 2;
  bool has_node_failure() const;
  void clear_node_failure() ;
  bool node_failure() const;
  void set_node_failure(bool value);

  private:
  bool _internal_node_failure() const;
  void _internal_set_node_failure(bool value);

  public:
  // bool migration = 3;
  bool has_migration() const;
  void clear_migration() ;
  bool migration() const;
  void set_migration(bool value);

  private:
  bool _internal_migration() const;
  void _internal_set_migration(bool value);

  public:
  // bool server_leave = 4;
  bool has_server_leave() const;
  void clear_server_leave() ;
  bool server_leave() const;
  void set_server_leave(bool value);

  private:
  bool _internal_server_leave() const;
  void _internal_set_server_leave(bool value);

  public:
  // .livekit.CandidateProtocol switch_candidate_protocol = 5;
  bool has_switch_candidate_protocol() const;
  void clear_switch_candidate_protocol() ;
  ::livekit::CandidateProtocol switch_candidate_protocol() const;
  void set_switch_candidate_protocol(::livekit::CandidateProtocol value);

  private:
  ::livekit::CandidateProtocol _internal_switch_candidate_protocol() const;
  void _internal_set_switch_candidate_protocol(::livekit::CandidateProtocol value);

  public:
  // int64 subscriber_bandwidth = 6;
  bool has_subscriber_bandwidth() const;
  void clear_subscriber_bandwidth() ;
  ::int64_t subscriber_bandwidth() const;
  void set_subscriber_bandwidth(::int64_t value);

  private:
  ::int64_t _internal_subscriber_bandwidth() const;
  void _internal_set_subscriber_bandwidth(::int64_t value);

  public:
  // bool disconnect_signal_on_resume = 7;
  bool has_disconnect_signal_on_resume() const;
  void clear_disconnect_signal_on_resume() ;
  bool disconnect_signal_on_resume() const;
  void set_disconnect_signal_on_resume(bool value);

  private:
  bool _internal_disconnect_signal_on_resume() const;
  void _internal_set_disconnect_signal_on_resume(bool value);

  public:
  // bool disconnect_signal_on_resume_no_messages = 8;
  bool has_disconnect_signal_on_resume_no_messages() const;
  void clear_disconnect_signal_on_resume_no_messages() ;
  bool disconnect_signal_on_resume_no_messages() const;
  void set_disconnect_signal_on_resume_no_messages(bool value);

  private:
  bool _internal_disconnect_signal_on_resume_no_messages() const;
  void _internal_set_disconnect_signal_on_resume_no_messages(bool value);

  public:
  // bool leave_request_full_reconnect = 9;
  bool has_leave_request_full_reconnect() const;
  void clear_leave_request_full_reconnect() ;
  bool leave_request_full_reconnect() const;
  void set_leave_request_full_reconnect(bool value);

  private:
  bool _internal_leave_request_full_reconnect() const;
  void _internal_set_leave_request_full_reconnect(bool value);

  public:
  void clear_scenario();
  ScenarioCase scenario_case() const;
  // @@protoc_insertion_point(class_scope:livekit.SimulateScenario)
 private:
  class _Internal;
  void set_has_speaker_update();
  void set_has_node_failure();
  void set_has_migration();
  void set_has_server_leave();
  void set_has_switch_candidate_protocol();
  void set_has_subscriber_bandwidth();
  void set_has_disconnect_signal_on_resume();
  void set_has_disconnect_signal_on_resume_no_messages();
  void set_has_leave_request_full_reconnect();
  inline bool has_scenario() const;
  inline void clear_has_scenario();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 9,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SimulateScenario& from_msg);
    union ScenarioUnion {
      constexpr ScenarioUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int32_t speaker_update_;
      bool node_failure_;
      bool migration_;
      bool server_leave_;
      int switch_candidate_protocol_;
      ::int64_t subscriber_bandwidth_;
      bool disconnect_signal_on_resume_;
      bool disconnect_signal_on_resume_no_messages_;
      bool leave_request_full_reconnect_;
    } scenario_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SimulateScenario_class_data_;
// -------------------------------------------------------------------

class SessionDescription final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.SessionDescription) */ {
 public:
  inline SessionDescription() : SessionDescription(nullptr) {}
  ~SessionDescription() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SessionDescription* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SessionDescription));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SessionDescription(::google::protobuf::internal::ConstantInitialized);

  inline SessionDescription(const SessionDescription& from) : SessionDescription(nullptr, from) {}
  inline SessionDescription(SessionDescription&& from) noexcept
      : SessionDescription(nullptr, std::move(from)) {}
  inline SessionDescription& operator=(const SessionDescription& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionDescription& operator=(SessionDescription&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SessionDescription& default_instance() {
    return *reinterpret_cast<const SessionDescription*>(
        &_SessionDescription_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(SessionDescription& a, SessionDescription& b) { a.Swap(&b); }
  inline void Swap(SessionDescription* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionDescription* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionDescription* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SessionDescription>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SessionDescription& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SessionDescription& from) { SessionDescription::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SessionDescription* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.SessionDescription"; }

 protected:
  explicit SessionDescription(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SessionDescription(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SessionDescription& from);
  SessionDescription(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SessionDescription&& from) noexcept
      : SessionDescription(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTypeFieldNumber = 1,
    kSdpFieldNumber = 2,
  };
  // string type = 1;
  void clear_type() ;
  const std::string& type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_type();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_type();
  void set_allocated_type(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_type() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_type();

  public:
  // string sdp = 2;
  void clear_sdp() ;
  const std::string& sdp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sdp(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_sdp();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_sdp();
  void set_allocated_sdp(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_sdp() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_sdp(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_sdp();

  public:
  // @@protoc_insertion_point(class_scope:livekit.SessionDescription)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 42,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SessionDescription& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr type_;
    ::google::protobuf::internal::ArenaStringPtr sdp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SessionDescription_class_data_;
// -------------------------------------------------------------------

class RequestResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.RequestResponse) */ {
 public:
  inline RequestResponse() : RequestResponse(nullptr) {}
  ~RequestResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RequestResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RequestResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RequestResponse(::google::protobuf::internal::ConstantInitialized);

  inline RequestResponse(const RequestResponse& from) : RequestResponse(nullptr, from) {}
  inline RequestResponse(RequestResponse&& from) noexcept
      : RequestResponse(nullptr, std::move(from)) {}
  inline RequestResponse& operator=(const RequestResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestResponse& operator=(RequestResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestResponse& default_instance() {
    return *reinterpret_cast<const RequestResponse*>(
        &_RequestResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 41;
  friend void swap(RequestResponse& a, RequestResponse& b) { a.Swap(&b); }
  inline void Swap(RequestResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RequestResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RequestResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RequestResponse& from) { RequestResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RequestResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.RequestResponse"; }

 protected:
  explicit RequestResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RequestResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RequestResponse& from);
  RequestResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RequestResponse&& from) noexcept
      : RequestResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Reason = RequestResponse_Reason;
  static constexpr Reason OK = RequestResponse_Reason_OK;
  static constexpr Reason NOT_FOUND = RequestResponse_Reason_NOT_FOUND;
  static constexpr Reason NOT_ALLOWED = RequestResponse_Reason_NOT_ALLOWED;
  static constexpr Reason LIMIT_EXCEEDED = RequestResponse_Reason_LIMIT_EXCEEDED;
  static inline bool Reason_IsValid(int value) {
    return RequestResponse_Reason_IsValid(value);
  }
  static constexpr Reason Reason_MIN = RequestResponse_Reason_Reason_MIN;
  static constexpr Reason Reason_MAX = RequestResponse_Reason_Reason_MAX;
  static constexpr int Reason_ARRAYSIZE = RequestResponse_Reason_Reason_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Reason_descriptor() {
    return RequestResponse_Reason_descriptor();
  }
  template <typename T>
  static inline const std::string& Reason_Name(T value) {
    return RequestResponse_Reason_Name(value);
  }
  static inline bool Reason_Parse(
      absl::string_view name, Reason* PROTOBUF_NONNULL value) {
    return RequestResponse_Reason_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kMessageFieldNumber = 3,
    kRequestIdFieldNumber = 1,
    kReasonFieldNumber = 2,
  };
  // string message = 3;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_message();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_message();
  void set_allocated_message(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_message() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_message();

  public:
  // uint32 request_id = 1;
  void clear_request_id() ;
  ::uint32_t request_id() const;
  void set_request_id(::uint32_t value);

  private:
  ::uint32_t _internal_request_id() const;
  void _internal_set_request_id(::uint32_t value);

  public:
  // .livekit.RequestResponse.Reason reason = 2;
  void clear_reason() ;
  ::livekit::RequestResponse_Reason reason() const;
  void set_reason(::livekit::RequestResponse_Reason value);

  private:
  ::livekit::RequestResponse_Reason _internal_reason() const;
  void _internal_set_reason(::livekit::RequestResponse_Reason value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.RequestResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 39,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RequestResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::uint32_t request_id_;
    int reason_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RequestResponse_class_data_;
// -------------------------------------------------------------------

class RegionInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.RegionInfo) */ {
 public:
  inline RegionInfo() : RegionInfo(nullptr) {}
  ~RegionInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RegionInfo* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RegionInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegionInfo(::google::protobuf::internal::ConstantInitialized);

  inline RegionInfo(const RegionInfo& from) : RegionInfo(nullptr, from) {}
  inline RegionInfo(RegionInfo&& from) noexcept
      : RegionInfo(nullptr, std::move(from)) {}
  inline RegionInfo& operator=(const RegionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionInfo& operator=(RegionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegionInfo& default_instance() {
    return *reinterpret_cast<const RegionInfo*>(
        &_RegionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 39;
  friend void swap(RegionInfo& a, RegionInfo& b) { a.Swap(&b); }
  inline void Swap(RegionInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegionInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegionInfo* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RegionInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegionInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegionInfo& from) { RegionInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RegionInfo* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.RegionInfo"; }

 protected:
  explicit RegionInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RegionInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RegionInfo& from);
  RegionInfo(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RegionInfo&& from) noexcept
      : RegionInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRegionFieldNumber = 1,
    kUrlFieldNumber = 2,
    kDistanceFieldNumber = 3,
  };
  // string region = 1;
  void clear_region() ;
  const std::string& region() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_region(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_region();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_region();
  void set_allocated_region(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_region() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_region(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_region();

  public:
  // string url = 2;
  void clear_url() ;
  const std::string& url() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_url(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_url();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_url();
  void set_allocated_url(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_url() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_url();

  public:
  // int64 distance = 3;
  void clear_distance() ;
  ::int64_t distance() const;
  void set_distance(::int64_t value);

  private:
  ::int64_t _internal_distance() const;
  void _internal_set_distance(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.RegionInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 36,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RegionInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr region_;
    ::google::protobuf::internal::ArenaStringPtr url_;
    ::int64_t distance_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RegionInfo_class_data_;
// -------------------------------------------------------------------

class Pong final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.Pong) */ {
 public:
  inline Pong() : Pong(nullptr) {}
  ~Pong() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Pong* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Pong));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Pong(::google::protobuf::internal::ConstantInitialized);

  inline Pong(const Pong& from) : Pong(nullptr, from) {}
  inline Pong(Pong&& from) noexcept
      : Pong(nullptr, std::move(from)) {}
  inline Pong& operator=(const Pong& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pong& operator=(Pong&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pong& default_instance() {
    return *reinterpret_cast<const Pong*>(
        &_Pong_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 37;
  friend void swap(Pong& a, Pong& b) { a.Swap(&b); }
  inline void Swap(Pong* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pong* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pong* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Pong>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Pong& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Pong& from) { Pong::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Pong* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.Pong"; }

 protected:
  explicit Pong(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Pong(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Pong& from);
  Pong(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Pong&& from) noexcept
      : Pong(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLastPingTimestampFieldNumber = 1,
    kTimestampFieldNumber = 2,
  };
  // int64 last_ping_timestamp = 1;
  void clear_last_ping_timestamp() ;
  ::int64_t last_ping_timestamp() const;
  void set_last_ping_timestamp(::int64_t value);

  private:
  ::int64_t _internal_last_ping_timestamp() const;
  void _internal_set_last_ping_timestamp(::int64_t value);

  public:
  // int64 timestamp = 2;
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.Pong)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Pong& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t last_ping_timestamp_;
    ::int64_t timestamp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Pong_class_data_;
// -------------------------------------------------------------------

class Ping final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.Ping) */ {
 public:
  inline Ping() : Ping(nullptr) {}
  ~Ping() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Ping* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Ping));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Ping(::google::protobuf::internal::ConstantInitialized);

  inline Ping(const Ping& from) : Ping(nullptr, from) {}
  inline Ping(Ping&& from) noexcept
      : Ping(nullptr, std::move(from)) {}
  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ping& operator=(Ping&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ping& default_instance() {
    return *reinterpret_cast<const Ping*>(
        &_Ping_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 36;
  friend void swap(Ping& a, Ping& b) { a.Swap(&b); }
  inline void Swap(Ping* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ping* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ping* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Ping>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Ping& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Ping& from) { Ping::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Ping* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.Ping"; }

 protected:
  explicit Ping(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Ping(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Ping& from);
  Ping(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Ping&& from) noexcept
      : Ping(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTimestampFieldNumber = 1,
    kRttFieldNumber = 2,
  };
  // int64 timestamp = 1;
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // int64 rtt = 2;
  void clear_rtt() ;
  ::int64_t rtt() const;
  void set_rtt(::int64_t value);

  private:
  ::int64_t _internal_rtt() const;
  void _internal_set_rtt(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.Ping)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Ping& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t timestamp_;
    ::int64_t rtt_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Ping_class_data_;
// -------------------------------------------------------------------

class MuteTrackRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.MuteTrackRequest) */ {
 public:
  inline MuteTrackRequest() : MuteTrackRequest(nullptr) {}
  ~MuteTrackRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MuteTrackRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MuteTrackRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MuteTrackRequest(::google::protobuf::internal::ConstantInitialized);

  inline MuteTrackRequest(const MuteTrackRequest& from) : MuteTrackRequest(nullptr, from) {}
  inline MuteTrackRequest(MuteTrackRequest&& from) noexcept
      : MuteTrackRequest(nullptr, std::move(from)) {}
  inline MuteTrackRequest& operator=(const MuteTrackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MuteTrackRequest& operator=(MuteTrackRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MuteTrackRequest& default_instance() {
    return *reinterpret_cast<const MuteTrackRequest*>(
        &_MuteTrackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(MuteTrackRequest& a, MuteTrackRequest& b) { a.Swap(&b); }
  inline void Swap(MuteTrackRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MuteTrackRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MuteTrackRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MuteTrackRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MuteTrackRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MuteTrackRequest& from) { MuteTrackRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MuteTrackRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.MuteTrackRequest"; }

 protected:
  explicit MuteTrackRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MuteTrackRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MuteTrackRequest& from);
  MuteTrackRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MuteTrackRequest&& from) noexcept
      : MuteTrackRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSidFieldNumber = 1,
    kMutedFieldNumber = 2,
  };
  // string sid = 1;
  void clear_sid() ;
  const std::string& sid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sid(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_sid();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_sid();
  void set_allocated_sid(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_sid() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_sid(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_sid();

  public:
  // bool muted = 2;
  void clear_muted() ;
  bool muted() const;
  void set_muted(bool value);

  private:
  bool _internal_muted() const;
  void _internal_set_muted(bool value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.MuteTrackRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 36,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MuteTrackRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr sid_;
    bool muted_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MuteTrackRequest_class_data_;
// -------------------------------------------------------------------

class ICEServer final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.ICEServer) */ {
 public:
  inline ICEServer() : ICEServer(nullptr) {}
  ~ICEServer() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ICEServer* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ICEServer));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ICEServer(::google::protobuf::internal::ConstantInitialized);

  inline ICEServer(const ICEServer& from) : ICEServer(nullptr, from) {}
  inline ICEServer(ICEServer&& from) noexcept
      : ICEServer(nullptr, std::move(from)) {}
  inline ICEServer& operator=(const ICEServer& from) {
    CopyFrom(from);
    return *this;
  }
  inline ICEServer& operator=(ICEServer&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ICEServer& default_instance() {
    return *reinterpret_cast<const ICEServer*>(
        &_ICEServer_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(ICEServer& a, ICEServer& b) { a.Swap(&b); }
  inline void Swap(ICEServer* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ICEServer* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ICEServer* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ICEServer>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ICEServer& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ICEServer& from) { ICEServer::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ICEServer* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.ICEServer"; }

 protected:
  explicit ICEServer(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ICEServer(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ICEServer& from);
  ICEServer(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ICEServer&& from) noexcept
      : ICEServer(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUrlsFieldNumber = 1,
    kUsernameFieldNumber = 2,
    kCredentialFieldNumber = 3,
  };
  // repeated string urls = 1;
  int urls_size() const;
  private:
  int _internal_urls_size() const;

  public:
  void clear_urls() ;
  const std::string& urls(int index) const;
  std::string* PROTOBUF_NONNULL mutable_urls(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_urls(int index, Arg_&& value, Args_... args);
  std::string* PROTOBUF_NONNULL add_urls();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_urls(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& urls() const;
  ::google::protobuf::RepeatedPtrField<std::string>* PROTOBUF_NONNULL mutable_urls();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_urls() const;
  ::google::protobuf::RepeatedPtrField<std::string>* PROTOBUF_NONNULL _internal_mutable_urls();

  public:
  // string username = 2;
  void clear_username() ;
  const std::string& username() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_username(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_username();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_username();
  void set_allocated_username(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_username() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_username();

  public:
  // string credential = 3;
  void clear_credential() ;
  const std::string& credential() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_credential(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_credential();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_credential();
  void set_allocated_credential(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_credential() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_credential(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_credential();

  public:
  // @@protoc_insertion_point(class_scope:livekit.ICEServer)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 48,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ICEServer& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> urls_;
    ::google::protobuf::internal::ArenaStringPtr username_;
    ::google::protobuf::internal::ArenaStringPtr credential_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ICEServer_class_data_;
// -------------------------------------------------------------------

class DataChannelInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.DataChannelInfo) */ {
 public:
  inline DataChannelInfo() : DataChannelInfo(nullptr) {}
  ~DataChannelInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DataChannelInfo* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DataChannelInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DataChannelInfo(::google::protobuf::internal::ConstantInitialized);

  inline DataChannelInfo(const DataChannelInfo& from) : DataChannelInfo(nullptr, from) {}
  inline DataChannelInfo(DataChannelInfo&& from) noexcept
      : DataChannelInfo(nullptr, std::move(from)) {}
  inline DataChannelInfo& operator=(const DataChannelInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataChannelInfo& operator=(DataChannelInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataChannelInfo& default_instance() {
    return *reinterpret_cast<const DataChannelInfo*>(
        &_DataChannelInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 34;
  friend void swap(DataChannelInfo& a, DataChannelInfo& b) { a.Swap(&b); }
  inline void Swap(DataChannelInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataChannelInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataChannelInfo* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DataChannelInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DataChannelInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DataChannelInfo& from) { DataChannelInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DataChannelInfo* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.DataChannelInfo"; }

 protected:
  explicit DataChannelInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DataChannelInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DataChannelInfo& from);
  DataChannelInfo(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DataChannelInfo&& from) noexcept
      : DataChannelInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLabelFieldNumber = 1,
    kIdFieldNumber = 2,
    kTargetFieldNumber = 3,
  };
  // string label = 1;
  void clear_label() ;
  const std::string& label() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_label(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_label();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_label();
  void set_allocated_label(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_label() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_label(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_label();

  public:
  // uint32 id = 2;
  void clear_id() ;
  ::uint32_t id() const;
  void set_id(::uint32_t value);

  private:
  ::uint32_t _internal_id() const;
  void _internal_set_id(::uint32_t value);

  public:
  // .livekit.SignalTarget target = 3;
  void clear_target() ;
  ::livekit::SignalTarget target() const;
  void set_target(::livekit::SignalTarget value);

  private:
  ::livekit::SignalTarget _internal_target() const;
  void _internal_set_target(::livekit::SignalTarget value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.DataChannelInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 37,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DataChannelInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr label_;
    ::uint32_t id_;
    int target_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DataChannelInfo_class_data_;
// -------------------------------------------------------------------

class ConnectionQualityInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.ConnectionQualityInfo) */ {
 public:
  inline ConnectionQualityInfo() : ConnectionQualityInfo(nullptr) {}
  ~ConnectionQualityInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ConnectionQualityInfo* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ConnectionQualityInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ConnectionQualityInfo(::google::protobuf::internal::ConstantInitialized);

  inline ConnectionQualityInfo(const ConnectionQualityInfo& from) : ConnectionQualityInfo(nullptr, from) {}
  inline ConnectionQualityInfo(ConnectionQualityInfo&& from) noexcept
      : ConnectionQualityInfo(nullptr, std::move(from)) {}
  inline ConnectionQualityInfo& operator=(const ConnectionQualityInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectionQualityInfo& operator=(ConnectionQualityInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectionQualityInfo& default_instance() {
    return *reinterpret_cast<const ConnectionQualityInfo*>(
        &_ConnectionQualityInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(ConnectionQualityInfo& a, ConnectionQualityInfo& b) { a.Swap(&b); }
  inline void Swap(ConnectionQualityInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectionQualityInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectionQualityInfo* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ConnectionQualityInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ConnectionQualityInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ConnectionQualityInfo& from) { ConnectionQualityInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ConnectionQualityInfo* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.ConnectionQualityInfo"; }

 protected:
  explicit ConnectionQualityInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ConnectionQualityInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ConnectionQualityInfo& from);
  ConnectionQualityInfo(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ConnectionQualityInfo&& from) noexcept
      : ConnectionQualityInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kParticipantSidFieldNumber = 1,
    kQualityFieldNumber = 2,
    kScoreFieldNumber = 3,
  };
  // string participant_sid = 1;
  void clear_participant_sid() ;
  const std::string& participant_sid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_participant_sid(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_participant_sid();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_participant_sid();
  void set_allocated_participant_sid(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_participant_sid() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_participant_sid(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_participant_sid();

  public:
  // .livekit.ConnectionQuality quality = 2;
  void clear_quality() ;
  ::livekit::ConnectionQuality quality() const;
  void set_quality(::livekit::ConnectionQuality value);

  private:
  ::livekit::ConnectionQuality _internal_quality() const;
  void _internal_set_quality(::livekit::ConnectionQuality value);

  public:
  // float score = 3;
  void clear_score() ;
  float score() const;
  void set_score(float value);

  private:
  float _internal_score() const;
  void _internal_set_score(float value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.ConnectionQualityInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 53,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ConnectionQualityInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr participant_sid_;
    int quality_;
    float score_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ConnectionQualityInfo_class_data_;
// -------------------------------------------------------------------

class UpdateVideoLayers final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.UpdateVideoLayers) */ {
 public:
  inline UpdateVideoLayers() : UpdateVideoLayers(nullptr) {}
  ~UpdateVideoLayers() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateVideoLayers* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateVideoLayers));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateVideoLayers(::google::protobuf::internal::ConstantInitialized);

  inline UpdateVideoLayers(const UpdateVideoLayers& from) : UpdateVideoLayers(nullptr, from) {}
  inline UpdateVideoLayers(UpdateVideoLayers&& from) noexcept
      : UpdateVideoLayers(nullptr, std::move(from)) {}
  inline UpdateVideoLayers& operator=(const UpdateVideoLayers& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateVideoLayers& operator=(UpdateVideoLayers&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateVideoLayers& default_instance() {
    return *reinterpret_cast<const UpdateVideoLayers*>(
        &_UpdateVideoLayers_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(UpdateVideoLayers& a, UpdateVideoLayers& b) { a.Swap(&b); }
  inline void Swap(UpdateVideoLayers* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateVideoLayers* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateVideoLayers* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateVideoLayers>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateVideoLayers& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateVideoLayers& from) { UpdateVideoLayers::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateVideoLayers* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.UpdateVideoLayers"; }

 protected:
  explicit UpdateVideoLayers(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UpdateVideoLayers(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UpdateVideoLayers& from);
  UpdateVideoLayers(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UpdateVideoLayers&& from) noexcept
      : UpdateVideoLayers(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLayersFieldNumber = 2,
    kTrackSidFieldNumber = 1,
  };
  // repeated .livekit.VideoLayer layers = 2;
  int layers_size() const;
  private:
  int _internal_layers_size() const;

  public:
  void clear_layers() ;
  ::livekit::VideoLayer* PROTOBUF_NONNULL mutable_layers(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::VideoLayer>* PROTOBUF_NONNULL mutable_layers();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::VideoLayer>& _internal_layers() const;
  ::google::protobuf::RepeatedPtrField<::livekit::VideoLayer>* PROTOBUF_NONNULL _internal_mutable_layers();
  public:
  const ::livekit::VideoLayer& layers(int index) const;
  ::livekit::VideoLayer* PROTOBUF_NONNULL add_layers();
  const ::google::protobuf::RepeatedPtrField<::livekit::VideoLayer>& layers() const;
  // string track_sid = 1;
  void clear_track_sid() ;
  const std::string& track_sid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_track_sid(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_track_sid();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_track_sid();
  void set_allocated_track_sid(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_track_sid() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_track_sid(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_track_sid();

  public:
  // @@protoc_insertion_point(class_scope:livekit.UpdateVideoLayers)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 43,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UpdateVideoLayers& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::livekit::VideoLayer > layers_;
    ::google::protobuf::internal::ArenaStringPtr track_sid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UpdateVideoLayers_class_data_;
// -------------------------------------------------------------------

class UpdateSubscription final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.UpdateSubscription) */ {
 public:
  inline UpdateSubscription() : UpdateSubscription(nullptr) {}
  ~UpdateSubscription() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateSubscription* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateSubscription));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateSubscription(::google::protobuf::internal::ConstantInitialized);

  inline UpdateSubscription(const UpdateSubscription& from) : UpdateSubscription(nullptr, from) {}
  inline UpdateSubscription(UpdateSubscription&& from) noexcept
      : UpdateSubscription(nullptr, std::move(from)) {}
  inline UpdateSubscription& operator=(const UpdateSubscription& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateSubscription& operator=(UpdateSubscription&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateSubscription& default_instance() {
    return *reinterpret_cast<const UpdateSubscription*>(
        &_UpdateSubscription_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(UpdateSubscription& a, UpdateSubscription& b) { a.Swap(&b); }
  inline void Swap(UpdateSubscription* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateSubscription* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateSubscription* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateSubscription>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateSubscription& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateSubscription& from) { UpdateSubscription::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateSubscription* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.UpdateSubscription"; }

 protected:
  explicit UpdateSubscription(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UpdateSubscription(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UpdateSubscription& from);
  UpdateSubscription(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UpdateSubscription&& from) noexcept
      : UpdateSubscription(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTrackSidsFieldNumber = 1,
    kParticipantTracksFieldNumber = 3,
    kSubscribeFieldNumber = 2,
  };
  // repeated string track_sids = 1;
  int track_sids_size() const;
  private:
  int _internal_track_sids_size() const;

  public:
  void clear_track_sids() ;
  const std::string& track_sids(int index) const;
  std::string* PROTOBUF_NONNULL mutable_track_sids(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_track_sids(int index, Arg_&& value, Args_... args);
  std::string* PROTOBUF_NONNULL add_track_sids();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_track_sids(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& track_sids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* PROTOBUF_NONNULL mutable_track_sids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_track_sids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* PROTOBUF_NONNULL _internal_mutable_track_sids();

  public:
  // repeated .livekit.ParticipantTracks participant_tracks = 3;
  int participant_tracks_size() const;
  private:
  int _internal_participant_tracks_size() const;

  public:
  void clear_participant_tracks() ;
  ::livekit::ParticipantTracks* PROTOBUF_NONNULL mutable_participant_tracks(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::ParticipantTracks>* PROTOBUF_NONNULL mutable_participant_tracks();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::ParticipantTracks>& _internal_participant_tracks() const;
  ::google::protobuf::RepeatedPtrField<::livekit::ParticipantTracks>* PROTOBUF_NONNULL _internal_mutable_participant_tracks();
  public:
  const ::livekit::ParticipantTracks& participant_tracks(int index) const;
  ::livekit::ParticipantTracks* PROTOBUF_NONNULL add_participant_tracks();
  const ::google::protobuf::RepeatedPtrField<::livekit::ParticipantTracks>& participant_tracks() const;
  // bool subscribe = 2;
  void clear_subscribe() ;
  bool subscribe() const;
  void set_subscribe(bool value);

  private:
  bool _internal_subscribe() const;
  void _internal_set_subscribe(bool value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.UpdateSubscription)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   1, 45,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UpdateSubscription& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> track_sids_;
    ::google::protobuf::RepeatedPtrField< ::livekit::ParticipantTracks > participant_tracks_;
    bool subscribe_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UpdateSubscription_class_data_;
// -------------------------------------------------------------------

class UpdateParticipantMetadata final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.UpdateParticipantMetadata) */ {
 public:
  inline UpdateParticipantMetadata() : UpdateParticipantMetadata(nullptr) {}
  ~UpdateParticipantMetadata() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateParticipantMetadata* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateParticipantMetadata));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateParticipantMetadata(::google::protobuf::internal::ConstantInitialized);

  inline UpdateParticipantMetadata(const UpdateParticipantMetadata& from) : UpdateParticipantMetadata(nullptr, from) {}
  inline UpdateParticipantMetadata(UpdateParticipantMetadata&& from) noexcept
      : UpdateParticipantMetadata(nullptr, std::move(from)) {}
  inline UpdateParticipantMetadata& operator=(const UpdateParticipantMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateParticipantMetadata& operator=(UpdateParticipantMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateParticipantMetadata& default_instance() {
    return *reinterpret_cast<const UpdateParticipantMetadata*>(
        &_UpdateParticipantMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(UpdateParticipantMetadata& a, UpdateParticipantMetadata& b) { a.Swap(&b); }
  inline void Swap(UpdateParticipantMetadata* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateParticipantMetadata* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateParticipantMetadata* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateParticipantMetadata>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateParticipantMetadata& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateParticipantMetadata& from) { UpdateParticipantMetadata::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateParticipantMetadata* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.UpdateParticipantMetadata"; }

 protected:
  explicit UpdateParticipantMetadata(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UpdateParticipantMetadata(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UpdateParticipantMetadata& from);
  UpdateParticipantMetadata(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UpdateParticipantMetadata&& from) noexcept
      : UpdateParticipantMetadata(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAttributesFieldNumber = 3,
    kMetadataFieldNumber = 1,
    kNameFieldNumber = 2,
    kRequestIdFieldNumber = 4,
  };
  // map<string, string> attributes = 3;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;

  public:
  void clear_attributes() ;
  const ::google::protobuf::Map<std::string, std::string>& attributes() const;
  ::google::protobuf::Map<std::string, std::string>* PROTOBUF_NONNULL mutable_attributes();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_attributes() const;
  ::google::protobuf::Map<std::string, std::string>* PROTOBUF_NONNULL _internal_mutable_attributes();

  public:
  // string metadata = 1;
  void clear_metadata() ;
  const std::string& metadata() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_metadata(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_metadata();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_metadata();
  void set_allocated_metadata(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_metadata() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_metadata(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_metadata();

  public:
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // uint32 request_id = 4;
  void clear_request_id() ;
  ::uint32_t request_id() const;
  void set_request_id(::uint32_t value);

  private:
  ::uint32_t _internal_request_id() const;
  void _internal_set_request_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.UpdateParticipantMetadata)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   1, 64,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UpdateParticipantMetadata& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::MapField<UpdateParticipantMetadata_AttributesEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        attributes_;
    ::google::protobuf::internal::ArenaStringPtr metadata_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::uint32_t request_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UpdateParticipantMetadata_class_data_;
// -------------------------------------------------------------------

class SubscriptionPermission final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.SubscriptionPermission) */ {
 public:
  inline SubscriptionPermission() : SubscriptionPermission(nullptr) {}
  ~SubscriptionPermission() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SubscriptionPermission* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SubscriptionPermission));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubscriptionPermission(::google::protobuf::internal::ConstantInitialized);

  inline SubscriptionPermission(const SubscriptionPermission& from) : SubscriptionPermission(nullptr, from) {}
  inline SubscriptionPermission(SubscriptionPermission&& from) noexcept
      : SubscriptionPermission(nullptr, std::move(from)) {}
  inline SubscriptionPermission& operator=(const SubscriptionPermission& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscriptionPermission& operator=(SubscriptionPermission&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscriptionPermission& default_instance() {
    return *reinterpret_cast<const SubscriptionPermission*>(
        &_SubscriptionPermission_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 31;
  friend void swap(SubscriptionPermission& a, SubscriptionPermission& b) { a.Swap(&b); }
  inline void Swap(SubscriptionPermission* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscriptionPermission* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscriptionPermission* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SubscriptionPermission>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SubscriptionPermission& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SubscriptionPermission& from) { SubscriptionPermission::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SubscriptionPermission* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.SubscriptionPermission"; }

 protected:
  explicit SubscriptionPermission(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SubscriptionPermission(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SubscriptionPermission& from);
  SubscriptionPermission(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SubscriptionPermission&& from) noexcept
      : SubscriptionPermission(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTrackPermissionsFieldNumber = 2,
    kAllParticipantsFieldNumber = 1,
  };
  // repeated .livekit.TrackPermission track_permissions = 2;
  int track_permissions_size() const;
  private:
  int _internal_track_permissions_size() const;

  public:
  void clear_track_permissions() ;
  ::livekit::TrackPermission* PROTOBUF_NONNULL mutable_track_permissions(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::TrackPermission>* PROTOBUF_NONNULL mutable_track_permissions();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::TrackPermission>& _internal_track_permissions() const;
  ::google::protobuf::RepeatedPtrField<::livekit::TrackPermission>* PROTOBUF_NONNULL _internal_mutable_track_permissions();
  public:
  const ::livekit::TrackPermission& track_permissions(int index) const;
  ::livekit::TrackPermission* PROTOBUF_NONNULL add_track_permissions();
  const ::google::protobuf::RepeatedPtrField<::livekit::TrackPermission>& track_permissions() const;
  // bool all_participants = 1;
  void clear_all_participants() ;
  bool all_participants() const;
  void set_all_participants(bool value);

  private:
  bool _internal_all_participants() const;
  void _internal_set_all_participants(bool value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.SubscriptionPermission)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SubscriptionPermission& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::livekit::TrackPermission > track_permissions_;
    bool all_participants_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SubscriptionPermission_class_data_;
// -------------------------------------------------------------------

class SubscribedCodec final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.SubscribedCodec) */ {
 public:
  inline SubscribedCodec() : SubscribedCodec(nullptr) {}
  ~SubscribedCodec() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SubscribedCodec* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SubscribedCodec));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribedCodec(::google::protobuf::internal::ConstantInitialized);

  inline SubscribedCodec(const SubscribedCodec& from) : SubscribedCodec(nullptr, from) {}
  inline SubscribedCodec(SubscribedCodec&& from) noexcept
      : SubscribedCodec(nullptr, std::move(from)) {}
  inline SubscribedCodec& operator=(const SubscribedCodec& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribedCodec& operator=(SubscribedCodec&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribedCodec& default_instance() {
    return *reinterpret_cast<const SubscribedCodec*>(
        &_SubscribedCodec_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 28;
  friend void swap(SubscribedCodec& a, SubscribedCodec& b) { a.Swap(&b); }
  inline void Swap(SubscribedCodec* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribedCodec* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribedCodec* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SubscribedCodec>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SubscribedCodec& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SubscribedCodec& from) { SubscribedCodec::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SubscribedCodec* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.SubscribedCodec"; }

 protected:
  explicit SubscribedCodec(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SubscribedCodec(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SubscribedCodec& from);
  SubscribedCodec(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SubscribedCodec&& from) noexcept
      : SubscribedCodec(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kQualitiesFieldNumber = 2,
    kCodecFieldNumber = 1,
  };
  // repeated .livekit.SubscribedQuality qualities = 2;
  int qualities_size() const;
  private:
  int _internal_qualities_size() const;

  public:
  void clear_qualities() ;
  ::livekit::SubscribedQuality* PROTOBUF_NONNULL mutable_qualities(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::SubscribedQuality>* PROTOBUF_NONNULL mutable_qualities();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::SubscribedQuality>& _internal_qualities() const;
  ::google::protobuf::RepeatedPtrField<::livekit::SubscribedQuality>* PROTOBUF_NONNULL _internal_mutable_qualities();
  public:
  const ::livekit::SubscribedQuality& qualities(int index) const;
  ::livekit::SubscribedQuality* PROTOBUF_NONNULL add_qualities();
  const ::google::protobuf::RepeatedPtrField<::livekit::SubscribedQuality>& qualities() const;
  // string codec = 1;
  void clear_codec() ;
  const std::string& codec() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_codec(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_codec();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_codec();
  void set_allocated_codec(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_codec() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_codec(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_codec();

  public:
  // @@protoc_insertion_point(class_scope:livekit.SubscribedCodec)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 37,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SubscribedCodec& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::livekit::SubscribedQuality > qualities_;
    ::google::protobuf::internal::ArenaStringPtr codec_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SubscribedCodec_class_data_;
// -------------------------------------------------------------------

class StreamStateUpdate final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.StreamStateUpdate) */ {
 public:
  inline StreamStateUpdate() : StreamStateUpdate(nullptr) {}
  ~StreamStateUpdate() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(StreamStateUpdate* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(StreamStateUpdate));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StreamStateUpdate(::google::protobuf::internal::ConstantInitialized);

  inline StreamStateUpdate(const StreamStateUpdate& from) : StreamStateUpdate(nullptr, from) {}
  inline StreamStateUpdate(StreamStateUpdate&& from) noexcept
      : StreamStateUpdate(nullptr, std::move(from)) {}
  inline StreamStateUpdate& operator=(const StreamStateUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamStateUpdate& operator=(StreamStateUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamStateUpdate& default_instance() {
    return *reinterpret_cast<const StreamStateUpdate*>(
        &_StreamStateUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(StreamStateUpdate& a, StreamStateUpdate& b) { a.Swap(&b); }
  inline void Swap(StreamStateUpdate* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamStateUpdate* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamStateUpdate* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<StreamStateUpdate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StreamStateUpdate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StreamStateUpdate& from) { StreamStateUpdate::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(StreamStateUpdate* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.StreamStateUpdate"; }

 protected:
  explicit StreamStateUpdate(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  StreamStateUpdate(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const StreamStateUpdate& from);
  StreamStateUpdate(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, StreamStateUpdate&& from) noexcept
      : StreamStateUpdate(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStreamStatesFieldNumber = 1,
  };
  // repeated .livekit.StreamStateInfo stream_states = 1;
  int stream_states_size() const;
  private:
  int _internal_stream_states_size() const;

  public:
  void clear_stream_states() ;
  ::livekit::StreamStateInfo* PROTOBUF_NONNULL mutable_stream_states(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::StreamStateInfo>* PROTOBUF_NONNULL mutable_stream_states();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::StreamStateInfo>& _internal_stream_states() const;
  ::google::protobuf::RepeatedPtrField<::livekit::StreamStateInfo>* PROTOBUF_NONNULL _internal_mutable_stream_states();
  public:
  const ::livekit::StreamStateInfo& stream_states(int index) const;
  ::livekit::StreamStateInfo* PROTOBUF_NONNULL add_stream_states();
  const ::google::protobuf::RepeatedPtrField<::livekit::StreamStateInfo>& stream_states() const;
  // @@protoc_insertion_point(class_scope:livekit.StreamStateUpdate)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const StreamStateUpdate& from_msg);
    ::google::protobuf::RepeatedPtrField< ::livekit::StreamStateInfo > stream_states_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull StreamStateUpdate_class_data_;
// -------------------------------------------------------------------

class SpeakersChanged final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.SpeakersChanged) */ {
 public:
  inline SpeakersChanged() : SpeakersChanged(nullptr) {}
  ~SpeakersChanged() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SpeakersChanged* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SpeakersChanged));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SpeakersChanged(::google::protobuf::internal::ConstantInitialized);

  inline SpeakersChanged(const SpeakersChanged& from) : SpeakersChanged(nullptr, from) {}
  inline SpeakersChanged(SpeakersChanged&& from) noexcept
      : SpeakersChanged(nullptr, std::move(from)) {}
  inline SpeakersChanged& operator=(const SpeakersChanged& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpeakersChanged& operator=(SpeakersChanged&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpeakersChanged& default_instance() {
    return *reinterpret_cast<const SpeakersChanged*>(
        &_SpeakersChanged_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(SpeakersChanged& a, SpeakersChanged& b) { a.Swap(&b); }
  inline void Swap(SpeakersChanged* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpeakersChanged* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpeakersChanged* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SpeakersChanged>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SpeakersChanged& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SpeakersChanged& from) { SpeakersChanged::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SpeakersChanged* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.SpeakersChanged"; }

 protected:
  explicit SpeakersChanged(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SpeakersChanged(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SpeakersChanged& from);
  SpeakersChanged(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SpeakersChanged&& from) noexcept
      : SpeakersChanged(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSpeakersFieldNumber = 1,
  };
  // repeated .livekit.SpeakerInfo speakers = 1;
  int speakers_size() const;
  private:
  int _internal_speakers_size() const;

  public:
  void clear_speakers() ;
  ::livekit::SpeakerInfo* PROTOBUF_NONNULL mutable_speakers(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::SpeakerInfo>* PROTOBUF_NONNULL mutable_speakers();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::SpeakerInfo>& _internal_speakers() const;
  ::google::protobuf::RepeatedPtrField<::livekit::SpeakerInfo>* PROTOBUF_NONNULL _internal_mutable_speakers();
  public:
  const ::livekit::SpeakerInfo& speakers(int index) const;
  ::livekit::SpeakerInfo* PROTOBUF_NONNULL add_speakers();
  const ::google::protobuf::RepeatedPtrField<::livekit::SpeakerInfo>& speakers() const;
  // @@protoc_insertion_point(class_scope:livekit.SpeakersChanged)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SpeakersChanged& from_msg);
    ::google::protobuf::RepeatedPtrField< ::livekit::SpeakerInfo > speakers_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SpeakersChanged_class_data_;
// -------------------------------------------------------------------

class RegionSettings final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.RegionSettings) */ {
 public:
  inline RegionSettings() : RegionSettings(nullptr) {}
  ~RegionSettings() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RegionSettings* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RegionSettings));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegionSettings(::google::protobuf::internal::ConstantInitialized);

  inline RegionSettings(const RegionSettings& from) : RegionSettings(nullptr, from) {}
  inline RegionSettings(RegionSettings&& from) noexcept
      : RegionSettings(nullptr, std::move(from)) {}
  inline RegionSettings& operator=(const RegionSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionSettings& operator=(RegionSettings&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegionSettings& default_instance() {
    return *reinterpret_cast<const RegionSettings*>(
        &_RegionSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 38;
  friend void swap(RegionSettings& a, RegionSettings& b) { a.Swap(&b); }
  inline void Swap(RegionSettings* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegionSettings* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegionSettings* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RegionSettings>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegionSettings& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegionSettings& from) { RegionSettings::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RegionSettings* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.RegionSettings"; }

 protected:
  explicit RegionSettings(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RegionSettings(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RegionSettings& from);
  RegionSettings(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RegionSettings&& from) noexcept
      : RegionSettings(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRegionsFieldNumber = 1,
  };
  // repeated .livekit.RegionInfo regions = 1;
  int regions_size() const;
  private:
  int _internal_regions_size() const;

  public:
  void clear_regions() ;
  ::livekit::RegionInfo* PROTOBUF_NONNULL mutable_regions(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::RegionInfo>* PROTOBUF_NONNULL mutable_regions();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::RegionInfo>& _internal_regions() const;
  ::google::protobuf::RepeatedPtrField<::livekit::RegionInfo>* PROTOBUF_NONNULL _internal_mutable_regions();
  public:
  const ::livekit::RegionInfo& regions(int index) const;
  ::livekit::RegionInfo* PROTOBUF_NONNULL add_regions();
  const ::google::protobuf::RepeatedPtrField<::livekit::RegionInfo>& regions() const;
  // @@protoc_insertion_point(class_scope:livekit.RegionSettings)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RegionSettings& from_msg);
    ::google::protobuf::RepeatedPtrField< ::livekit::RegionInfo > regions_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RegionSettings_class_data_;
// -------------------------------------------------------------------

class ConnectionQualityUpdate final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.ConnectionQualityUpdate) */ {
 public:
  inline ConnectionQualityUpdate() : ConnectionQualityUpdate(nullptr) {}
  ~ConnectionQualityUpdate() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ConnectionQualityUpdate* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ConnectionQualityUpdate));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ConnectionQualityUpdate(::google::protobuf::internal::ConstantInitialized);

  inline ConnectionQualityUpdate(const ConnectionQualityUpdate& from) : ConnectionQualityUpdate(nullptr, from) {}
  inline ConnectionQualityUpdate(ConnectionQualityUpdate&& from) noexcept
      : ConnectionQualityUpdate(nullptr, std::move(from)) {}
  inline ConnectionQualityUpdate& operator=(const ConnectionQualityUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectionQualityUpdate& operator=(ConnectionQualityUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectionQualityUpdate& default_instance() {
    return *reinterpret_cast<const ConnectionQualityUpdate*>(
        &_ConnectionQualityUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(ConnectionQualityUpdate& a, ConnectionQualityUpdate& b) { a.Swap(&b); }
  inline void Swap(ConnectionQualityUpdate* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectionQualityUpdate* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectionQualityUpdate* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ConnectionQualityUpdate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ConnectionQualityUpdate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ConnectionQualityUpdate& from) { ConnectionQualityUpdate::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ConnectionQualityUpdate* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.ConnectionQualityUpdate"; }

 protected:
  explicit ConnectionQualityUpdate(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ConnectionQualityUpdate(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ConnectionQualityUpdate& from);
  ConnectionQualityUpdate(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ConnectionQualityUpdate&& from) noexcept
      : ConnectionQualityUpdate(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUpdatesFieldNumber = 1,
  };
  // repeated .livekit.ConnectionQualityInfo updates = 1;
  int updates_size() const;
  private:
  int _internal_updates_size() const;

  public:
  void clear_updates() ;
  ::livekit::ConnectionQualityInfo* PROTOBUF_NONNULL mutable_updates(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::ConnectionQualityInfo>* PROTOBUF_NONNULL mutable_updates();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::ConnectionQualityInfo>& _internal_updates() const;
  ::google::protobuf::RepeatedPtrField<::livekit::ConnectionQualityInfo>* PROTOBUF_NONNULL _internal_mutable_updates();
  public:
  const ::livekit::ConnectionQualityInfo& updates(int index) const;
  ::livekit::ConnectionQualityInfo* PROTOBUF_NONNULL add_updates();
  const ::google::protobuf::RepeatedPtrField<::livekit::ConnectionQualityInfo>& updates() const;
  // @@protoc_insertion_point(class_scope:livekit.ConnectionQualityUpdate)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ConnectionQualityUpdate& from_msg);
    ::google::protobuf::RepeatedPtrField< ::livekit::ConnectionQualityInfo > updates_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ConnectionQualityUpdate_class_data_;
// -------------------------------------------------------------------

class AddTrackRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.AddTrackRequest) */ {
 public:
  inline AddTrackRequest() : AddTrackRequest(nullptr) {}
  ~AddTrackRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AddTrackRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AddTrackRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AddTrackRequest(::google::protobuf::internal::ConstantInitialized);

  inline AddTrackRequest(const AddTrackRequest& from) : AddTrackRequest(nullptr, from) {}
  inline AddTrackRequest(AddTrackRequest&& from) noexcept
      : AddTrackRequest(nullptr, std::move(from)) {}
  inline AddTrackRequest& operator=(const AddTrackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddTrackRequest& operator=(AddTrackRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddTrackRequest& default_instance() {
    return *reinterpret_cast<const AddTrackRequest*>(
        &_AddTrackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(AddTrackRequest& a, AddTrackRequest& b) { a.Swap(&b); }
  inline void Swap(AddTrackRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddTrackRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddTrackRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AddTrackRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AddTrackRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AddTrackRequest& from) { AddTrackRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AddTrackRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.AddTrackRequest"; }

 protected:
  explicit AddTrackRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  AddTrackRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const AddTrackRequest& from);
  AddTrackRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, AddTrackRequest&& from) noexcept
      : AddTrackRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLayersFieldNumber = 9,
    kSimulcastCodecsFieldNumber = 10,
    kCidFieldNumber = 1,
    kNameFieldNumber = 2,
    kSidFieldNumber = 11,
    kStreamFieldNumber = 15,
    kTypeFieldNumber = 3,
    kWidthFieldNumber = 4,
    kHeightFieldNumber = 5,
    kSourceFieldNumber = 8,
    kMutedFieldNumber = 6,
    kDisableDtxFieldNumber = 7,
    kStereoFieldNumber = 12,
    kDisableRedFieldNumber = 13,
    kEncryptionFieldNumber = 14,
    kBackupCodecPolicyFieldNumber = 16,
  };
  // repeated .livekit.VideoLayer layers = 9;
  int layers_size() const;
  private:
  int _internal_layers_size() const;

  public:
  void clear_layers() ;
  ::livekit::VideoLayer* PROTOBUF_NONNULL mutable_layers(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::VideoLayer>* PROTOBUF_NONNULL mutable_layers();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::VideoLayer>& _internal_layers() const;
  ::google::protobuf::RepeatedPtrField<::livekit::VideoLayer>* PROTOBUF_NONNULL _internal_mutable_layers();
  public:
  const ::livekit::VideoLayer& layers(int index) const;
  ::livekit::VideoLayer* PROTOBUF_NONNULL add_layers();
  const ::google::protobuf::RepeatedPtrField<::livekit::VideoLayer>& layers() const;
  // repeated .livekit.SimulcastCodec simulcast_codecs = 10;
  int simulcast_codecs_size() const;
  private:
  int _internal_simulcast_codecs_size() const;

  public:
  void clear_simulcast_codecs() ;
  ::livekit::SimulcastCodec* PROTOBUF_NONNULL mutable_simulcast_codecs(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::SimulcastCodec>* PROTOBUF_NONNULL mutable_simulcast_codecs();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::SimulcastCodec>& _internal_simulcast_codecs() const;
  ::google::protobuf::RepeatedPtrField<::livekit::SimulcastCodec>* PROTOBUF_NONNULL _internal_mutable_simulcast_codecs();
  public:
  const ::livekit::SimulcastCodec& simulcast_codecs(int index) const;
  ::livekit::SimulcastCodec* PROTOBUF_NONNULL add_simulcast_codecs();
  const ::google::protobuf::RepeatedPtrField<::livekit::SimulcastCodec>& simulcast_codecs() const;
  // string cid = 1;
  void clear_cid() ;
  const std::string& cid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cid(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_cid();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_cid();
  void set_allocated_cid(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_cid() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_cid();

  public:
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // string sid = 11;
  void clear_sid() ;
  const std::string& sid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sid(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_sid();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_sid();
  void set_allocated_sid(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_sid() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_sid(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_sid();

  public:
  // string stream = 15;
  void clear_stream() ;
  const std::string& stream() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_stream(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_stream();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_stream();
  void set_allocated_stream(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_stream() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_stream(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_stream();

  public:
  // .livekit.TrackType type = 3;
  void clear_type() ;
  ::livekit::TrackType type() const;
  void set_type(::livekit::TrackType value);

  private:
  ::livekit::TrackType _internal_type() const;
  void _internal_set_type(::livekit::TrackType value);

  public:
  // uint32 width = 4;
  void clear_width() ;
  ::uint32_t width() const;
  void set_width(::uint32_t value);

  private:
  ::uint32_t _internal_width() const;
  void _internal_set_width(::uint32_t value);

  public:
  // uint32 height = 5;
  void clear_height() ;
  ::uint32_t height() const;
  void set_height(::uint32_t value);

  private:
  ::uint32_t _internal_height() const;
  void _internal_set_height(::uint32_t value);

  public:
  // .livekit.TrackSource source = 8;
  void clear_source() ;
  ::livekit::TrackSource source() const;
  void set_source(::livekit::TrackSource value);

  private:
  ::livekit::TrackSource _internal_source() const;
  void _internal_set_source(::livekit::TrackSource value);

  public:
  // bool muted = 6;
  void clear_muted() ;
  bool muted() const;
  void set_muted(bool value);

  private:
  bool _internal_muted() const;
  void _internal_set_muted(bool value);

  public:
  // bool disable_dtx = 7;
  void clear_disable_dtx() ;
  bool disable_dtx() const;
  void set_disable_dtx(bool value);

  private:
  bool _internal_disable_dtx() const;
  void _internal_set_disable_dtx(bool value);

  public:
  // bool stereo = 12;
  void clear_stereo() ;
  bool stereo() const;
  void set_stereo(bool value);

  private:
  bool _internal_stereo() const;
  void _internal_set_stereo(bool value);

  public:
  // bool disable_red = 13;
  void clear_disable_red() ;
  bool disable_red() const;
  void set_disable_red(bool value);

  private:
  bool _internal_disable_red() const;
  void _internal_set_disable_red(bool value);

  public:
  // .livekit.Encryption.Type encryption = 14;
  void clear_encryption() ;
  ::livekit::Encryption_Type encryption() const;
  void set_encryption(::livekit::Encryption_Type value);

  private:
  ::livekit::Encryption_Type _internal_encryption() const;
  void _internal_set_encryption(::livekit::Encryption_Type value);

  public:
  // .livekit.BackupCodecPolicy backup_codec_policy = 16;
  void clear_backup_codec_policy() ;
  ::livekit::BackupCodecPolicy backup_codec_policy() const;
  void set_backup_codec_policy(::livekit::BackupCodecPolicy value);

  private:
  ::livekit::BackupCodecPolicy _internal_backup_codec_policy() const;
  void _internal_set_backup_codec_policy(::livekit::BackupCodecPolicy value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.AddTrackRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 16,
                                   2, 64,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const AddTrackRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::livekit::VideoLayer > layers_;
    ::google::protobuf::RepeatedPtrField< ::livekit::SimulcastCodec > simulcast_codecs_;
    ::google::protobuf::internal::ArenaStringPtr cid_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr sid_;
    ::google::protobuf::internal::ArenaStringPtr stream_;
    int type_;
    ::uint32_t width_;
    ::uint32_t height_;
    int source_;
    bool muted_;
    bool disable_dtx_;
    bool stereo_;
    bool disable_red_;
    int encryption_;
    int backup_codec_policy_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull AddTrackRequest_class_data_;
// -------------------------------------------------------------------

class SubscribedQualityUpdate final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.SubscribedQualityUpdate) */ {
 public:
  inline SubscribedQualityUpdate() : SubscribedQualityUpdate(nullptr) {}
  ~SubscribedQualityUpdate() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SubscribedQualityUpdate* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SubscribedQualityUpdate));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribedQualityUpdate(::google::protobuf::internal::ConstantInitialized);

  inline SubscribedQualityUpdate(const SubscribedQualityUpdate& from) : SubscribedQualityUpdate(nullptr, from) {}
  inline SubscribedQualityUpdate(SubscribedQualityUpdate&& from) noexcept
      : SubscribedQualityUpdate(nullptr, std::move(from)) {}
  inline SubscribedQualityUpdate& operator=(const SubscribedQualityUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribedQualityUpdate& operator=(SubscribedQualityUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribedQualityUpdate& default_instance() {
    return *reinterpret_cast<const SubscribedQualityUpdate*>(
        &_SubscribedQualityUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 29;
  friend void swap(SubscribedQualityUpdate& a, SubscribedQualityUpdate& b) { a.Swap(&b); }
  inline void Swap(SubscribedQualityUpdate* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribedQualityUpdate* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribedQualityUpdate* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SubscribedQualityUpdate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SubscribedQualityUpdate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SubscribedQualityUpdate& from) { SubscribedQualityUpdate::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SubscribedQualityUpdate* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.SubscribedQualityUpdate"; }

 protected:
  explicit SubscribedQualityUpdate(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SubscribedQualityUpdate(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SubscribedQualityUpdate& from);
  SubscribedQualityUpdate(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SubscribedQualityUpdate&& from) noexcept
      : SubscribedQualityUpdate(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSubscribedQualitiesFieldNumber = 2,
    kSubscribedCodecsFieldNumber = 3,
    kTrackSidFieldNumber = 1,
  };
  // repeated .livekit.SubscribedQuality subscribed_qualities = 2;
  int subscribed_qualities_size() const;
  private:
  int _internal_subscribed_qualities_size() const;

  public:
  void clear_subscribed_qualities() ;
  ::livekit::SubscribedQuality* PROTOBUF_NONNULL mutable_subscribed_qualities(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::SubscribedQuality>* PROTOBUF_NONNULL mutable_subscribed_qualities();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::SubscribedQuality>& _internal_subscribed_qualities() const;
  ::google::protobuf::RepeatedPtrField<::livekit::SubscribedQuality>* PROTOBUF_NONNULL _internal_mutable_subscribed_qualities();
  public:
  const ::livekit::SubscribedQuality& subscribed_qualities(int index) const;
  ::livekit::SubscribedQuality* PROTOBUF_NONNULL add_subscribed_qualities();
  const ::google::protobuf::RepeatedPtrField<::livekit::SubscribedQuality>& subscribed_qualities() const;
  // repeated .livekit.SubscribedCodec subscribed_codecs = 3;
  int subscribed_codecs_size() const;
  private:
  int _internal_subscribed_codecs_size() const;

  public:
  void clear_subscribed_codecs() ;
  ::livekit::SubscribedCodec* PROTOBUF_NONNULL mutable_subscribed_codecs(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::SubscribedCodec>* PROTOBUF_NONNULL mutable_subscribed_codecs();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::SubscribedCodec>& _internal_subscribed_codecs() const;
  ::google::protobuf::RepeatedPtrField<::livekit::SubscribedCodec>* PROTOBUF_NONNULL _internal_mutable_subscribed_codecs();
  public:
  const ::livekit::SubscribedCodec& subscribed_codecs(int index) const;
  ::livekit::SubscribedCodec* PROTOBUF_NONNULL add_subscribed_codecs();
  const ::google::protobuf::RepeatedPtrField<::livekit::SubscribedCodec>& subscribed_codecs() const;
  // string track_sid = 1;
  void clear_track_sid() ;
  const std::string& track_sid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_track_sid(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_track_sid();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_track_sid();
  void set_allocated_track_sid(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_track_sid() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_track_sid(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_track_sid();

  public:
  // @@protoc_insertion_point(class_scope:livekit.SubscribedQualityUpdate)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 49,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SubscribedQualityUpdate& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::livekit::SubscribedQuality > subscribed_qualities_;
    ::google::protobuf::RepeatedPtrField< ::livekit::SubscribedCodec > subscribed_codecs_;
    ::google::protobuf::internal::ArenaStringPtr track_sid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SubscribedQualityUpdate_class_data_;
// -------------------------------------------------------------------

class RoomUpdate final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.RoomUpdate) */ {
 public:
  inline RoomUpdate() : RoomUpdate(nullptr) {}
  ~RoomUpdate() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RoomUpdate* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RoomUpdate));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RoomUpdate(::google::protobuf::internal::ConstantInitialized);

  inline RoomUpdate(const RoomUpdate& from) : RoomUpdate(nullptr, from) {}
  inline RoomUpdate(RoomUpdate&& from) noexcept
      : RoomUpdate(nullptr, std::move(from)) {}
  inline RoomUpdate& operator=(const RoomUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomUpdate& operator=(RoomUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomUpdate& default_instance() {
    return *reinterpret_cast<const RoomUpdate*>(
        &_RoomUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(RoomUpdate& a, RoomUpdate& b) { a.Swap(&b); }
  inline void Swap(RoomUpdate* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomUpdate* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomUpdate* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RoomUpdate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoomUpdate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RoomUpdate& from) { RoomUpdate::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RoomUpdate* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.RoomUpdate"; }

 protected:
  explicit RoomUpdate(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RoomUpdate(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RoomUpdate& from);
  RoomUpdate(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RoomUpdate&& from) noexcept
      : RoomUpdate(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRoomFieldNumber = 1,
  };
  // .livekit.Room room = 1;
  bool has_room() const;
  void clear_room() ;
  const ::livekit::Room& room() const;
  [[nodiscard]] ::livekit::Room* PROTOBUF_NULLABLE release_room();
  ::livekit::Room* PROTOBUF_NONNULL mutable_room();
  void set_allocated_room(::livekit::Room* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_room(::livekit::Room* PROTOBUF_NULLABLE value);
  ::livekit::Room* PROTOBUF_NULLABLE unsafe_arena_release_room();

  private:
  const ::livekit::Room& _internal_room() const;
  ::livekit::Room* PROTOBUF_NONNULL _internal_mutable_room();

  public:
  // @@protoc_insertion_point(class_scope:livekit.RoomUpdate)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RoomUpdate& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::livekit::Room* PROTOBUF_NULLABLE room_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RoomUpdate_class_data_;
// -------------------------------------------------------------------

class LeaveRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.LeaveRequest) */ {
 public:
  inline LeaveRequest() : LeaveRequest(nullptr) {}
  ~LeaveRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LeaveRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LeaveRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LeaveRequest(::google::protobuf::internal::ConstantInitialized);

  inline LeaveRequest(const LeaveRequest& from) : LeaveRequest(nullptr, from) {}
  inline LeaveRequest(LeaveRequest&& from) noexcept
      : LeaveRequest(nullptr, std::move(from)) {}
  inline LeaveRequest& operator=(const LeaveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaveRequest& operator=(LeaveRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeaveRequest& default_instance() {
    return *reinterpret_cast<const LeaveRequest*>(
        &_LeaveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(LeaveRequest& a, LeaveRequest& b) { a.Swap(&b); }
  inline void Swap(LeaveRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaveRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeaveRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<LeaveRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LeaveRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LeaveRequest& from) { LeaveRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LeaveRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.LeaveRequest"; }

 protected:
  explicit LeaveRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  LeaveRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const LeaveRequest& from);
  LeaveRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, LeaveRequest&& from) noexcept
      : LeaveRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Action = LeaveRequest_Action;
  static constexpr Action DISCONNECT = LeaveRequest_Action_DISCONNECT;
  static constexpr Action RESUME = LeaveRequest_Action_RESUME;
  static constexpr Action RECONNECT = LeaveRequest_Action_RECONNECT;
  static inline bool Action_IsValid(int value) {
    return LeaveRequest_Action_IsValid(value);
  }
  static constexpr Action Action_MIN = LeaveRequest_Action_Action_MIN;
  static constexpr Action Action_MAX = LeaveRequest_Action_Action_MAX;
  static constexpr int Action_ARRAYSIZE = LeaveRequest_Action_Action_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Action_descriptor() {
    return LeaveRequest_Action_descriptor();
  }
  template <typename T>
  static inline const std::string& Action_Name(T value) {
    return LeaveRequest_Action_Name(value);
  }
  static inline bool Action_Parse(
      absl::string_view name, Action* PROTOBUF_NONNULL value) {
    return LeaveRequest_Action_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kRegionsFieldNumber = 4,
    kCanReconnectFieldNumber = 1,
    kReasonFieldNumber = 2,
    kActionFieldNumber = 3,
  };
  // .livekit.RegionSettings regions = 4;
  bool has_regions() const;
  void clear_regions() ;
  const ::livekit::RegionSettings& regions() const;
  [[nodiscard]] ::livekit::RegionSettings* PROTOBUF_NULLABLE release_regions();
  ::livekit::RegionSettings* PROTOBUF_NONNULL mutable_regions();
  void set_allocated_regions(::livekit::RegionSettings* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_regions(::livekit::RegionSettings* PROTOBUF_NULLABLE value);
  ::livekit::RegionSettings* PROTOBUF_NULLABLE unsafe_arena_release_regions();

  private:
  const ::livekit::RegionSettings& _internal_regions() const;
  ::livekit::RegionSettings* PROTOBUF_NONNULL _internal_mutable_regions();

  public:
  // bool can_reconnect = 1;
  void clear_can_reconnect() ;
  bool can_reconnect() const;
  void set_can_reconnect(bool value);

  private:
  bool _internal_can_reconnect() const;
  void _internal_set_can_reconnect(bool value);

  public:
  // .livekit.DisconnectReason reason = 2;
  void clear_reason() ;
  ::livekit::DisconnectReason reason() const;
  void set_reason(::livekit::DisconnectReason value);

  private:
  ::livekit::DisconnectReason _internal_reason() const;
  void _internal_set_reason(::livekit::DisconnectReason value);

  public:
  // .livekit.LeaveRequest.Action action = 3;
  void clear_action() ;
  ::livekit::LeaveRequest_Action action() const;
  void set_action(::livekit::LeaveRequest_Action value);

  private:
  ::livekit::LeaveRequest_Action _internal_action() const;
  void _internal_set_action(::livekit::LeaveRequest_Action value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.LeaveRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const LeaveRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::livekit::RegionSettings* PROTOBUF_NULLABLE regions_;
    bool can_reconnect_;
    int reason_;
    int action_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull LeaveRequest_class_data_;
// -------------------------------------------------------------------

class TrackPublishedResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.TrackPublishedResponse) */ {
 public:
  inline TrackPublishedResponse() : TrackPublishedResponse(nullptr) {}
  ~TrackPublishedResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TrackPublishedResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TrackPublishedResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TrackPublishedResponse(::google::protobuf::internal::ConstantInitialized);

  inline TrackPublishedResponse(const TrackPublishedResponse& from) : TrackPublishedResponse(nullptr, from) {}
  inline TrackPublishedResponse(TrackPublishedResponse&& from) noexcept
      : TrackPublishedResponse(nullptr, std::move(from)) {}
  inline TrackPublishedResponse& operator=(const TrackPublishedResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackPublishedResponse& operator=(TrackPublishedResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackPublishedResponse& default_instance() {
    return *reinterpret_cast<const TrackPublishedResponse*>(
        &_TrackPublishedResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(TrackPublishedResponse& a, TrackPublishedResponse& b) { a.Swap(&b); }
  inline void Swap(TrackPublishedResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackPublishedResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackPublishedResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TrackPublishedResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrackPublishedResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TrackPublishedResponse& from) { TrackPublishedResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TrackPublishedResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.TrackPublishedResponse"; }

 protected:
  explicit TrackPublishedResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TrackPublishedResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TrackPublishedResponse& from);
  TrackPublishedResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TrackPublishedResponse&& from) noexcept
      : TrackPublishedResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCidFieldNumber = 1,
    kTrackFieldNumber = 2,
  };
  // string cid = 1;
  void clear_cid() ;
  const std::string& cid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cid(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_cid();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_cid();
  void set_allocated_cid(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_cid() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_cid();

  public:
  // .livekit.TrackInfo track = 2;
  bool has_track() const;
  void clear_track() ;
  const ::livekit::TrackInfo& track() const;
  [[nodiscard]] ::livekit::TrackInfo* PROTOBUF_NULLABLE release_track();
  ::livekit::TrackInfo* PROTOBUF_NONNULL mutable_track();
  void set_allocated_track(::livekit::TrackInfo* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_track(::livekit::TrackInfo* PROTOBUF_NULLABLE value);
  ::livekit::TrackInfo* PROTOBUF_NULLABLE unsafe_arena_release_track();

  private:
  const ::livekit::TrackInfo& _internal_track() const;
  ::livekit::TrackInfo* PROTOBUF_NONNULL _internal_mutable_track();

  public:
  // @@protoc_insertion_point(class_scope:livekit.TrackPublishedResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 42,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TrackPublishedResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr cid_;
    ::livekit::TrackInfo* PROTOBUF_NULLABLE track_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TrackPublishedResponse_class_data_;
// -------------------------------------------------------------------

class ReconnectResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.ReconnectResponse) */ {
 public:
  inline ReconnectResponse() : ReconnectResponse(nullptr) {}
  ~ReconnectResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReconnectResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReconnectResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReconnectResponse(::google::protobuf::internal::ConstantInitialized);

  inline ReconnectResponse(const ReconnectResponse& from) : ReconnectResponse(nullptr, from) {}
  inline ReconnectResponse(ReconnectResponse&& from) noexcept
      : ReconnectResponse(nullptr, std::move(from)) {}
  inline ReconnectResponse& operator=(const ReconnectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReconnectResponse& operator=(ReconnectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReconnectResponse& default_instance() {
    return *reinterpret_cast<const ReconnectResponse*>(
        &_ReconnectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(ReconnectResponse& a, ReconnectResponse& b) { a.Swap(&b); }
  inline void Swap(ReconnectResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReconnectResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReconnectResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReconnectResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReconnectResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReconnectResponse& from) { ReconnectResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReconnectResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.ReconnectResponse"; }

 protected:
  explicit ReconnectResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ReconnectResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ReconnectResponse& from);
  ReconnectResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ReconnectResponse&& from) noexcept
      : ReconnectResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIceServersFieldNumber = 1,
    kClientConfigurationFieldNumber = 2,
  };
  // repeated .livekit.ICEServer ice_servers = 1;
  int ice_servers_size() const;
  private:
  int _internal_ice_servers_size() const;

  public:
  void clear_ice_servers() ;
  ::livekit::ICEServer* PROTOBUF_NONNULL mutable_ice_servers(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::ICEServer>* PROTOBUF_NONNULL mutable_ice_servers();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::ICEServer>& _internal_ice_servers() const;
  ::google::protobuf::RepeatedPtrField<::livekit::ICEServer>* PROTOBUF_NONNULL _internal_mutable_ice_servers();
  public:
  const ::livekit::ICEServer& ice_servers(int index) const;
  ::livekit::ICEServer* PROTOBUF_NONNULL add_ice_servers();
  const ::google::protobuf::RepeatedPtrField<::livekit::ICEServer>& ice_servers() const;
  // .livekit.ClientConfiguration client_configuration = 2;
  bool has_client_configuration() const;
  void clear_client_configuration() ;
  const ::livekit::ClientConfiguration& client_configuration() const;
  [[nodiscard]] ::livekit::ClientConfiguration* PROTOBUF_NULLABLE release_client_configuration();
  ::livekit::ClientConfiguration* PROTOBUF_NONNULL mutable_client_configuration();
  void set_allocated_client_configuration(::livekit::ClientConfiguration* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_client_configuration(::livekit::ClientConfiguration* PROTOBUF_NULLABLE value);
  ::livekit::ClientConfiguration* PROTOBUF_NULLABLE unsafe_arena_release_client_configuration();

  private:
  const ::livekit::ClientConfiguration& _internal_client_configuration() const;
  ::livekit::ClientConfiguration* PROTOBUF_NONNULL _internal_mutable_client_configuration();

  public:
  // @@protoc_insertion_point(class_scope:livekit.ReconnectResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ReconnectResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::livekit::ICEServer > ice_servers_;
    ::livekit::ClientConfiguration* PROTOBUF_NULLABLE client_configuration_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ReconnectResponse_class_data_;
// -------------------------------------------------------------------

class SyncState final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.SyncState) */ {
 public:
  inline SyncState() : SyncState(nullptr) {}
  ~SyncState() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SyncState* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SyncState));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SyncState(::google::protobuf::internal::ConstantInitialized);

  inline SyncState(const SyncState& from) : SyncState(nullptr, from) {}
  inline SyncState(SyncState&& from) noexcept
      : SyncState(nullptr, std::move(from)) {}
  inline SyncState& operator=(const SyncState& from) {
    CopyFrom(from);
    return *this;
  }
  inline SyncState& operator=(SyncState&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SyncState& default_instance() {
    return *reinterpret_cast<const SyncState*>(
        &_SyncState_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 33;
  friend void swap(SyncState& a, SyncState& b) { a.Swap(&b); }
  inline void Swap(SyncState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SyncState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SyncState* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SyncState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SyncState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SyncState& from) { SyncState::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SyncState* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.SyncState"; }

 protected:
  explicit SyncState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SyncState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SyncState& from);
  SyncState(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SyncState&& from) noexcept
      : SyncState(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPublishTracksFieldNumber = 3,
    kDataChannelsFieldNumber = 4,
    kTrackSidsDisabledFieldNumber = 6,
    kAnswerFieldNumber = 1,
    kSubscriptionFieldNumber = 2,
    kOfferFieldNumber = 5,
  };
  // repeated .livekit.TrackPublishedResponse publish_tracks = 3;
  int publish_tracks_size() const;
  private:
  int _internal_publish_tracks_size() const;

  public:
  void clear_publish_tracks() ;
  ::livekit::TrackPublishedResponse* PROTOBUF_NONNULL mutable_publish_tracks(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::TrackPublishedResponse>* PROTOBUF_NONNULL mutable_publish_tracks();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::TrackPublishedResponse>& _internal_publish_tracks() const;
  ::google::protobuf::RepeatedPtrField<::livekit::TrackPublishedResponse>* PROTOBUF_NONNULL _internal_mutable_publish_tracks();
  public:
  const ::livekit::TrackPublishedResponse& publish_tracks(int index) const;
  ::livekit::TrackPublishedResponse* PROTOBUF_NONNULL add_publish_tracks();
  const ::google::protobuf::RepeatedPtrField<::livekit::TrackPublishedResponse>& publish_tracks() const;
  // repeated .livekit.DataChannelInfo data_channels = 4;
  int data_channels_size() const;
  private:
  int _internal_data_channels_size() const;

  public:
  void clear_data_channels() ;
  ::livekit::DataChannelInfo* PROTOBUF_NONNULL mutable_data_channels(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::DataChannelInfo>* PROTOBUF_NONNULL mutable_data_channels();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::DataChannelInfo>& _internal_data_channels() const;
  ::google::protobuf::RepeatedPtrField<::livekit::DataChannelInfo>* PROTOBUF_NONNULL _internal_mutable_data_channels();
  public:
  const ::livekit::DataChannelInfo& data_channels(int index) const;
  ::livekit::DataChannelInfo* PROTOBUF_NONNULL add_data_channels();
  const ::google::protobuf::RepeatedPtrField<::livekit::DataChannelInfo>& data_channels() const;
  // repeated string track_sids_disabled = 6;
  int track_sids_disabled_size() const;
  private:
  int _internal_track_sids_disabled_size() const;

  public:
  void clear_track_sids_disabled() ;
  const std::string& track_sids_disabled(int index) const;
  std::string* PROTOBUF_NONNULL mutable_track_sids_disabled(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_track_sids_disabled(int index, Arg_&& value, Args_... args);
  std::string* PROTOBUF_NONNULL add_track_sids_disabled();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_track_sids_disabled(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& track_sids_disabled() const;
  ::google::protobuf::RepeatedPtrField<std::string>* PROTOBUF_NONNULL mutable_track_sids_disabled();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_track_sids_disabled() const;
  ::google::protobuf::RepeatedPtrField<std::string>* PROTOBUF_NONNULL _internal_mutable_track_sids_disabled();

  public:
  // .livekit.SessionDescription answer = 1;
  bool has_answer() const;
  void clear_answer() ;
  const ::livekit::SessionDescription& answer() const;
  [[nodiscard]] ::livekit::SessionDescription* PROTOBUF_NULLABLE release_answer();
  ::livekit::SessionDescription* PROTOBUF_NONNULL mutable_answer();
  void set_allocated_answer(::livekit::SessionDescription* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_answer(::livekit::SessionDescription* PROTOBUF_NULLABLE value);
  ::livekit::SessionDescription* PROTOBUF_NULLABLE unsafe_arena_release_answer();

  private:
  const ::livekit::SessionDescription& _internal_answer() const;
  ::livekit::SessionDescription* PROTOBUF_NONNULL _internal_mutable_answer();

  public:
  // .livekit.UpdateSubscription subscription = 2;
  bool has_subscription() const;
  void clear_subscription() ;
  const ::livekit::UpdateSubscription& subscription() const;
  [[nodiscard]] ::livekit::UpdateSubscription* PROTOBUF_NULLABLE release_subscription();
  ::livekit::UpdateSubscription* PROTOBUF_NONNULL mutable_subscription();
  void set_allocated_subscription(::livekit::UpdateSubscription* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_subscription(::livekit::UpdateSubscription* PROTOBUF_NULLABLE value);
  ::livekit::UpdateSubscription* PROTOBUF_NULLABLE unsafe_arena_release_subscription();

  private:
  const ::livekit::UpdateSubscription& _internal_subscription() const;
  ::livekit::UpdateSubscription* PROTOBUF_NONNULL _internal_mutable_subscription();

  public:
  // .livekit.SessionDescription offer = 5;
  bool has_offer() const;
  void clear_offer() ;
  const ::livekit::SessionDescription& offer() const;
  [[nodiscard]] ::livekit::SessionDescription* PROTOBUF_NULLABLE release_offer();
  ::livekit::SessionDescription* PROTOBUF_NONNULL mutable_offer();
  void set_allocated_offer(::livekit::SessionDescription* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_offer(::livekit::SessionDescription* PROTOBUF_NULLABLE value);
  ::livekit::SessionDescription* PROTOBUF_NULLABLE unsafe_arena_release_offer();

  private:
  const ::livekit::SessionDescription& _internal_offer() const;
  ::livekit::SessionDescription* PROTOBUF_NONNULL _internal_mutable_offer();

  public:
  // @@protoc_insertion_point(class_scope:livekit.SyncState)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   5, 45,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SyncState& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::livekit::TrackPublishedResponse > publish_tracks_;
    ::google::protobuf::RepeatedPtrField< ::livekit::DataChannelInfo > data_channels_;
    ::google::protobuf::RepeatedPtrField<std::string> track_sids_disabled_;
    ::livekit::SessionDescription* PROTOBUF_NULLABLE answer_;
    ::livekit::UpdateSubscription* PROTOBUF_NULLABLE subscription_;
    ::livekit::SessionDescription* PROTOBUF_NULLABLE offer_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SyncState_class_data_;
// -------------------------------------------------------------------

class ParticipantUpdate final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.ParticipantUpdate) */ {
 public:
  inline ParticipantUpdate() : ParticipantUpdate(nullptr) {}
  ~ParticipantUpdate() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ParticipantUpdate* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ParticipantUpdate));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ParticipantUpdate(::google::protobuf::internal::ConstantInitialized);

  inline ParticipantUpdate(const ParticipantUpdate& from) : ParticipantUpdate(nullptr, from) {}
  inline ParticipantUpdate(ParticipantUpdate&& from) noexcept
      : ParticipantUpdate(nullptr, std::move(from)) {}
  inline ParticipantUpdate& operator=(const ParticipantUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParticipantUpdate& operator=(ParticipantUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ParticipantUpdate& default_instance() {
    return *reinterpret_cast<const ParticipantUpdate*>(
        &_ParticipantUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(ParticipantUpdate& a, ParticipantUpdate& b) { a.Swap(&b); }
  inline void Swap(ParticipantUpdate* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParticipantUpdate* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ParticipantUpdate* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ParticipantUpdate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ParticipantUpdate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ParticipantUpdate& from) { ParticipantUpdate::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ParticipantUpdate* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.ParticipantUpdate"; }

 protected:
  explicit ParticipantUpdate(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ParticipantUpdate(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ParticipantUpdate& from);
  ParticipantUpdate(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ParticipantUpdate&& from) noexcept
      : ParticipantUpdate(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kParticipantsFieldNumber = 1,
  };
  // repeated .livekit.ParticipantInfo participants = 1;
  int participants_size() const;
  private:
  int _internal_participants_size() const;

  public:
  void clear_participants() ;
  ::livekit::ParticipantInfo* PROTOBUF_NONNULL mutable_participants(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::ParticipantInfo>* PROTOBUF_NONNULL mutable_participants();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::ParticipantInfo>& _internal_participants() const;
  ::google::protobuf::RepeatedPtrField<::livekit::ParticipantInfo>* PROTOBUF_NONNULL _internal_mutable_participants();
  public:
  const ::livekit::ParticipantInfo& participants(int index) const;
  ::livekit::ParticipantInfo* PROTOBUF_NONNULL add_participants();
  const ::google::protobuf::RepeatedPtrField<::livekit::ParticipantInfo>& participants() const;
  // @@protoc_insertion_point(class_scope:livekit.ParticipantUpdate)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ParticipantUpdate& from_msg);
    ::google::protobuf::RepeatedPtrField< ::livekit::ParticipantInfo > participants_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ParticipantUpdate_class_data_;
// -------------------------------------------------------------------

class JoinResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.JoinResponse) */ {
 public:
  inline JoinResponse() : JoinResponse(nullptr) {}
  ~JoinResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(JoinResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(JoinResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR JoinResponse(::google::protobuf::internal::ConstantInitialized);

  inline JoinResponse(const JoinResponse& from) : JoinResponse(nullptr, from) {}
  inline JoinResponse(JoinResponse&& from) noexcept
      : JoinResponse(nullptr, std::move(from)) {}
  inline JoinResponse& operator=(const JoinResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinResponse& operator=(JoinResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoinResponse& default_instance() {
    return *reinterpret_cast<const JoinResponse*>(
        &_JoinResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(JoinResponse& a, JoinResponse& b) { a.Swap(&b); }
  inline void Swap(JoinResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JoinResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<JoinResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const JoinResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const JoinResponse& from) { JoinResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(JoinResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.JoinResponse"; }

 protected:
  explicit JoinResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  JoinResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const JoinResponse& from);
  JoinResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, JoinResponse&& from) noexcept
      : JoinResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOtherParticipantsFieldNumber = 3,
    kIceServersFieldNumber = 5,
    kEnabledPublishCodecsFieldNumber = 14,
    kServerVersionFieldNumber = 4,
    kAlternativeUrlFieldNumber = 7,
    kServerRegionFieldNumber = 9,
    kSifTrailerFieldNumber = 13,
    kRoomFieldNumber = 1,
    kParticipantFieldNumber = 2,
    kClientConfigurationFieldNumber = 8,
    kServerInfoFieldNumber = 12,
    kPingTimeoutFieldNumber = 10,
    kSubscriberPrimaryFieldNumber = 6,
    kFastPublishFieldNumber = 15,
    kPingIntervalFieldNumber = 11,
  };
  // repeated .livekit.ParticipantInfo other_participants = 3;
  int other_participants_size() const;
  private:
  int _internal_other_participants_size() const;

  public:
  void clear_other_participants() ;
  ::livekit::ParticipantInfo* PROTOBUF_NONNULL mutable_other_participants(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::ParticipantInfo>* PROTOBUF_NONNULL mutable_other_participants();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::ParticipantInfo>& _internal_other_participants() const;
  ::google::protobuf::RepeatedPtrField<::livekit::ParticipantInfo>* PROTOBUF_NONNULL _internal_mutable_other_participants();
  public:
  const ::livekit::ParticipantInfo& other_participants(int index) const;
  ::livekit::ParticipantInfo* PROTOBUF_NONNULL add_other_participants();
  const ::google::protobuf::RepeatedPtrField<::livekit::ParticipantInfo>& other_participants() const;
  // repeated .livekit.ICEServer ice_servers = 5;
  int ice_servers_size() const;
  private:
  int _internal_ice_servers_size() const;

  public:
  void clear_ice_servers() ;
  ::livekit::ICEServer* PROTOBUF_NONNULL mutable_ice_servers(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::ICEServer>* PROTOBUF_NONNULL mutable_ice_servers();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::ICEServer>& _internal_ice_servers() const;
  ::google::protobuf::RepeatedPtrField<::livekit::ICEServer>* PROTOBUF_NONNULL _internal_mutable_ice_servers();
  public:
  const ::livekit::ICEServer& ice_servers(int index) const;
  ::livekit::ICEServer* PROTOBUF_NONNULL add_ice_servers();
  const ::google::protobuf::RepeatedPtrField<::livekit::ICEServer>& ice_servers() const;
  // repeated .livekit.Codec enabled_publish_codecs = 14;
  int enabled_publish_codecs_size() const;
  private:
  int _internal_enabled_publish_codecs_size() const;

  public:
  void clear_enabled_publish_codecs() ;
  ::livekit::Codec* PROTOBUF_NONNULL mutable_enabled_publish_codecs(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::Codec>* PROTOBUF_NONNULL mutable_enabled_publish_codecs();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::Codec>& _internal_enabled_publish_codecs() const;
  ::google::protobuf::RepeatedPtrField<::livekit::Codec>* PROTOBUF_NONNULL _internal_mutable_enabled_publish_codecs();
  public:
  const ::livekit::Codec& enabled_publish_codecs(int index) const;
  ::livekit::Codec* PROTOBUF_NONNULL add_enabled_publish_codecs();
  const ::google::protobuf::RepeatedPtrField<::livekit::Codec>& enabled_publish_codecs() const;
  // string server_version = 4;
  void clear_server_version() ;
  const std::string& server_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_server_version(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_server_version();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_server_version();
  void set_allocated_server_version(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_server_version() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_server_version(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_server_version();

  public:
  // string alternative_url = 7;
  void clear_alternative_url() ;
  const std::string& alternative_url() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_alternative_url(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_alternative_url();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_alternative_url();
  void set_allocated_alternative_url(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_alternative_url() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_alternative_url(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_alternative_url();

  public:
  // string server_region = 9;
  void clear_server_region() ;
  const std::string& server_region() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_server_region(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_server_region();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_server_region();
  void set_allocated_server_region(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_server_region() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_server_region(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_server_region();

  public:
  // bytes sif_trailer = 13;
  void clear_sif_trailer() ;
  const std::string& sif_trailer() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sif_trailer(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_sif_trailer();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_sif_trailer();
  void set_allocated_sif_trailer(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_sif_trailer() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_sif_trailer(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_sif_trailer();

  public:
  // .livekit.Room room = 1;
  bool has_room() const;
  void clear_room() ;
  const ::livekit::Room& room() const;
  [[nodiscard]] ::livekit::Room* PROTOBUF_NULLABLE release_room();
  ::livekit::Room* PROTOBUF_NONNULL mutable_room();
  void set_allocated_room(::livekit::Room* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_room(::livekit::Room* PROTOBUF_NULLABLE value);
  ::livekit::Room* PROTOBUF_NULLABLE unsafe_arena_release_room();

  private:
  const ::livekit::Room& _internal_room() const;
  ::livekit::Room* PROTOBUF_NONNULL _internal_mutable_room();

  public:
  // .livekit.ParticipantInfo participant = 2;
  bool has_participant() const;
  void clear_participant() ;
  const ::livekit::ParticipantInfo& participant() const;
  [[nodiscard]] ::livekit::ParticipantInfo* PROTOBUF_NULLABLE release_participant();
  ::livekit::ParticipantInfo* PROTOBUF_NONNULL mutable_participant();
  void set_allocated_participant(::livekit::ParticipantInfo* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_participant(::livekit::ParticipantInfo* PROTOBUF_NULLABLE value);
  ::livekit::ParticipantInfo* PROTOBUF_NULLABLE unsafe_arena_release_participant();

  private:
  const ::livekit::ParticipantInfo& _internal_participant() const;
  ::livekit::ParticipantInfo* PROTOBUF_NONNULL _internal_mutable_participant();

  public:
  // .livekit.ClientConfiguration client_configuration = 8;
  bool has_client_configuration() const;
  void clear_client_configuration() ;
  const ::livekit::ClientConfiguration& client_configuration() const;
  [[nodiscard]] ::livekit::ClientConfiguration* PROTOBUF_NULLABLE release_client_configuration();
  ::livekit::ClientConfiguration* PROTOBUF_NONNULL mutable_client_configuration();
  void set_allocated_client_configuration(::livekit::ClientConfiguration* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_client_configuration(::livekit::ClientConfiguration* PROTOBUF_NULLABLE value);
  ::livekit::ClientConfiguration* PROTOBUF_NULLABLE unsafe_arena_release_client_configuration();

  private:
  const ::livekit::ClientConfiguration& _internal_client_configuration() const;
  ::livekit::ClientConfiguration* PROTOBUF_NONNULL _internal_mutable_client_configuration();

  public:
  // .livekit.ServerInfo server_info = 12;
  bool has_server_info() const;
  void clear_server_info() ;
  const ::livekit::ServerInfo& server_info() const;
  [[nodiscard]] ::livekit::ServerInfo* PROTOBUF_NULLABLE release_server_info();
  ::livekit::ServerInfo* PROTOBUF_NONNULL mutable_server_info();
  void set_allocated_server_info(::livekit::ServerInfo* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_server_info(::livekit::ServerInfo* PROTOBUF_NULLABLE value);
  ::livekit::ServerInfo* PROTOBUF_NULLABLE unsafe_arena_release_server_info();

  private:
  const ::livekit::ServerInfo& _internal_server_info() const;
  ::livekit::ServerInfo* PROTOBUF_NONNULL _internal_mutable_server_info();

  public:
  // int32 ping_timeout = 10;
  void clear_ping_timeout() ;
  ::int32_t ping_timeout() const;
  void set_ping_timeout(::int32_t value);

  private:
  ::int32_t _internal_ping_timeout() const;
  void _internal_set_ping_timeout(::int32_t value);

  public:
  // bool subscriber_primary = 6;
  void clear_subscriber_primary() ;
  bool subscriber_primary() const;
  void set_subscriber_primary(bool value);

  private:
  bool _internal_subscriber_primary() const;
  void _internal_set_subscriber_primary(bool value);

  public:
  // bool fast_publish = 15;
  void clear_fast_publish() ;
  bool fast_publish() const;
  void set_fast_publish(bool value);

  private:
  bool _internal_fast_publish() const;
  void _internal_set_fast_publish(bool value);

  public:
  // int32 ping_interval = 11;
  void clear_ping_interval() ;
  ::int32_t ping_interval() const;
  void set_ping_interval(::int32_t value);

  private:
  ::int32_t _internal_ping_interval() const;
  void _internal_set_ping_interval(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.JoinResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 15,
                                   7, 79,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const JoinResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::livekit::ParticipantInfo > other_participants_;
    ::google::protobuf::RepeatedPtrField< ::livekit::ICEServer > ice_servers_;
    ::google::protobuf::RepeatedPtrField< ::livekit::Codec > enabled_publish_codecs_;
    ::google::protobuf::internal::ArenaStringPtr server_version_;
    ::google::protobuf::internal::ArenaStringPtr alternative_url_;
    ::google::protobuf::internal::ArenaStringPtr server_region_;
    ::google::protobuf::internal::ArenaStringPtr sif_trailer_;
    ::livekit::Room* PROTOBUF_NULLABLE room_;
    ::livekit::ParticipantInfo* PROTOBUF_NULLABLE participant_;
    ::livekit::ClientConfiguration* PROTOBUF_NULLABLE client_configuration_;
    ::livekit::ServerInfo* PROTOBUF_NULLABLE server_info_;
    ::int32_t ping_timeout_;
    bool subscriber_primary_;
    bool fast_publish_;
    ::int32_t ping_interval_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull JoinResponse_class_data_;
// -------------------------------------------------------------------

class SignalResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.SignalResponse) */ {
 public:
  inline SignalResponse() : SignalResponse(nullptr) {}
  ~SignalResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SignalResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SignalResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SignalResponse(::google::protobuf::internal::ConstantInitialized);

  inline SignalResponse(const SignalResponse& from) : SignalResponse(nullptr, from) {}
  inline SignalResponse(SignalResponse&& from) noexcept
      : SignalResponse(nullptr, std::move(from)) {}
  inline SignalResponse& operator=(const SignalResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignalResponse& operator=(SignalResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignalResponse& default_instance() {
    return *reinterpret_cast<const SignalResponse*>(
        &_SignalResponse_default_instance_);
  }
  enum MessageCase {
    kJoin = 1,
    kAnswer = 2,
    kOffer = 3,
    kTrickle = 4,
    kUpdate = 5,
    kTrackPublished = 6,
    kLeave = 8,
    kMute = 9,
    kSpeakersChanged = 10,
    kRoomUpdate = 11,
    kConnectionQuality = 12,
    kStreamStateUpdate = 13,
    kSubscribedQualityUpdate = 14,
    kSubscriptionPermissionUpdate = 15,
    kRefreshToken = 16,
    kTrackUnpublished = 17,
    kPong = 18,
    kReconnect = 19,
    kPongResp = 20,
    kSubscriptionResponse = 21,
    kRequestResponse = 22,
    kTrackSubscribed = 23,
    MESSAGE_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(SignalResponse& a, SignalResponse& b) { a.Swap(&b); }
  inline void Swap(SignalResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignalResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignalResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SignalResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SignalResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SignalResponse& from) { SignalResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SignalResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.SignalResponse"; }

 protected:
  explicit SignalResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SignalResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SignalResponse& from);
  SignalResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SignalResponse&& from) noexcept
      : SignalResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kJoinFieldNumber = 1,
    kAnswerFieldNumber = 2,
    kOfferFieldNumber = 3,
    kTrickleFieldNumber = 4,
    kUpdateFieldNumber = 5,
    kTrackPublishedFieldNumber = 6,
    kLeaveFieldNumber = 8,
    kMuteFieldNumber = 9,
    kSpeakersChangedFieldNumber = 10,
    kRoomUpdateFieldNumber = 11,
    kConnectionQualityFieldNumber = 12,
    kStreamStateUpdateFieldNumber = 13,
    kSubscribedQualityUpdateFieldNumber = 14,
    kSubscriptionPermissionUpdateFieldNumber = 15,
    kRefreshTokenFieldNumber = 16,
    kTrackUnpublishedFieldNumber = 17,
    kPongFieldNumber = 18,
    kReconnectFieldNumber = 19,
    kPongRespFieldNumber = 20,
    kSubscriptionResponseFieldNumber = 21,
    kRequestResponseFieldNumber = 22,
    kTrackSubscribedFieldNumber = 23,
  };
  // .livekit.JoinResponse join = 1;
  bool has_join() const;
  private:
  bool _internal_has_join() const;

  public:
  void clear_join() ;
  const ::livekit::JoinResponse& join() const;
  [[nodiscard]] ::livekit::JoinResponse* PROTOBUF_NULLABLE release_join();
  ::livekit::JoinResponse* PROTOBUF_NONNULL mutable_join();
  void set_allocated_join(::livekit::JoinResponse* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_join(::livekit::JoinResponse* PROTOBUF_NULLABLE value);
  ::livekit::JoinResponse* PROTOBUF_NULLABLE unsafe_arena_release_join();

  private:
  const ::livekit::JoinResponse& _internal_join() const;
  ::livekit::JoinResponse* PROTOBUF_NONNULL _internal_mutable_join();

  public:
  // .livekit.SessionDescription answer = 2;
  bool has_answer() const;
  private:
  bool _internal_has_answer() const;

  public:
  void clear_answer() ;
  const ::livekit::SessionDescription& answer() const;
  [[nodiscard]] ::livekit::SessionDescription* PROTOBUF_NULLABLE release_answer();
  ::livekit::SessionDescription* PROTOBUF_NONNULL mutable_answer();
  void set_allocated_answer(::livekit::SessionDescription* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_answer(::livekit::SessionDescription* PROTOBUF_NULLABLE value);
  ::livekit::SessionDescription* PROTOBUF_NULLABLE unsafe_arena_release_answer();

  private:
  const ::livekit::SessionDescription& _internal_answer() const;
  ::livekit::SessionDescription* PROTOBUF_NONNULL _internal_mutable_answer();

  public:
  // .livekit.SessionDescription offer = 3;
  bool has_offer() const;
  private:
  bool _internal_has_offer() const;

  public:
  void clear_offer() ;
  const ::livekit::SessionDescription& offer() const;
  [[nodiscard]] ::livekit::SessionDescription* PROTOBUF_NULLABLE release_offer();
  ::livekit::SessionDescription* PROTOBUF_NONNULL mutable_offer();
  void set_allocated_offer(::livekit::SessionDescription* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_offer(::livekit::SessionDescription* PROTOBUF_NULLABLE value);
  ::livekit::SessionDescription* PROTOBUF_NULLABLE unsafe_arena_release_offer();

  private:
  const ::livekit::SessionDescription& _internal_offer() const;
  ::livekit::SessionDescription* PROTOBUF_NONNULL _internal_mutable_offer();

  public:
  // .livekit.TrickleRequest trickle = 4;
  bool has_trickle() const;
  private:
  bool _internal_has_trickle() const;

  public:
  void clear_trickle() ;
  const ::livekit::TrickleRequest& trickle() const;
  [[nodiscard]] ::livekit::TrickleRequest* PROTOBUF_NULLABLE release_trickle();
  ::livekit::TrickleRequest* PROTOBUF_NONNULL mutable_trickle();
  void set_allocated_trickle(::livekit::TrickleRequest* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_trickle(::livekit::TrickleRequest* PROTOBUF_NULLABLE value);
  ::livekit::TrickleRequest* PROTOBUF_NULLABLE unsafe_arena_release_trickle();

  private:
  const ::livekit::TrickleRequest& _internal_trickle() const;
  ::livekit::TrickleRequest* PROTOBUF_NONNULL _internal_mutable_trickle();

  public:
  // .livekit.ParticipantUpdate update = 5;
  bool has_update() const;
  private:
  bool _internal_has_update() const;

  public:
  void clear_update() ;
  const ::livekit::ParticipantUpdate& update() const;
  [[nodiscard]] ::livekit::ParticipantUpdate* PROTOBUF_NULLABLE release_update();
  ::livekit::ParticipantUpdate* PROTOBUF_NONNULL mutable_update();
  void set_allocated_update(::livekit::ParticipantUpdate* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_update(::livekit::ParticipantUpdate* PROTOBUF_NULLABLE value);
  ::livekit::ParticipantUpdate* PROTOBUF_NULLABLE unsafe_arena_release_update();

  private:
  const ::livekit::ParticipantUpdate& _internal_update() const;
  ::livekit::ParticipantUpdate* PROTOBUF_NONNULL _internal_mutable_update();

  public:
  // .livekit.TrackPublishedResponse track_published = 6;
  bool has_track_published() const;
  private:
  bool _internal_has_track_published() const;

  public:
  void clear_track_published() ;
  const ::livekit::TrackPublishedResponse& track_published() const;
  [[nodiscard]] ::livekit::TrackPublishedResponse* PROTOBUF_NULLABLE release_track_published();
  ::livekit::TrackPublishedResponse* PROTOBUF_NONNULL mutable_track_published();
  void set_allocated_track_published(::livekit::TrackPublishedResponse* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_track_published(::livekit::TrackPublishedResponse* PROTOBUF_NULLABLE value);
  ::livekit::TrackPublishedResponse* PROTOBUF_NULLABLE unsafe_arena_release_track_published();

  private:
  const ::livekit::TrackPublishedResponse& _internal_track_published() const;
  ::livekit::TrackPublishedResponse* PROTOBUF_NONNULL _internal_mutable_track_published();

  public:
  // .livekit.LeaveRequest leave = 8;
  bool has_leave() const;
  private:
  bool _internal_has_leave() const;

  public:
  void clear_leave() ;
  const ::livekit::LeaveRequest& leave() const;
  [[nodiscard]] ::livekit::LeaveRequest* PROTOBUF_NULLABLE release_leave();
  ::livekit::LeaveRequest* PROTOBUF_NONNULL mutable_leave();
  void set_allocated_leave(::livekit::LeaveRequest* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_leave(::livekit::LeaveRequest* PROTOBUF_NULLABLE value);
  ::livekit::LeaveRequest* PROTOBUF_NULLABLE unsafe_arena_release_leave();

  private:
  const ::livekit::LeaveRequest& _internal_leave() const;
  ::livekit::LeaveRequest* PROTOBUF_NONNULL _internal_mutable_leave();

  public:
  // .livekit.MuteTrackRequest mute = 9;
  bool has_mute() const;
  private:
  bool _internal_has_mute() const;

  public:
  void clear_mute() ;
  const ::livekit::MuteTrackRequest& mute() const;
  [[nodiscard]] ::livekit::MuteTrackRequest* PROTOBUF_NULLABLE release_mute();
  ::livekit::MuteTrackRequest* PROTOBUF_NONNULL mutable_mute();
  void set_allocated_mute(::livekit::MuteTrackRequest* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_mute(::livekit::MuteTrackRequest* PROTOBUF_NULLABLE value);
  ::livekit::MuteTrackRequest* PROTOBUF_NULLABLE unsafe_arena_release_mute();

  private:
  const ::livekit::MuteTrackRequest& _internal_mute() const;
  ::livekit::MuteTrackRequest* PROTOBUF_NONNULL _internal_mutable_mute();

  public:
  // .livekit.SpeakersChanged speakers_changed = 10;
  bool has_speakers_changed() const;
  private:
  bool _internal_has_speakers_changed() const;

  public:
  void clear_speakers_changed() ;
  const ::livekit::SpeakersChanged& speakers_changed() const;
  [[nodiscard]] ::livekit::SpeakersChanged* PROTOBUF_NULLABLE release_speakers_changed();
  ::livekit::SpeakersChanged* PROTOBUF_NONNULL mutable_speakers_changed();
  void set_allocated_speakers_changed(::livekit::SpeakersChanged* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_speakers_changed(::livekit::SpeakersChanged* PROTOBUF_NULLABLE value);
  ::livekit::SpeakersChanged* PROTOBUF_NULLABLE unsafe_arena_release_speakers_changed();

  private:
  const ::livekit::SpeakersChanged& _internal_speakers_changed() const;
  ::livekit::SpeakersChanged* PROTOBUF_NONNULL _internal_mutable_speakers_changed();

  public:
  // .livekit.RoomUpdate room_update = 11;
  bool has_room_update() const;
  private:
  bool _internal_has_room_update() const;

  public:
  void clear_room_update() ;
  const ::livekit::RoomUpdate& room_update() const;
  [[nodiscard]] ::livekit::RoomUpdate* PROTOBUF_NULLABLE release_room_update();
  ::livekit::RoomUpdate* PROTOBUF_NONNULL mutable_room_update();
  void set_allocated_room_update(::livekit::RoomUpdate* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_room_update(::livekit::RoomUpdate* PROTOBUF_NULLABLE value);
  ::livekit::RoomUpdate* PROTOBUF_NULLABLE unsafe_arena_release_room_update();

  private:
  const ::livekit::RoomUpdate& _internal_room_update() const;
  ::livekit::RoomUpdate* PROTOBUF_NONNULL _internal_mutable_room_update();

  public:
  // .livekit.ConnectionQualityUpdate connection_quality = 12;
  bool has_connection_quality() const;
  private:
  bool _internal_has_connection_quality() const;

  public:
  void clear_connection_quality() ;
  const ::livekit::ConnectionQualityUpdate& connection_quality() const;
  [[nodiscard]] ::livekit::ConnectionQualityUpdate* PROTOBUF_NULLABLE release_connection_quality();
  ::livekit::ConnectionQualityUpdate* PROTOBUF_NONNULL mutable_connection_quality();
  void set_allocated_connection_quality(::livekit::ConnectionQualityUpdate* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_connection_quality(::livekit::ConnectionQualityUpdate* PROTOBUF_NULLABLE value);
  ::livekit::ConnectionQualityUpdate* PROTOBUF_NULLABLE unsafe_arena_release_connection_quality();

  private:
  const ::livekit::ConnectionQualityUpdate& _internal_connection_quality() const;
  ::livekit::ConnectionQualityUpdate* PROTOBUF_NONNULL _internal_mutable_connection_quality();

  public:
  // .livekit.StreamStateUpdate stream_state_update = 13;
  bool has_stream_state_update() const;
  private:
  bool _internal_has_stream_state_update() const;

  public:
  void clear_stream_state_update() ;
  const ::livekit::StreamStateUpdate& stream_state_update() const;
  [[nodiscard]] ::livekit::StreamStateUpdate* PROTOBUF_NULLABLE release_stream_state_update();
  ::livekit::StreamStateUpdate* PROTOBUF_NONNULL mutable_stream_state_update();
  void set_allocated_stream_state_update(::livekit::StreamStateUpdate* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_stream_state_update(::livekit::StreamStateUpdate* PROTOBUF_NULLABLE value);
  ::livekit::StreamStateUpdate* PROTOBUF_NULLABLE unsafe_arena_release_stream_state_update();

  private:
  const ::livekit::StreamStateUpdate& _internal_stream_state_update() const;
  ::livekit::StreamStateUpdate* PROTOBUF_NONNULL _internal_mutable_stream_state_update();

  public:
  // .livekit.SubscribedQualityUpdate subscribed_quality_update = 14;
  bool has_subscribed_quality_update() const;
  private:
  bool _internal_has_subscribed_quality_update() const;

  public:
  void clear_subscribed_quality_update() ;
  const ::livekit::SubscribedQualityUpdate& subscribed_quality_update() const;
  [[nodiscard]] ::livekit::SubscribedQualityUpdate* PROTOBUF_NULLABLE release_subscribed_quality_update();
  ::livekit::SubscribedQualityUpdate* PROTOBUF_NONNULL mutable_subscribed_quality_update();
  void set_allocated_subscribed_quality_update(::livekit::SubscribedQualityUpdate* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_subscribed_quality_update(::livekit::SubscribedQualityUpdate* PROTOBUF_NULLABLE value);
  ::livekit::SubscribedQualityUpdate* PROTOBUF_NULLABLE unsafe_arena_release_subscribed_quality_update();

  private:
  const ::livekit::SubscribedQualityUpdate& _internal_subscribed_quality_update() const;
  ::livekit::SubscribedQualityUpdate* PROTOBUF_NONNULL _internal_mutable_subscribed_quality_update();

  public:
  // .livekit.SubscriptionPermissionUpdate subscription_permission_update = 15;
  bool has_subscription_permission_update() const;
  private:
  bool _internal_has_subscription_permission_update() const;

  public:
  void clear_subscription_permission_update() ;
  const ::livekit::SubscriptionPermissionUpdate& subscription_permission_update() const;
  [[nodiscard]] ::livekit::SubscriptionPermissionUpdate* PROTOBUF_NULLABLE release_subscription_permission_update();
  ::livekit::SubscriptionPermissionUpdate* PROTOBUF_NONNULL mutable_subscription_permission_update();
  void set_allocated_subscription_permission_update(::livekit::SubscriptionPermissionUpdate* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_subscription_permission_update(::livekit::SubscriptionPermissionUpdate* PROTOBUF_NULLABLE value);
  ::livekit::SubscriptionPermissionUpdate* PROTOBUF_NULLABLE unsafe_arena_release_subscription_permission_update();

  private:
  const ::livekit::SubscriptionPermissionUpdate& _internal_subscription_permission_update() const;
  ::livekit::SubscriptionPermissionUpdate* PROTOBUF_NONNULL _internal_mutable_subscription_permission_update();

  public:
  // string refresh_token = 16;
  bool has_refresh_token() const;
  void clear_refresh_token() ;
  const std::string& refresh_token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_refresh_token(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_refresh_token();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_refresh_token();
  void set_allocated_refresh_token(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_refresh_token() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_refresh_token(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_refresh_token();

  public:
  // .livekit.TrackUnpublishedResponse track_unpublished = 17;
  bool has_track_unpublished() const;
  private:
  bool _internal_has_track_unpublished() const;

  public:
  void clear_track_unpublished() ;
  const ::livekit::TrackUnpublishedResponse& track_unpublished() const;
  [[nodiscard]] ::livekit::TrackUnpublishedResponse* PROTOBUF_NULLABLE release_track_unpublished();
  ::livekit::TrackUnpublishedResponse* PROTOBUF_NONNULL mutable_track_unpublished();
  void set_allocated_track_unpublished(::livekit::TrackUnpublishedResponse* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_track_unpublished(::livekit::TrackUnpublishedResponse* PROTOBUF_NULLABLE value);
  ::livekit::TrackUnpublishedResponse* PROTOBUF_NULLABLE unsafe_arena_release_track_unpublished();

  private:
  const ::livekit::TrackUnpublishedResponse& _internal_track_unpublished() const;
  ::livekit::TrackUnpublishedResponse* PROTOBUF_NONNULL _internal_mutable_track_unpublished();

  public:
  // int64 pong = 18;
  bool has_pong() const;
  void clear_pong() ;
  ::int64_t pong() const;
  void set_pong(::int64_t value);

  private:
  ::int64_t _internal_pong() const;
  void _internal_set_pong(::int64_t value);

  public:
  // .livekit.ReconnectResponse reconnect = 19;
  bool has_reconnect() const;
  private:
  bool _internal_has_reconnect() const;

  public:
  void clear_reconnect() ;
  const ::livekit::ReconnectResponse& reconnect() const;
  [[nodiscard]] ::livekit::ReconnectResponse* PROTOBUF_NULLABLE release_reconnect();
  ::livekit::ReconnectResponse* PROTOBUF_NONNULL mutable_reconnect();
  void set_allocated_reconnect(::livekit::ReconnectResponse* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_reconnect(::livekit::ReconnectResponse* PROTOBUF_NULLABLE value);
  ::livekit::ReconnectResponse* PROTOBUF_NULLABLE unsafe_arena_release_reconnect();

  private:
  const ::livekit::ReconnectResponse& _internal_reconnect() const;
  ::livekit::ReconnectResponse* PROTOBUF_NONNULL _internal_mutable_reconnect();

  public:
  // .livekit.Pong pong_resp = 20;
  bool has_pong_resp() const;
  private:
  bool _internal_has_pong_resp() const;

  public:
  void clear_pong_resp() ;
  const ::livekit::Pong& pong_resp() const;
  [[nodiscard]] ::livekit::Pong* PROTOBUF_NULLABLE release_pong_resp();
  ::livekit::Pong* PROTOBUF_NONNULL mutable_pong_resp();
  void set_allocated_pong_resp(::livekit::Pong* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_pong_resp(::livekit::Pong* PROTOBUF_NULLABLE value);
  ::livekit::Pong* PROTOBUF_NULLABLE unsafe_arena_release_pong_resp();

  private:
  const ::livekit::Pong& _internal_pong_resp() const;
  ::livekit::Pong* PROTOBUF_NONNULL _internal_mutable_pong_resp();

  public:
  // .livekit.SubscriptionResponse subscription_response = 21;
  bool has_subscription_response() const;
  private:
  bool _internal_has_subscription_response() const;

  public:
  void clear_subscription_response() ;
  const ::livekit::SubscriptionResponse& subscription_response() const;
  [[nodiscard]] ::livekit::SubscriptionResponse* PROTOBUF_NULLABLE release_subscription_response();
  ::livekit::SubscriptionResponse* PROTOBUF_NONNULL mutable_subscription_response();
  void set_allocated_subscription_response(::livekit::SubscriptionResponse* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_subscription_response(::livekit::SubscriptionResponse* PROTOBUF_NULLABLE value);
  ::livekit::SubscriptionResponse* PROTOBUF_NULLABLE unsafe_arena_release_subscription_response();

  private:
  const ::livekit::SubscriptionResponse& _internal_subscription_response() const;
  ::livekit::SubscriptionResponse* PROTOBUF_NONNULL _internal_mutable_subscription_response();

  public:
  // .livekit.RequestResponse request_response = 22;
  bool has_request_response() const;
  private:
  bool _internal_has_request_response() const;

  public:
  void clear_request_response() ;
  const ::livekit::RequestResponse& request_response() const;
  [[nodiscard]] ::livekit::RequestResponse* PROTOBUF_NULLABLE release_request_response();
  ::livekit::RequestResponse* PROTOBUF_NONNULL mutable_request_response();
  void set_allocated_request_response(::livekit::RequestResponse* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_request_response(::livekit::RequestResponse* PROTOBUF_NULLABLE value);
  ::livekit::RequestResponse* PROTOBUF_NULLABLE unsafe_arena_release_request_response();

  private:
  const ::livekit::RequestResponse& _internal_request_response() const;
  ::livekit::RequestResponse* PROTOBUF_NONNULL _internal_mutable_request_response();

  public:
  // .livekit.TrackSubscribed track_subscribed = 23;
  bool has_track_subscribed() const;
  private:
  bool _internal_has_track_subscribed() const;

  public:
  void clear_track_subscribed() ;
  const ::livekit::TrackSubscribed& track_subscribed() const;
  [[nodiscard]] ::livekit::TrackSubscribed* PROTOBUF_NULLABLE release_track_subscribed();
  ::livekit::TrackSubscribed* PROTOBUF_NONNULL mutable_track_subscribed();
  void set_allocated_track_subscribed(::livekit::TrackSubscribed* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_track_subscribed(::livekit::TrackSubscribed* PROTOBUF_NULLABLE value);
  ::livekit::TrackSubscribed* PROTOBUF_NULLABLE unsafe_arena_release_track_subscribed();

  private:
  const ::livekit::TrackSubscribed& _internal_track_subscribed() const;
  ::livekit::TrackSubscribed* PROTOBUF_NONNULL _internal_mutable_track_subscribed();

  public:
  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:livekit.SignalResponse)
 private:
  class _Internal;
  void set_has_join();
  void set_has_answer();
  void set_has_offer();
  void set_has_trickle();
  void set_has_update();
  void set_has_track_published();
  void set_has_leave();
  void set_has_mute();
  void set_has_speakers_changed();
  void set_has_room_update();
  void set_has_connection_quality();
  void set_has_stream_state_update();
  void set_has_subscribed_quality_update();
  void set_has_subscription_permission_update();
  void set_has_refresh_token();
  void set_has_track_unpublished();
  void set_has_pong();
  void set_has_reconnect();
  void set_has_pong_resp();
  void set_has_subscription_response();
  void set_has_request_response();
  void set_has_track_subscribed();
  inline bool has_message() const;
  inline void clear_has_message();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 22,
                                   20, 60,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SignalResponse& from_msg);
    union MessageUnion {
      constexpr MessageUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE join_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE answer_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE offer_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE trickle_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE update_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE track_published_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE leave_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE mute_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE speakers_changed_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE room_update_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE connection_quality_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE stream_state_update_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE subscribed_quality_update_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE subscription_permission_update_;
      ::google::protobuf::internal::ArenaStringPtr refresh_token_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE track_unpublished_;
      ::int64_t pong_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE reconnect_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE pong_resp_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE subscription_response_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE request_response_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE track_subscribed_;
    } message_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SignalResponse_class_data_;
// -------------------------------------------------------------------

class SignalRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.SignalRequest) */ {
 public:
  inline SignalRequest() : SignalRequest(nullptr) {}
  ~SignalRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SignalRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SignalRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SignalRequest(::google::protobuf::internal::ConstantInitialized);

  inline SignalRequest(const SignalRequest& from) : SignalRequest(nullptr, from) {}
  inline SignalRequest(SignalRequest&& from) noexcept
      : SignalRequest(nullptr, std::move(from)) {}
  inline SignalRequest& operator=(const SignalRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignalRequest& operator=(SignalRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignalRequest& default_instance() {
    return *reinterpret_cast<const SignalRequest*>(
        &_SignalRequest_default_instance_);
  }
  enum MessageCase {
    kOffer = 1,
    kAnswer = 2,
    kTrickle = 3,
    kAddTrack = 4,
    kMute = 5,
    kSubscription = 6,
    kTrackSetting = 7,
    kLeave = 8,
    kUpdateLayers = 10,
    kSubscriptionPermission = 11,
    kSyncState = 12,
    kSimulate = 13,
    kPing = 14,
    kUpdateMetadata = 15,
    kPingReq = 16,
    kUpdateAudioTrack = 17,
    kUpdateVideoTrack = 18,
    MESSAGE_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(SignalRequest& a, SignalRequest& b) { a.Swap(&b); }
  inline void Swap(SignalRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignalRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignalRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SignalRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SignalRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SignalRequest& from) { SignalRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SignalRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.SignalRequest"; }

 protected:
  explicit SignalRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SignalRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SignalRequest& from);
  SignalRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SignalRequest&& from) noexcept
      : SignalRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOfferFieldNumber = 1,
    kAnswerFieldNumber = 2,
    kTrickleFieldNumber = 3,
    kAddTrackFieldNumber = 4,
    kMuteFieldNumber = 5,
    kSubscriptionFieldNumber = 6,
    kTrackSettingFieldNumber = 7,
    kLeaveFieldNumber = 8,
    kUpdateLayersFieldNumber = 10,
    kSubscriptionPermissionFieldNumber = 11,
    kSyncStateFieldNumber = 12,
    kSimulateFieldNumber = 13,
    kPingFieldNumber = 14,
    kUpdateMetadataFieldNumber = 15,
    kPingReqFieldNumber = 16,
    kUpdateAudioTrackFieldNumber = 17,
    kUpdateVideoTrackFieldNumber = 18,
  };
  // .livekit.SessionDescription offer = 1;
  bool has_offer() const;
  private:
  bool _internal_has_offer() const;

  public:
  void clear_offer() ;
  const ::livekit::SessionDescription& offer() const;
  [[nodiscard]] ::livekit::SessionDescription* PROTOBUF_NULLABLE release_offer();
  ::livekit::SessionDescription* PROTOBUF_NONNULL mutable_offer();
  void set_allocated_offer(::livekit::SessionDescription* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_offer(::livekit::SessionDescription* PROTOBUF_NULLABLE value);
  ::livekit::SessionDescription* PROTOBUF_NULLABLE unsafe_arena_release_offer();

  private:
  const ::livekit::SessionDescription& _internal_offer() const;
  ::livekit::SessionDescription* PROTOBUF_NONNULL _internal_mutable_offer();

  public:
  // .livekit.SessionDescription answer = 2;
  bool has_answer() const;
  private:
  bool _internal_has_answer() const;

  public:
  void clear_answer() ;
  const ::livekit::SessionDescription& answer() const;
  [[nodiscard]] ::livekit::SessionDescription* PROTOBUF_NULLABLE release_answer();
  ::livekit::SessionDescription* PROTOBUF_NONNULL mutable_answer();
  void set_allocated_answer(::livekit::SessionDescription* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_answer(::livekit::SessionDescription* PROTOBUF_NULLABLE value);
  ::livekit::SessionDescription* PROTOBUF_NULLABLE unsafe_arena_release_answer();

  private:
  const ::livekit::SessionDescription& _internal_answer() const;
  ::livekit::SessionDescription* PROTOBUF_NONNULL _internal_mutable_answer();

  public:
  // .livekit.TrickleRequest trickle = 3;
  bool has_trickle() const;
  private:
  bool _internal_has_trickle() const;

  public:
  void clear_trickle() ;
  const ::livekit::TrickleRequest& trickle() const;
  [[nodiscard]] ::livekit::TrickleRequest* PROTOBUF_NULLABLE release_trickle();
  ::livekit::TrickleRequest* PROTOBUF_NONNULL mutable_trickle();
  void set_allocated_trickle(::livekit::TrickleRequest* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_trickle(::livekit::TrickleRequest* PROTOBUF_NULLABLE value);
  ::livekit::TrickleRequest* PROTOBUF_NULLABLE unsafe_arena_release_trickle();

  private:
  const ::livekit::TrickleRequest& _internal_trickle() const;
  ::livekit::TrickleRequest* PROTOBUF_NONNULL _internal_mutable_trickle();

  public:
  // .livekit.AddTrackRequest add_track = 4;
  bool has_add_track() const;
  private:
  bool _internal_has_add_track() const;

  public:
  void clear_add_track() ;
  const ::livekit::AddTrackRequest& add_track() const;
  [[nodiscard]] ::livekit::AddTrackRequest* PROTOBUF_NULLABLE release_add_track();
  ::livekit::AddTrackRequest* PROTOBUF_NONNULL mutable_add_track();
  void set_allocated_add_track(::livekit::AddTrackRequest* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_add_track(::livekit::AddTrackRequest* PROTOBUF_NULLABLE value);
  ::livekit::AddTrackRequest* PROTOBUF_NULLABLE unsafe_arena_release_add_track();

  private:
  const ::livekit::AddTrackRequest& _internal_add_track() const;
  ::livekit::AddTrackRequest* PROTOBUF_NONNULL _internal_mutable_add_track();

  public:
  // .livekit.MuteTrackRequest mute = 5;
  bool has_mute() const;
  private:
  bool _internal_has_mute() const;

  public:
  void clear_mute() ;
  const ::livekit::MuteTrackRequest& mute() const;
  [[nodiscard]] ::livekit::MuteTrackRequest* PROTOBUF_NULLABLE release_mute();
  ::livekit::MuteTrackRequest* PROTOBUF_NONNULL mutable_mute();
  void set_allocated_mute(::livekit::MuteTrackRequest* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_mute(::livekit::MuteTrackRequest* PROTOBUF_NULLABLE value);
  ::livekit::MuteTrackRequest* PROTOBUF_NULLABLE unsafe_arena_release_mute();

  private:
  const ::livekit::MuteTrackRequest& _internal_mute() const;
  ::livekit::MuteTrackRequest* PROTOBUF_NONNULL _internal_mutable_mute();

  public:
  // .livekit.UpdateSubscription subscription = 6;
  bool has_subscription() const;
  private:
  bool _internal_has_subscription() const;

  public:
  void clear_subscription() ;
  const ::livekit::UpdateSubscription& subscription() const;
  [[nodiscard]] ::livekit::UpdateSubscription* PROTOBUF_NULLABLE release_subscription();
  ::livekit::UpdateSubscription* PROTOBUF_NONNULL mutable_subscription();
  void set_allocated_subscription(::livekit::UpdateSubscription* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_subscription(::livekit::UpdateSubscription* PROTOBUF_NULLABLE value);
  ::livekit::UpdateSubscription* PROTOBUF_NULLABLE unsafe_arena_release_subscription();

  private:
  const ::livekit::UpdateSubscription& _internal_subscription() const;
  ::livekit::UpdateSubscription* PROTOBUF_NONNULL _internal_mutable_subscription();

  public:
  // .livekit.UpdateTrackSettings track_setting = 7;
  bool has_track_setting() const;
  private:
  bool _internal_has_track_setting() const;

  public:
  void clear_track_setting() ;
  const ::livekit::UpdateTrackSettings& track_setting() const;
  [[nodiscard]] ::livekit::UpdateTrackSettings* PROTOBUF_NULLABLE release_track_setting();
  ::livekit::UpdateTrackSettings* PROTOBUF_NONNULL mutable_track_setting();
  void set_allocated_track_setting(::livekit::UpdateTrackSettings* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_track_setting(::livekit::UpdateTrackSettings* PROTOBUF_NULLABLE value);
  ::livekit::UpdateTrackSettings* PROTOBUF_NULLABLE unsafe_arena_release_track_setting();

  private:
  const ::livekit::UpdateTrackSettings& _internal_track_setting() const;
  ::livekit::UpdateTrackSettings* PROTOBUF_NONNULL _internal_mutable_track_setting();

  public:
  // .livekit.LeaveRequest leave = 8;
  bool has_leave() const;
  private:
  bool _internal_has_leave() const;

  public:
  void clear_leave() ;
  const ::livekit::LeaveRequest& leave() const;
  [[nodiscard]] ::livekit::LeaveRequest* PROTOBUF_NULLABLE release_leave();
  ::livekit::LeaveRequest* PROTOBUF_NONNULL mutable_leave();
  void set_allocated_leave(::livekit::LeaveRequest* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_leave(::livekit::LeaveRequest* PROTOBUF_NULLABLE value);
  ::livekit::LeaveRequest* PROTOBUF_NULLABLE unsafe_arena_release_leave();

  private:
  const ::livekit::LeaveRequest& _internal_leave() const;
  ::livekit::LeaveRequest* PROTOBUF_NONNULL _internal_mutable_leave();

  public:
  // .livekit.UpdateVideoLayers update_layers = 10 [deprecated = true];
  [[deprecated]]  bool has_update_layers() const;
  private:
  bool _internal_has_update_layers() const;

  public:
  [[deprecated]]  void clear_update_layers() ;
  [[deprecated]] const ::livekit::UpdateVideoLayers& update_layers() const;
  [[deprecated]] [[nodiscard]] ::livekit::UpdateVideoLayers* PROTOBUF_NULLABLE release_update_layers();
  [[deprecated]] ::livekit::UpdateVideoLayers* PROTOBUF_NONNULL mutable_update_layers();
  [[deprecated]] void set_allocated_update_layers(::livekit::UpdateVideoLayers* PROTOBUF_NULLABLE value);
  [[deprecated]] void unsafe_arena_set_allocated_update_layers(::livekit::UpdateVideoLayers* PROTOBUF_NULLABLE value);
  [[deprecated]] ::livekit::UpdateVideoLayers* PROTOBUF_NULLABLE unsafe_arena_release_update_layers();

  private:
  const ::livekit::UpdateVideoLayers& _internal_update_layers() const;
  ::livekit::UpdateVideoLayers* PROTOBUF_NONNULL _internal_mutable_update_layers();

  public:
  // .livekit.SubscriptionPermission subscription_permission = 11;
  bool has_subscription_permission() const;
  private:
  bool _internal_has_subscription_permission() const;

  public:
  void clear_subscription_permission() ;
  const ::livekit::SubscriptionPermission& subscription_permission() const;
  [[nodiscard]] ::livekit::SubscriptionPermission* PROTOBUF_NULLABLE release_subscription_permission();
  ::livekit::SubscriptionPermission* PROTOBUF_NONNULL mutable_subscription_permission();
  void set_allocated_subscription_permission(::livekit::SubscriptionPermission* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_subscription_permission(::livekit::SubscriptionPermission* PROTOBUF_NULLABLE value);
  ::livekit::SubscriptionPermission* PROTOBUF_NULLABLE unsafe_arena_release_subscription_permission();

  private:
  const ::livekit::SubscriptionPermission& _internal_subscription_permission() const;
  ::livekit::SubscriptionPermission* PROTOBUF_NONNULL _internal_mutable_subscription_permission();

  public:
  // .livekit.SyncState sync_state = 12;
  bool has_sync_state() const;
  private:
  bool _internal_has_sync_state() const;

  public:
  void clear_sync_state() ;
  const ::livekit::SyncState& sync_state() const;
  [[nodiscard]] ::livekit::SyncState* PROTOBUF_NULLABLE release_sync_state();
  ::livekit::SyncState* PROTOBUF_NONNULL mutable_sync_state();
  void set_allocated_sync_state(::livekit::SyncState* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_sync_state(::livekit::SyncState* PROTOBUF_NULLABLE value);
  ::livekit::SyncState* PROTOBUF_NULLABLE unsafe_arena_release_sync_state();

  private:
  const ::livekit::SyncState& _internal_sync_state() const;
  ::livekit::SyncState* PROTOBUF_NONNULL _internal_mutable_sync_state();

  public:
  // .livekit.SimulateScenario simulate = 13;
  bool has_simulate() const;
  private:
  bool _internal_has_simulate() const;

  public:
  void clear_simulate() ;
  const ::livekit::SimulateScenario& simulate() const;
  [[nodiscard]] ::livekit::SimulateScenario* PROTOBUF_NULLABLE release_simulate();
  ::livekit::SimulateScenario* PROTOBUF_NONNULL mutable_simulate();
  void set_allocated_simulate(::livekit::SimulateScenario* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_simulate(::livekit::SimulateScenario* PROTOBUF_NULLABLE value);
  ::livekit::SimulateScenario* PROTOBUF_NULLABLE unsafe_arena_release_simulate();

  private:
  const ::livekit::SimulateScenario& _internal_simulate() const;
  ::livekit::SimulateScenario* PROTOBUF_NONNULL _internal_mutable_simulate();

  public:
  // int64 ping = 14;
  bool has_ping() const;
  void clear_ping() ;
  ::int64_t ping() const;
  void set_ping(::int64_t value);

  private:
  ::int64_t _internal_ping() const;
  void _internal_set_ping(::int64_t value);

  public:
  // .livekit.UpdateParticipantMetadata update_metadata = 15;
  bool has_update_metadata() const;
  private:
  bool _internal_has_update_metadata() const;

  public:
  void clear_update_metadata() ;
  const ::livekit::UpdateParticipantMetadata& update_metadata() const;
  [[nodiscard]] ::livekit::UpdateParticipantMetadata* PROTOBUF_NULLABLE release_update_metadata();
  ::livekit::UpdateParticipantMetadata* PROTOBUF_NONNULL mutable_update_metadata();
  void set_allocated_update_metadata(::livekit::UpdateParticipantMetadata* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_update_metadata(::livekit::UpdateParticipantMetadata* PROTOBUF_NULLABLE value);
  ::livekit::UpdateParticipantMetadata* PROTOBUF_NULLABLE unsafe_arena_release_update_metadata();

  private:
  const ::livekit::UpdateParticipantMetadata& _internal_update_metadata() const;
  ::livekit::UpdateParticipantMetadata* PROTOBUF_NONNULL _internal_mutable_update_metadata();

  public:
  // .livekit.Ping ping_req = 16;
  bool has_ping_req() const;
  private:
  bool _internal_has_ping_req() const;

  public:
  void clear_ping_req() ;
  const ::livekit::Ping& ping_req() const;
  [[nodiscard]] ::livekit::Ping* PROTOBUF_NULLABLE release_ping_req();
  ::livekit::Ping* PROTOBUF_NONNULL mutable_ping_req();
  void set_allocated_ping_req(::livekit::Ping* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_ping_req(::livekit::Ping* PROTOBUF_NULLABLE value);
  ::livekit::Ping* PROTOBUF_NULLABLE unsafe_arena_release_ping_req();

  private:
  const ::livekit::Ping& _internal_ping_req() const;
  ::livekit::Ping* PROTOBUF_NONNULL _internal_mutable_ping_req();

  public:
  // .livekit.UpdateLocalAudioTrack update_audio_track = 17;
  bool has_update_audio_track() const;
  private:
  bool _internal_has_update_audio_track() const;

  public:
  void clear_update_audio_track() ;
  const ::livekit::UpdateLocalAudioTrack& update_audio_track() const;
  [[nodiscard]] ::livekit::UpdateLocalAudioTrack* PROTOBUF_NULLABLE release_update_audio_track();
  ::livekit::UpdateLocalAudioTrack* PROTOBUF_NONNULL mutable_update_audio_track();
  void set_allocated_update_audio_track(::livekit::UpdateLocalAudioTrack* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_update_audio_track(::livekit::UpdateLocalAudioTrack* PROTOBUF_NULLABLE value);
  ::livekit::UpdateLocalAudioTrack* PROTOBUF_NULLABLE unsafe_arena_release_update_audio_track();

  private:
  const ::livekit::UpdateLocalAudioTrack& _internal_update_audio_track() const;
  ::livekit::UpdateLocalAudioTrack* PROTOBUF_NONNULL _internal_mutable_update_audio_track();

  public:
  // .livekit.UpdateLocalVideoTrack update_video_track = 18;
  bool has_update_video_track() const;
  private:
  bool _internal_has_update_video_track() const;

  public:
  void clear_update_video_track() ;
  const ::livekit::UpdateLocalVideoTrack& update_video_track() const;
  [[nodiscard]] ::livekit::UpdateLocalVideoTrack* PROTOBUF_NULLABLE release_update_video_track();
  ::livekit::UpdateLocalVideoTrack* PROTOBUF_NONNULL mutable_update_video_track();
  void set_allocated_update_video_track(::livekit::UpdateLocalVideoTrack* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_update_video_track(::livekit::UpdateLocalVideoTrack* PROTOBUF_NULLABLE value);
  ::livekit::UpdateLocalVideoTrack* PROTOBUF_NULLABLE unsafe_arena_release_update_video_track();

  private:
  const ::livekit::UpdateLocalVideoTrack& _internal_update_video_track() const;
  ::livekit::UpdateLocalVideoTrack* PROTOBUF_NONNULL _internal_mutable_update_video_track();

  public:
  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:livekit.SignalRequest)
 private:
  class _Internal;
  void set_has_offer();
  void set_has_answer();
  void set_has_trickle();
  void set_has_add_track();
  void set_has_mute();
  void set_has_subscription();
  void set_has_track_setting();
  void set_has_leave();
  void set_has_update_layers();
  void set_has_subscription_permission();
  void set_has_sync_state();
  void set_has_simulate();
  void set_has_ping();
  void set_has_update_metadata();
  void set_has_ping_req();
  void set_has_update_audio_track();
  void set_has_update_video_track();
  inline bool has_message() const;
  inline void clear_has_message();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 17,
                                   16, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SignalRequest& from_msg);
    union MessageUnion {
      constexpr MessageUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE offer_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE answer_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE trickle_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE add_track_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE mute_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE subscription_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE track_setting_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE leave_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE update_layers_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE subscription_permission_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE sync_state_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE simulate_;
      ::int64_t ping_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE update_metadata_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE ping_req_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE update_audio_track_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE update_video_track_;
    } message_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SignalRequest_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// SignalRequest

// .livekit.SessionDescription offer = 1;
inline bool SignalRequest::has_offer() const {
  return message_case() == kOffer;
}
inline bool SignalRequest::_internal_has_offer() const {
  return message_case() == kOffer;
}
inline void SignalRequest::set_has_offer() {
  _impl_._oneof_case_[0] = kOffer;
}
inline void SignalRequest::clear_offer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kOffer) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.offer_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.offer_);
    }
    clear_has_message();
  }
}
inline ::livekit::SessionDescription* PROTOBUF_NULLABLE SignalRequest::release_offer() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.offer)
  if (message_case() == kOffer) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::SessionDescription*>(_impl_.message_.offer_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.offer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::SessionDescription& SignalRequest::_internal_offer() const {
  return message_case() == kOffer ? *reinterpret_cast<::livekit::SessionDescription*>(_impl_.message_.offer_) : reinterpret_cast<::livekit::SessionDescription&>(::livekit::_SessionDescription_default_instance_);
}
inline const ::livekit::SessionDescription& SignalRequest::offer() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.offer)
  return _internal_offer();
}
inline ::livekit::SessionDescription* PROTOBUF_NULLABLE SignalRequest::unsafe_arena_release_offer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.offer)
  if (message_case() == kOffer) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::SessionDescription*>(_impl_.message_.offer_);
    _impl_.message_.offer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_offer(
    ::livekit::SessionDescription* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_offer();
    _impl_.message_.offer_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.offer)
}
inline ::livekit::SessionDescription* PROTOBUF_NONNULL SignalRequest::_internal_mutable_offer() {
  if (message_case() != kOffer) {
    clear_message();
    set_has_offer();
    _impl_.message_.offer_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::SessionDescription>(GetArena()));
  }
  return reinterpret_cast<::livekit::SessionDescription*>(_impl_.message_.offer_);
}
inline ::livekit::SessionDescription* PROTOBUF_NONNULL SignalRequest::mutable_offer()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::SessionDescription* _msg = _internal_mutable_offer();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.offer)
  return _msg;
}

// .livekit.SessionDescription answer = 2;
inline bool SignalRequest::has_answer() const {
  return message_case() == kAnswer;
}
inline bool SignalRequest::_internal_has_answer() const {
  return message_case() == kAnswer;
}
inline void SignalRequest::set_has_answer() {
  _impl_._oneof_case_[0] = kAnswer;
}
inline void SignalRequest::clear_answer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kAnswer) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.answer_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.answer_);
    }
    clear_has_message();
  }
}
inline ::livekit::SessionDescription* PROTOBUF_NULLABLE SignalRequest::release_answer() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.answer)
  if (message_case() == kAnswer) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::SessionDescription*>(_impl_.message_.answer_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.answer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::SessionDescription& SignalRequest::_internal_answer() const {
  return message_case() == kAnswer ? *reinterpret_cast<::livekit::SessionDescription*>(_impl_.message_.answer_) : reinterpret_cast<::livekit::SessionDescription&>(::livekit::_SessionDescription_default_instance_);
}
inline const ::livekit::SessionDescription& SignalRequest::answer() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.answer)
  return _internal_answer();
}
inline ::livekit::SessionDescription* PROTOBUF_NULLABLE SignalRequest::unsafe_arena_release_answer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.answer)
  if (message_case() == kAnswer) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::SessionDescription*>(_impl_.message_.answer_);
    _impl_.message_.answer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_answer(
    ::livekit::SessionDescription* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_answer();
    _impl_.message_.answer_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.answer)
}
inline ::livekit::SessionDescription* PROTOBUF_NONNULL SignalRequest::_internal_mutable_answer() {
  if (message_case() != kAnswer) {
    clear_message();
    set_has_answer();
    _impl_.message_.answer_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::SessionDescription>(GetArena()));
  }
  return reinterpret_cast<::livekit::SessionDescription*>(_impl_.message_.answer_);
}
inline ::livekit::SessionDescription* PROTOBUF_NONNULL SignalRequest::mutable_answer()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::SessionDescription* _msg = _internal_mutable_answer();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.answer)
  return _msg;
}

// .livekit.TrickleRequest trickle = 3;
inline bool SignalRequest::has_trickle() const {
  return message_case() == kTrickle;
}
inline bool SignalRequest::_internal_has_trickle() const {
  return message_case() == kTrickle;
}
inline void SignalRequest::set_has_trickle() {
  _impl_._oneof_case_[0] = kTrickle;
}
inline void SignalRequest::clear_trickle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kTrickle) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.trickle_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.trickle_);
    }
    clear_has_message();
  }
}
inline ::livekit::TrickleRequest* PROTOBUF_NULLABLE SignalRequest::release_trickle() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.trickle)
  if (message_case() == kTrickle) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::TrickleRequest*>(_impl_.message_.trickle_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.trickle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::TrickleRequest& SignalRequest::_internal_trickle() const {
  return message_case() == kTrickle ? *reinterpret_cast<::livekit::TrickleRequest*>(_impl_.message_.trickle_) : reinterpret_cast<::livekit::TrickleRequest&>(::livekit::_TrickleRequest_default_instance_);
}
inline const ::livekit::TrickleRequest& SignalRequest::trickle() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.trickle)
  return _internal_trickle();
}
inline ::livekit::TrickleRequest* PROTOBUF_NULLABLE SignalRequest::unsafe_arena_release_trickle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.trickle)
  if (message_case() == kTrickle) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::TrickleRequest*>(_impl_.message_.trickle_);
    _impl_.message_.trickle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_trickle(
    ::livekit::TrickleRequest* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_trickle();
    _impl_.message_.trickle_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.trickle)
}
inline ::livekit::TrickleRequest* PROTOBUF_NONNULL SignalRequest::_internal_mutable_trickle() {
  if (message_case() != kTrickle) {
    clear_message();
    set_has_trickle();
    _impl_.message_.trickle_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::TrickleRequest>(GetArena()));
  }
  return reinterpret_cast<::livekit::TrickleRequest*>(_impl_.message_.trickle_);
}
inline ::livekit::TrickleRequest* PROTOBUF_NONNULL SignalRequest::mutable_trickle()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::TrickleRequest* _msg = _internal_mutable_trickle();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.trickle)
  return _msg;
}

// .livekit.AddTrackRequest add_track = 4;
inline bool SignalRequest::has_add_track() const {
  return message_case() == kAddTrack;
}
inline bool SignalRequest::_internal_has_add_track() const {
  return message_case() == kAddTrack;
}
inline void SignalRequest::set_has_add_track() {
  _impl_._oneof_case_[0] = kAddTrack;
}
inline void SignalRequest::clear_add_track() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kAddTrack) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.add_track_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.add_track_);
    }
    clear_has_message();
  }
}
inline ::livekit::AddTrackRequest* PROTOBUF_NULLABLE SignalRequest::release_add_track() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.add_track)
  if (message_case() == kAddTrack) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::AddTrackRequest*>(_impl_.message_.add_track_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.add_track_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::AddTrackRequest& SignalRequest::_internal_add_track() const {
  return message_case() == kAddTrack ? *reinterpret_cast<::livekit::AddTrackRequest*>(_impl_.message_.add_track_) : reinterpret_cast<::livekit::AddTrackRequest&>(::livekit::_AddTrackRequest_default_instance_);
}
inline const ::livekit::AddTrackRequest& SignalRequest::add_track() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.add_track)
  return _internal_add_track();
}
inline ::livekit::AddTrackRequest* PROTOBUF_NULLABLE SignalRequest::unsafe_arena_release_add_track() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.add_track)
  if (message_case() == kAddTrack) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::AddTrackRequest*>(_impl_.message_.add_track_);
    _impl_.message_.add_track_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_add_track(
    ::livekit::AddTrackRequest* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_add_track();
    _impl_.message_.add_track_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.add_track)
}
inline ::livekit::AddTrackRequest* PROTOBUF_NONNULL SignalRequest::_internal_mutable_add_track() {
  if (message_case() != kAddTrack) {
    clear_message();
    set_has_add_track();
    _impl_.message_.add_track_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::AddTrackRequest>(GetArena()));
  }
  return reinterpret_cast<::livekit::AddTrackRequest*>(_impl_.message_.add_track_);
}
inline ::livekit::AddTrackRequest* PROTOBUF_NONNULL SignalRequest::mutable_add_track()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::AddTrackRequest* _msg = _internal_mutable_add_track();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.add_track)
  return _msg;
}

// .livekit.MuteTrackRequest mute = 5;
inline bool SignalRequest::has_mute() const {
  return message_case() == kMute;
}
inline bool SignalRequest::_internal_has_mute() const {
  return message_case() == kMute;
}
inline void SignalRequest::set_has_mute() {
  _impl_._oneof_case_[0] = kMute;
}
inline void SignalRequest::clear_mute() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kMute) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.mute_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.mute_);
    }
    clear_has_message();
  }
}
inline ::livekit::MuteTrackRequest* PROTOBUF_NULLABLE SignalRequest::release_mute() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.mute)
  if (message_case() == kMute) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::MuteTrackRequest*>(_impl_.message_.mute_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.mute_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::MuteTrackRequest& SignalRequest::_internal_mute() const {
  return message_case() == kMute ? *reinterpret_cast<::livekit::MuteTrackRequest*>(_impl_.message_.mute_) : reinterpret_cast<::livekit::MuteTrackRequest&>(::livekit::_MuteTrackRequest_default_instance_);
}
inline const ::livekit::MuteTrackRequest& SignalRequest::mute() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.mute)
  return _internal_mute();
}
inline ::livekit::MuteTrackRequest* PROTOBUF_NULLABLE SignalRequest::unsafe_arena_release_mute() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.mute)
  if (message_case() == kMute) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::MuteTrackRequest*>(_impl_.message_.mute_);
    _impl_.message_.mute_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_mute(
    ::livekit::MuteTrackRequest* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_mute();
    _impl_.message_.mute_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.mute)
}
inline ::livekit::MuteTrackRequest* PROTOBUF_NONNULL SignalRequest::_internal_mutable_mute() {
  if (message_case() != kMute) {
    clear_message();
    set_has_mute();
    _impl_.message_.mute_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::MuteTrackRequest>(GetArena()));
  }
  return reinterpret_cast<::livekit::MuteTrackRequest*>(_impl_.message_.mute_);
}
inline ::livekit::MuteTrackRequest* PROTOBUF_NONNULL SignalRequest::mutable_mute()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::MuteTrackRequest* _msg = _internal_mutable_mute();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.mute)
  return _msg;
}

// .livekit.UpdateSubscription subscription = 6;
inline bool SignalRequest::has_subscription() const {
  return message_case() == kSubscription;
}
inline bool SignalRequest::_internal_has_subscription() const {
  return message_case() == kSubscription;
}
inline void SignalRequest::set_has_subscription() {
  _impl_._oneof_case_[0] = kSubscription;
}
inline void SignalRequest::clear_subscription() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kSubscription) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.subscription_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.subscription_);
    }
    clear_has_message();
  }
}
inline ::livekit::UpdateSubscription* PROTOBUF_NULLABLE SignalRequest::release_subscription() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.subscription)
  if (message_case() == kSubscription) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::UpdateSubscription*>(_impl_.message_.subscription_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.subscription_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::UpdateSubscription& SignalRequest::_internal_subscription() const {
  return message_case() == kSubscription ? *reinterpret_cast<::livekit::UpdateSubscription*>(_impl_.message_.subscription_) : reinterpret_cast<::livekit::UpdateSubscription&>(::livekit::_UpdateSubscription_default_instance_);
}
inline const ::livekit::UpdateSubscription& SignalRequest::subscription() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.subscription)
  return _internal_subscription();
}
inline ::livekit::UpdateSubscription* PROTOBUF_NULLABLE SignalRequest::unsafe_arena_release_subscription() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.subscription)
  if (message_case() == kSubscription) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::UpdateSubscription*>(_impl_.message_.subscription_);
    _impl_.message_.subscription_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_subscription(
    ::livekit::UpdateSubscription* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_subscription();
    _impl_.message_.subscription_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.subscription)
}
inline ::livekit::UpdateSubscription* PROTOBUF_NONNULL SignalRequest::_internal_mutable_subscription() {
  if (message_case() != kSubscription) {
    clear_message();
    set_has_subscription();
    _impl_.message_.subscription_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::UpdateSubscription>(GetArena()));
  }
  return reinterpret_cast<::livekit::UpdateSubscription*>(_impl_.message_.subscription_);
}
inline ::livekit::UpdateSubscription* PROTOBUF_NONNULL SignalRequest::mutable_subscription()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::UpdateSubscription* _msg = _internal_mutable_subscription();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.subscription)
  return _msg;
}

// .livekit.UpdateTrackSettings track_setting = 7;
inline bool SignalRequest::has_track_setting() const {
  return message_case() == kTrackSetting;
}
inline bool SignalRequest::_internal_has_track_setting() const {
  return message_case() == kTrackSetting;
}
inline void SignalRequest::set_has_track_setting() {
  _impl_._oneof_case_[0] = kTrackSetting;
}
inline void SignalRequest::clear_track_setting() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kTrackSetting) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.track_setting_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.track_setting_);
    }
    clear_has_message();
  }
}
inline ::livekit::UpdateTrackSettings* PROTOBUF_NULLABLE SignalRequest::release_track_setting() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.track_setting)
  if (message_case() == kTrackSetting) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::UpdateTrackSettings*>(_impl_.message_.track_setting_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.track_setting_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::UpdateTrackSettings& SignalRequest::_internal_track_setting() const {
  return message_case() == kTrackSetting ? *reinterpret_cast<::livekit::UpdateTrackSettings*>(_impl_.message_.track_setting_) : reinterpret_cast<::livekit::UpdateTrackSettings&>(::livekit::_UpdateTrackSettings_default_instance_);
}
inline const ::livekit::UpdateTrackSettings& SignalRequest::track_setting() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.track_setting)
  return _internal_track_setting();
}
inline ::livekit::UpdateTrackSettings* PROTOBUF_NULLABLE SignalRequest::unsafe_arena_release_track_setting() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.track_setting)
  if (message_case() == kTrackSetting) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::UpdateTrackSettings*>(_impl_.message_.track_setting_);
    _impl_.message_.track_setting_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_track_setting(
    ::livekit::UpdateTrackSettings* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_track_setting();
    _impl_.message_.track_setting_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.track_setting)
}
inline ::livekit::UpdateTrackSettings* PROTOBUF_NONNULL SignalRequest::_internal_mutable_track_setting() {
  if (message_case() != kTrackSetting) {
    clear_message();
    set_has_track_setting();
    _impl_.message_.track_setting_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::UpdateTrackSettings>(GetArena()));
  }
  return reinterpret_cast<::livekit::UpdateTrackSettings*>(_impl_.message_.track_setting_);
}
inline ::livekit::UpdateTrackSettings* PROTOBUF_NONNULL SignalRequest::mutable_track_setting()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::UpdateTrackSettings* _msg = _internal_mutable_track_setting();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.track_setting)
  return _msg;
}

// .livekit.LeaveRequest leave = 8;
inline bool SignalRequest::has_leave() const {
  return message_case() == kLeave;
}
inline bool SignalRequest::_internal_has_leave() const {
  return message_case() == kLeave;
}
inline void SignalRequest::set_has_leave() {
  _impl_._oneof_case_[0] = kLeave;
}
inline void SignalRequest::clear_leave() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kLeave) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.leave_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.leave_);
    }
    clear_has_message();
  }
}
inline ::livekit::LeaveRequest* PROTOBUF_NULLABLE SignalRequest::release_leave() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.leave)
  if (message_case() == kLeave) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::LeaveRequest*>(_impl_.message_.leave_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.leave_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::LeaveRequest& SignalRequest::_internal_leave() const {
  return message_case() == kLeave ? *reinterpret_cast<::livekit::LeaveRequest*>(_impl_.message_.leave_) : reinterpret_cast<::livekit::LeaveRequest&>(::livekit::_LeaveRequest_default_instance_);
}
inline const ::livekit::LeaveRequest& SignalRequest::leave() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.leave)
  return _internal_leave();
}
inline ::livekit::LeaveRequest* PROTOBUF_NULLABLE SignalRequest::unsafe_arena_release_leave() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.leave)
  if (message_case() == kLeave) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::LeaveRequest*>(_impl_.message_.leave_);
    _impl_.message_.leave_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_leave(
    ::livekit::LeaveRequest* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_leave();
    _impl_.message_.leave_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.leave)
}
inline ::livekit::LeaveRequest* PROTOBUF_NONNULL SignalRequest::_internal_mutable_leave() {
  if (message_case() != kLeave) {
    clear_message();
    set_has_leave();
    _impl_.message_.leave_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::LeaveRequest>(GetArena()));
  }
  return reinterpret_cast<::livekit::LeaveRequest*>(_impl_.message_.leave_);
}
inline ::livekit::LeaveRequest* PROTOBUF_NONNULL SignalRequest::mutable_leave()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::LeaveRequest* _msg = _internal_mutable_leave();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.leave)
  return _msg;
}

// .livekit.UpdateVideoLayers update_layers = 10 [deprecated = true];
inline bool SignalRequest::has_update_layers() const {
  return message_case() == kUpdateLayers;
}
inline bool SignalRequest::_internal_has_update_layers() const {
  return message_case() == kUpdateLayers;
}
inline void SignalRequest::set_has_update_layers() {
  _impl_._oneof_case_[0] = kUpdateLayers;
}
inline void SignalRequest::clear_update_layers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kUpdateLayers) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.update_layers_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.update_layers_);
    }
    clear_has_message();
  }
}
inline ::livekit::UpdateVideoLayers* PROTOBUF_NULLABLE SignalRequest::release_update_layers() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.update_layers)
  if (message_case() == kUpdateLayers) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::UpdateVideoLayers*>(_impl_.message_.update_layers_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.update_layers_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::UpdateVideoLayers& SignalRequest::_internal_update_layers() const {
  return message_case() == kUpdateLayers ? *reinterpret_cast<::livekit::UpdateVideoLayers*>(_impl_.message_.update_layers_) : reinterpret_cast<::livekit::UpdateVideoLayers&>(::livekit::_UpdateVideoLayers_default_instance_);
}
inline const ::livekit::UpdateVideoLayers& SignalRequest::update_layers() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.update_layers)
  return _internal_update_layers();
}
inline ::livekit::UpdateVideoLayers* PROTOBUF_NULLABLE SignalRequest::unsafe_arena_release_update_layers() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.update_layers)
  if (message_case() == kUpdateLayers) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::UpdateVideoLayers*>(_impl_.message_.update_layers_);
    _impl_.message_.update_layers_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_update_layers(
    ::livekit::UpdateVideoLayers* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_update_layers();
    _impl_.message_.update_layers_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.update_layers)
}
inline ::livekit::UpdateVideoLayers* PROTOBUF_NONNULL SignalRequest::_internal_mutable_update_layers() {
  if (message_case() != kUpdateLayers) {
    clear_message();
    set_has_update_layers();
    _impl_.message_.update_layers_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::UpdateVideoLayers>(GetArena()));
  }
  return reinterpret_cast<::livekit::UpdateVideoLayers*>(_impl_.message_.update_layers_);
}
inline ::livekit::UpdateVideoLayers* PROTOBUF_NONNULL SignalRequest::mutable_update_layers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::UpdateVideoLayers* _msg = _internal_mutable_update_layers();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.update_layers)
  return _msg;
}

// .livekit.SubscriptionPermission subscription_permission = 11;
inline bool SignalRequest::has_subscription_permission() const {
  return message_case() == kSubscriptionPermission;
}
inline bool SignalRequest::_internal_has_subscription_permission() const {
  return message_case() == kSubscriptionPermission;
}
inline void SignalRequest::set_has_subscription_permission() {
  _impl_._oneof_case_[0] = kSubscriptionPermission;
}
inline void SignalRequest::clear_subscription_permission() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kSubscriptionPermission) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.subscription_permission_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.subscription_permission_);
    }
    clear_has_message();
  }
}
inline ::livekit::SubscriptionPermission* PROTOBUF_NULLABLE SignalRequest::release_subscription_permission() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.subscription_permission)
  if (message_case() == kSubscriptionPermission) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::SubscriptionPermission*>(_impl_.message_.subscription_permission_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.subscription_permission_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::SubscriptionPermission& SignalRequest::_internal_subscription_permission() const {
  return message_case() == kSubscriptionPermission ? *reinterpret_cast<::livekit::SubscriptionPermission*>(_impl_.message_.subscription_permission_) : reinterpret_cast<::livekit::SubscriptionPermission&>(::livekit::_SubscriptionPermission_default_instance_);
}
inline const ::livekit::SubscriptionPermission& SignalRequest::subscription_permission() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.subscription_permission)
  return _internal_subscription_permission();
}
inline ::livekit::SubscriptionPermission* PROTOBUF_NULLABLE SignalRequest::unsafe_arena_release_subscription_permission() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.subscription_permission)
  if (message_case() == kSubscriptionPermission) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::SubscriptionPermission*>(_impl_.message_.subscription_permission_);
    _impl_.message_.subscription_permission_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_subscription_permission(
    ::livekit::SubscriptionPermission* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_subscription_permission();
    _impl_.message_.subscription_permission_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.subscription_permission)
}
inline ::livekit::SubscriptionPermission* PROTOBUF_NONNULL SignalRequest::_internal_mutable_subscription_permission() {
  if (message_case() != kSubscriptionPermission) {
    clear_message();
    set_has_subscription_permission();
    _impl_.message_.subscription_permission_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::SubscriptionPermission>(GetArena()));
  }
  return reinterpret_cast<::livekit::SubscriptionPermission*>(_impl_.message_.subscription_permission_);
}
inline ::livekit::SubscriptionPermission* PROTOBUF_NONNULL SignalRequest::mutable_subscription_permission()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::SubscriptionPermission* _msg = _internal_mutable_subscription_permission();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.subscription_permission)
  return _msg;
}

// .livekit.SyncState sync_state = 12;
inline bool SignalRequest::has_sync_state() const {
  return message_case() == kSyncState;
}
inline bool SignalRequest::_internal_has_sync_state() const {
  return message_case() == kSyncState;
}
inline void SignalRequest::set_has_sync_state() {
  _impl_._oneof_case_[0] = kSyncState;
}
inline void SignalRequest::clear_sync_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kSyncState) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.sync_state_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.sync_state_);
    }
    clear_has_message();
  }
}
inline ::livekit::SyncState* PROTOBUF_NULLABLE SignalRequest::release_sync_state() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.sync_state)
  if (message_case() == kSyncState) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::SyncState*>(_impl_.message_.sync_state_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.sync_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::SyncState& SignalRequest::_internal_sync_state() const {
  return message_case() == kSyncState ? *reinterpret_cast<::livekit::SyncState*>(_impl_.message_.sync_state_) : reinterpret_cast<::livekit::SyncState&>(::livekit::_SyncState_default_instance_);
}
inline const ::livekit::SyncState& SignalRequest::sync_state() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.sync_state)
  return _internal_sync_state();
}
inline ::livekit::SyncState* PROTOBUF_NULLABLE SignalRequest::unsafe_arena_release_sync_state() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.sync_state)
  if (message_case() == kSyncState) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::SyncState*>(_impl_.message_.sync_state_);
    _impl_.message_.sync_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_sync_state(
    ::livekit::SyncState* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_sync_state();
    _impl_.message_.sync_state_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.sync_state)
}
inline ::livekit::SyncState* PROTOBUF_NONNULL SignalRequest::_internal_mutable_sync_state() {
  if (message_case() != kSyncState) {
    clear_message();
    set_has_sync_state();
    _impl_.message_.sync_state_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::SyncState>(GetArena()));
  }
  return reinterpret_cast<::livekit::SyncState*>(_impl_.message_.sync_state_);
}
inline ::livekit::SyncState* PROTOBUF_NONNULL SignalRequest::mutable_sync_state()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::SyncState* _msg = _internal_mutable_sync_state();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.sync_state)
  return _msg;
}

// .livekit.SimulateScenario simulate = 13;
inline bool SignalRequest::has_simulate() const {
  return message_case() == kSimulate;
}
inline bool SignalRequest::_internal_has_simulate() const {
  return message_case() == kSimulate;
}
inline void SignalRequest::set_has_simulate() {
  _impl_._oneof_case_[0] = kSimulate;
}
inline void SignalRequest::clear_simulate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kSimulate) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.simulate_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.simulate_);
    }
    clear_has_message();
  }
}
inline ::livekit::SimulateScenario* PROTOBUF_NULLABLE SignalRequest::release_simulate() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.simulate)
  if (message_case() == kSimulate) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::SimulateScenario*>(_impl_.message_.simulate_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.simulate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::SimulateScenario& SignalRequest::_internal_simulate() const {
  return message_case() == kSimulate ? *reinterpret_cast<::livekit::SimulateScenario*>(_impl_.message_.simulate_) : reinterpret_cast<::livekit::SimulateScenario&>(::livekit::_SimulateScenario_default_instance_);
}
inline const ::livekit::SimulateScenario& SignalRequest::simulate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.simulate)
  return _internal_simulate();
}
inline ::livekit::SimulateScenario* PROTOBUF_NULLABLE SignalRequest::unsafe_arena_release_simulate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.simulate)
  if (message_case() == kSimulate) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::SimulateScenario*>(_impl_.message_.simulate_);
    _impl_.message_.simulate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_simulate(
    ::livekit::SimulateScenario* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_simulate();
    _impl_.message_.simulate_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.simulate)
}
inline ::livekit::SimulateScenario* PROTOBUF_NONNULL SignalRequest::_internal_mutable_simulate() {
  if (message_case() != kSimulate) {
    clear_message();
    set_has_simulate();
    _impl_.message_.simulate_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::SimulateScenario>(GetArena()));
  }
  return reinterpret_cast<::livekit::SimulateScenario*>(_impl_.message_.simulate_);
}
inline ::livekit::SimulateScenario* PROTOBUF_NONNULL SignalRequest::mutable_simulate()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::SimulateScenario* _msg = _internal_mutable_simulate();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.simulate)
  return _msg;
}

// int64 ping = 14;
inline bool SignalRequest::has_ping() const {
  return message_case() == kPing;
}
inline void SignalRequest::set_has_ping() {
  _impl_._oneof_case_[0] = kPing;
}
inline void SignalRequest::clear_ping() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kPing) {
    _impl_.message_.ping_ = ::int64_t{0};
    clear_has_message();
  }
}
inline ::int64_t SignalRequest::ping() const {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.ping)
  return _internal_ping();
}
inline void SignalRequest::set_ping(::int64_t value) {
  if (message_case() != kPing) {
    clear_message();
    set_has_ping();
  }
  _impl_.message_.ping_ = value;
  // @@protoc_insertion_point(field_set:livekit.SignalRequest.ping)
}
inline ::int64_t SignalRequest::_internal_ping() const {
  if (message_case() == kPing) {
    return _impl_.message_.ping_;
  }
  return ::int64_t{0};
}

// .livekit.UpdateParticipantMetadata update_metadata = 15;
inline bool SignalRequest::has_update_metadata() const {
  return message_case() == kUpdateMetadata;
}
inline bool SignalRequest::_internal_has_update_metadata() const {
  return message_case() == kUpdateMetadata;
}
inline void SignalRequest::set_has_update_metadata() {
  _impl_._oneof_case_[0] = kUpdateMetadata;
}
inline void SignalRequest::clear_update_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kUpdateMetadata) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.update_metadata_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.update_metadata_);
    }
    clear_has_message();
  }
}
inline ::livekit::UpdateParticipantMetadata* PROTOBUF_NULLABLE SignalRequest::release_update_metadata() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.update_metadata)
  if (message_case() == kUpdateMetadata) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::UpdateParticipantMetadata*>(_impl_.message_.update_metadata_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.update_metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::UpdateParticipantMetadata& SignalRequest::_internal_update_metadata() const {
  return message_case() == kUpdateMetadata ? *reinterpret_cast<::livekit::UpdateParticipantMetadata*>(_impl_.message_.update_metadata_) : reinterpret_cast<::livekit::UpdateParticipantMetadata&>(::livekit::_UpdateParticipantMetadata_default_instance_);
}
inline const ::livekit::UpdateParticipantMetadata& SignalRequest::update_metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.update_metadata)
  return _internal_update_metadata();
}
inline ::livekit::UpdateParticipantMetadata* PROTOBUF_NULLABLE SignalRequest::unsafe_arena_release_update_metadata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.update_metadata)
  if (message_case() == kUpdateMetadata) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::UpdateParticipantMetadata*>(_impl_.message_.update_metadata_);
    _impl_.message_.update_metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_update_metadata(
    ::livekit::UpdateParticipantMetadata* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_update_metadata();
    _impl_.message_.update_metadata_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.update_metadata)
}
inline ::livekit::UpdateParticipantMetadata* PROTOBUF_NONNULL SignalRequest::_internal_mutable_update_metadata() {
  if (message_case() != kUpdateMetadata) {
    clear_message();
    set_has_update_metadata();
    _impl_.message_.update_metadata_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::UpdateParticipantMetadata>(GetArena()));
  }
  return reinterpret_cast<::livekit::UpdateParticipantMetadata*>(_impl_.message_.update_metadata_);
}
inline ::livekit::UpdateParticipantMetadata* PROTOBUF_NONNULL SignalRequest::mutable_update_metadata()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::UpdateParticipantMetadata* _msg = _internal_mutable_update_metadata();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.update_metadata)
  return _msg;
}

// .livekit.Ping ping_req = 16;
inline bool SignalRequest::has_ping_req() const {
  return message_case() == kPingReq;
}
inline bool SignalRequest::_internal_has_ping_req() const {
  return message_case() == kPingReq;
}
inline void SignalRequest::set_has_ping_req() {
  _impl_._oneof_case_[0] = kPingReq;
}
inline void SignalRequest::clear_ping_req() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kPingReq) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.ping_req_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.ping_req_);
    }
    clear_has_message();
  }
}
inline ::livekit::Ping* PROTOBUF_NULLABLE SignalRequest::release_ping_req() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.ping_req)
  if (message_case() == kPingReq) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::Ping*>(_impl_.message_.ping_req_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.ping_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::Ping& SignalRequest::_internal_ping_req() const {
  return message_case() == kPingReq ? *reinterpret_cast<::livekit::Ping*>(_impl_.message_.ping_req_) : reinterpret_cast<::livekit::Ping&>(::livekit::_Ping_default_instance_);
}
inline const ::livekit::Ping& SignalRequest::ping_req() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.ping_req)
  return _internal_ping_req();
}
inline ::livekit::Ping* PROTOBUF_NULLABLE SignalRequest::unsafe_arena_release_ping_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.ping_req)
  if (message_case() == kPingReq) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::Ping*>(_impl_.message_.ping_req_);
    _impl_.message_.ping_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_ping_req(
    ::livekit::Ping* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_ping_req();
    _impl_.message_.ping_req_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.ping_req)
}
inline ::livekit::Ping* PROTOBUF_NONNULL SignalRequest::_internal_mutable_ping_req() {
  if (message_case() != kPingReq) {
    clear_message();
    set_has_ping_req();
    _impl_.message_.ping_req_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::Ping>(GetArena()));
  }
  return reinterpret_cast<::livekit::Ping*>(_impl_.message_.ping_req_);
}
inline ::livekit::Ping* PROTOBUF_NONNULL SignalRequest::mutable_ping_req()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::Ping* _msg = _internal_mutable_ping_req();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.ping_req)
  return _msg;
}

// .livekit.UpdateLocalAudioTrack update_audio_track = 17;
inline bool SignalRequest::has_update_audio_track() const {
  return message_case() == kUpdateAudioTrack;
}
inline bool SignalRequest::_internal_has_update_audio_track() const {
  return message_case() == kUpdateAudioTrack;
}
inline void SignalRequest::set_has_update_audio_track() {
  _impl_._oneof_case_[0] = kUpdateAudioTrack;
}
inline void SignalRequest::clear_update_audio_track() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kUpdateAudioTrack) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.update_audio_track_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.update_audio_track_);
    }
    clear_has_message();
  }
}
inline ::livekit::UpdateLocalAudioTrack* PROTOBUF_NULLABLE SignalRequest::release_update_audio_track() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.update_audio_track)
  if (message_case() == kUpdateAudioTrack) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::UpdateLocalAudioTrack*>(_impl_.message_.update_audio_track_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.update_audio_track_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::UpdateLocalAudioTrack& SignalRequest::_internal_update_audio_track() const {
  return message_case() == kUpdateAudioTrack ? *reinterpret_cast<::livekit::UpdateLocalAudioTrack*>(_impl_.message_.update_audio_track_) : reinterpret_cast<::livekit::UpdateLocalAudioTrack&>(::livekit::_UpdateLocalAudioTrack_default_instance_);
}
inline const ::livekit::UpdateLocalAudioTrack& SignalRequest::update_audio_track() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.update_audio_track)
  return _internal_update_audio_track();
}
inline ::livekit::UpdateLocalAudioTrack* PROTOBUF_NULLABLE SignalRequest::unsafe_arena_release_update_audio_track() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.update_audio_track)
  if (message_case() == kUpdateAudioTrack) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::UpdateLocalAudioTrack*>(_impl_.message_.update_audio_track_);
    _impl_.message_.update_audio_track_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_update_audio_track(
    ::livekit::UpdateLocalAudioTrack* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_update_audio_track();
    _impl_.message_.update_audio_track_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.update_audio_track)
}
inline ::livekit::UpdateLocalAudioTrack* PROTOBUF_NONNULL SignalRequest::_internal_mutable_update_audio_track() {
  if (message_case() != kUpdateAudioTrack) {
    clear_message();
    set_has_update_audio_track();
    _impl_.message_.update_audio_track_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::UpdateLocalAudioTrack>(GetArena()));
  }
  return reinterpret_cast<::livekit::UpdateLocalAudioTrack*>(_impl_.message_.update_audio_track_);
}
inline ::livekit::UpdateLocalAudioTrack* PROTOBUF_NONNULL SignalRequest::mutable_update_audio_track()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::UpdateLocalAudioTrack* _msg = _internal_mutable_update_audio_track();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.update_audio_track)
  return _msg;
}

// .livekit.UpdateLocalVideoTrack update_video_track = 18;
inline bool SignalRequest::has_update_video_track() const {
  return message_case() == kUpdateVideoTrack;
}
inline bool SignalRequest::_internal_has_update_video_track() const {
  return message_case() == kUpdateVideoTrack;
}
inline void SignalRequest::set_has_update_video_track() {
  _impl_._oneof_case_[0] = kUpdateVideoTrack;
}
inline void SignalRequest::clear_update_video_track() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kUpdateVideoTrack) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.update_video_track_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.update_video_track_);
    }
    clear_has_message();
  }
}
inline ::livekit::UpdateLocalVideoTrack* PROTOBUF_NULLABLE SignalRequest::release_update_video_track() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.update_video_track)
  if (message_case() == kUpdateVideoTrack) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::UpdateLocalVideoTrack*>(_impl_.message_.update_video_track_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.update_video_track_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::UpdateLocalVideoTrack& SignalRequest::_internal_update_video_track() const {
  return message_case() == kUpdateVideoTrack ? *reinterpret_cast<::livekit::UpdateLocalVideoTrack*>(_impl_.message_.update_video_track_) : reinterpret_cast<::livekit::UpdateLocalVideoTrack&>(::livekit::_UpdateLocalVideoTrack_default_instance_);
}
inline const ::livekit::UpdateLocalVideoTrack& SignalRequest::update_video_track() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.update_video_track)
  return _internal_update_video_track();
}
inline ::livekit::UpdateLocalVideoTrack* PROTOBUF_NULLABLE SignalRequest::unsafe_arena_release_update_video_track() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.update_video_track)
  if (message_case() == kUpdateVideoTrack) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::UpdateLocalVideoTrack*>(_impl_.message_.update_video_track_);
    _impl_.message_.update_video_track_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_update_video_track(
    ::livekit::UpdateLocalVideoTrack* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_update_video_track();
    _impl_.message_.update_video_track_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.update_video_track)
}
inline ::livekit::UpdateLocalVideoTrack* PROTOBUF_NONNULL SignalRequest::_internal_mutable_update_video_track() {
  if (message_case() != kUpdateVideoTrack) {
    clear_message();
    set_has_update_video_track();
    _impl_.message_.update_video_track_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::UpdateLocalVideoTrack>(GetArena()));
  }
  return reinterpret_cast<::livekit::UpdateLocalVideoTrack*>(_impl_.message_.update_video_track_);
}
inline ::livekit::UpdateLocalVideoTrack* PROTOBUF_NONNULL SignalRequest::mutable_update_video_track()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::UpdateLocalVideoTrack* _msg = _internal_mutable_update_video_track();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.update_video_track)
  return _msg;
}

inline bool SignalRequest::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void SignalRequest::clear_has_message() {
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}
inline SignalRequest::MessageCase SignalRequest::message_case() const {
  return SignalRequest::MessageCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SignalResponse

// .livekit.JoinResponse join = 1;
inline bool SignalResponse::has_join() const {
  return message_case() == kJoin;
}
inline bool SignalResponse::_internal_has_join() const {
  return message_case() == kJoin;
}
inline void SignalResponse::set_has_join() {
  _impl_._oneof_case_[0] = kJoin;
}
inline void SignalResponse::clear_join() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kJoin) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.join_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.join_);
    }
    clear_has_message();
  }
}
inline ::livekit::JoinResponse* PROTOBUF_NULLABLE SignalResponse::release_join() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.join)
  if (message_case() == kJoin) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::JoinResponse*>(_impl_.message_.join_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::JoinResponse& SignalResponse::_internal_join() const {
  return message_case() == kJoin ? *reinterpret_cast<::livekit::JoinResponse*>(_impl_.message_.join_) : reinterpret_cast<::livekit::JoinResponse&>(::livekit::_JoinResponse_default_instance_);
}
inline const ::livekit::JoinResponse& SignalResponse::join() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.join)
  return _internal_join();
}
inline ::livekit::JoinResponse* PROTOBUF_NULLABLE SignalResponse::unsafe_arena_release_join() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.join)
  if (message_case() == kJoin) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::JoinResponse*>(_impl_.message_.join_);
    _impl_.message_.join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_join(
    ::livekit::JoinResponse* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_join();
    _impl_.message_.join_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.join)
}
inline ::livekit::JoinResponse* PROTOBUF_NONNULL SignalResponse::_internal_mutable_join() {
  if (message_case() != kJoin) {
    clear_message();
    set_has_join();
    _impl_.message_.join_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::JoinResponse>(GetArena()));
  }
  return reinterpret_cast<::livekit::JoinResponse*>(_impl_.message_.join_);
}
inline ::livekit::JoinResponse* PROTOBUF_NONNULL SignalResponse::mutable_join()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::JoinResponse* _msg = _internal_mutable_join();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.join)
  return _msg;
}

// .livekit.SessionDescription answer = 2;
inline bool SignalResponse::has_answer() const {
  return message_case() == kAnswer;
}
inline bool SignalResponse::_internal_has_answer() const {
  return message_case() == kAnswer;
}
inline void SignalResponse::set_has_answer() {
  _impl_._oneof_case_[0] = kAnswer;
}
inline void SignalResponse::clear_answer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kAnswer) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.answer_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.answer_);
    }
    clear_has_message();
  }
}
inline ::livekit::SessionDescription* PROTOBUF_NULLABLE SignalResponse::release_answer() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.answer)
  if (message_case() == kAnswer) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::SessionDescription*>(_impl_.message_.answer_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.answer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::SessionDescription& SignalResponse::_internal_answer() const {
  return message_case() == kAnswer ? *reinterpret_cast<::livekit::SessionDescription*>(_impl_.message_.answer_) : reinterpret_cast<::livekit::SessionDescription&>(::livekit::_SessionDescription_default_instance_);
}
inline const ::livekit::SessionDescription& SignalResponse::answer() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.answer)
  return _internal_answer();
}
inline ::livekit::SessionDescription* PROTOBUF_NULLABLE SignalResponse::unsafe_arena_release_answer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.answer)
  if (message_case() == kAnswer) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::SessionDescription*>(_impl_.message_.answer_);
    _impl_.message_.answer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_answer(
    ::livekit::SessionDescription* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_answer();
    _impl_.message_.answer_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.answer)
}
inline ::livekit::SessionDescription* PROTOBUF_NONNULL SignalResponse::_internal_mutable_answer() {
  if (message_case() != kAnswer) {
    clear_message();
    set_has_answer();
    _impl_.message_.answer_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::SessionDescription>(GetArena()));
  }
  return reinterpret_cast<::livekit::SessionDescription*>(_impl_.message_.answer_);
}
inline ::livekit::SessionDescription* PROTOBUF_NONNULL SignalResponse::mutable_answer()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::SessionDescription* _msg = _internal_mutable_answer();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.answer)
  return _msg;
}

// .livekit.SessionDescription offer = 3;
inline bool SignalResponse::has_offer() const {
  return message_case() == kOffer;
}
inline bool SignalResponse::_internal_has_offer() const {
  return message_case() == kOffer;
}
inline void SignalResponse::set_has_offer() {
  _impl_._oneof_case_[0] = kOffer;
}
inline void SignalResponse::clear_offer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kOffer) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.offer_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.offer_);
    }
    clear_has_message();
  }
}
inline ::livekit::SessionDescription* PROTOBUF_NULLABLE SignalResponse::release_offer() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.offer)
  if (message_case() == kOffer) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::SessionDescription*>(_impl_.message_.offer_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.offer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::SessionDescription& SignalResponse::_internal_offer() const {
  return message_case() == kOffer ? *reinterpret_cast<::livekit::SessionDescription*>(_impl_.message_.offer_) : reinterpret_cast<::livekit::SessionDescription&>(::livekit::_SessionDescription_default_instance_);
}
inline const ::livekit::SessionDescription& SignalResponse::offer() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.offer)
  return _internal_offer();
}
inline ::livekit::SessionDescription* PROTOBUF_NULLABLE SignalResponse::unsafe_arena_release_offer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.offer)
  if (message_case() == kOffer) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::SessionDescription*>(_impl_.message_.offer_);
    _impl_.message_.offer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_offer(
    ::livekit::SessionDescription* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_offer();
    _impl_.message_.offer_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.offer)
}
inline ::livekit::SessionDescription* PROTOBUF_NONNULL SignalResponse::_internal_mutable_offer() {
  if (message_case() != kOffer) {
    clear_message();
    set_has_offer();
    _impl_.message_.offer_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::SessionDescription>(GetArena()));
  }
  return reinterpret_cast<::livekit::SessionDescription*>(_impl_.message_.offer_);
}
inline ::livekit::SessionDescription* PROTOBUF_NONNULL SignalResponse::mutable_offer()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::SessionDescription* _msg = _internal_mutable_offer();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.offer)
  return _msg;
}

// .livekit.TrickleRequest trickle = 4;
inline bool SignalResponse::has_trickle() const {
  return message_case() == kTrickle;
}
inline bool SignalResponse::_internal_has_trickle() const {
  return message_case() == kTrickle;
}
inline void SignalResponse::set_has_trickle() {
  _impl_._oneof_case_[0] = kTrickle;
}
inline void SignalResponse::clear_trickle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kTrickle) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.trickle_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.trickle_);
    }
    clear_has_message();
  }
}
inline ::livekit::TrickleRequest* PROTOBUF_NULLABLE SignalResponse::release_trickle() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.trickle)
  if (message_case() == kTrickle) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::TrickleRequest*>(_impl_.message_.trickle_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.trickle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::TrickleRequest& SignalResponse::_internal_trickle() const {
  return message_case() == kTrickle ? *reinterpret_cast<::livekit::TrickleRequest*>(_impl_.message_.trickle_) : reinterpret_cast<::livekit::TrickleRequest&>(::livekit::_TrickleRequest_default_instance_);
}
inline const ::livekit::TrickleRequest& SignalResponse::trickle() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.trickle)
  return _internal_trickle();
}
inline ::livekit::TrickleRequest* PROTOBUF_NULLABLE SignalResponse::unsafe_arena_release_trickle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.trickle)
  if (message_case() == kTrickle) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::TrickleRequest*>(_impl_.message_.trickle_);
    _impl_.message_.trickle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_trickle(
    ::livekit::TrickleRequest* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_trickle();
    _impl_.message_.trickle_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.trickle)
}
inline ::livekit::TrickleRequest* PROTOBUF_NONNULL SignalResponse::_internal_mutable_trickle() {
  if (message_case() != kTrickle) {
    clear_message();
    set_has_trickle();
    _impl_.message_.trickle_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::TrickleRequest>(GetArena()));
  }
  return reinterpret_cast<::livekit::TrickleRequest*>(_impl_.message_.trickle_);
}
inline ::livekit::TrickleRequest* PROTOBUF_NONNULL SignalResponse::mutable_trickle()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::TrickleRequest* _msg = _internal_mutable_trickle();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.trickle)
  return _msg;
}

// .livekit.ParticipantUpdate update = 5;
inline bool SignalResponse::has_update() const {
  return message_case() == kUpdate;
}
inline bool SignalResponse::_internal_has_update() const {
  return message_case() == kUpdate;
}
inline void SignalResponse::set_has_update() {
  _impl_._oneof_case_[0] = kUpdate;
}
inline void SignalResponse::clear_update() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kUpdate) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.update_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.update_);
    }
    clear_has_message();
  }
}
inline ::livekit::ParticipantUpdate* PROTOBUF_NULLABLE SignalResponse::release_update() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.update)
  if (message_case() == kUpdate) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::ParticipantUpdate*>(_impl_.message_.update_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::ParticipantUpdate& SignalResponse::_internal_update() const {
  return message_case() == kUpdate ? *reinterpret_cast<::livekit::ParticipantUpdate*>(_impl_.message_.update_) : reinterpret_cast<::livekit::ParticipantUpdate&>(::livekit::_ParticipantUpdate_default_instance_);
}
inline const ::livekit::ParticipantUpdate& SignalResponse::update() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.update)
  return _internal_update();
}
inline ::livekit::ParticipantUpdate* PROTOBUF_NULLABLE SignalResponse::unsafe_arena_release_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.update)
  if (message_case() == kUpdate) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::ParticipantUpdate*>(_impl_.message_.update_);
    _impl_.message_.update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_update(
    ::livekit::ParticipantUpdate* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_update();
    _impl_.message_.update_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.update)
}
inline ::livekit::ParticipantUpdate* PROTOBUF_NONNULL SignalResponse::_internal_mutable_update() {
  if (message_case() != kUpdate) {
    clear_message();
    set_has_update();
    _impl_.message_.update_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::ParticipantUpdate>(GetArena()));
  }
  return reinterpret_cast<::livekit::ParticipantUpdate*>(_impl_.message_.update_);
}
inline ::livekit::ParticipantUpdate* PROTOBUF_NONNULL SignalResponse::mutable_update()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::ParticipantUpdate* _msg = _internal_mutable_update();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.update)
  return _msg;
}

// .livekit.TrackPublishedResponse track_published = 6;
inline bool SignalResponse::has_track_published() const {
  return message_case() == kTrackPublished;
}
inline bool SignalResponse::_internal_has_track_published() const {
  return message_case() == kTrackPublished;
}
inline void SignalResponse::set_has_track_published() {
  _impl_._oneof_case_[0] = kTrackPublished;
}
inline void SignalResponse::clear_track_published() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kTrackPublished) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.track_published_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.track_published_);
    }
    clear_has_message();
  }
}
inline ::livekit::TrackPublishedResponse* PROTOBUF_NULLABLE SignalResponse::release_track_published() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.track_published)
  if (message_case() == kTrackPublished) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::TrackPublishedResponse*>(_impl_.message_.track_published_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.track_published_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::TrackPublishedResponse& SignalResponse::_internal_track_published() const {
  return message_case() == kTrackPublished ? *reinterpret_cast<::livekit::TrackPublishedResponse*>(_impl_.message_.track_published_) : reinterpret_cast<::livekit::TrackPublishedResponse&>(::livekit::_TrackPublishedResponse_default_instance_);
}
inline const ::livekit::TrackPublishedResponse& SignalResponse::track_published() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.track_published)
  return _internal_track_published();
}
inline ::livekit::TrackPublishedResponse* PROTOBUF_NULLABLE SignalResponse::unsafe_arena_release_track_published() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.track_published)
  if (message_case() == kTrackPublished) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::TrackPublishedResponse*>(_impl_.message_.track_published_);
    _impl_.message_.track_published_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_track_published(
    ::livekit::TrackPublishedResponse* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_track_published();
    _impl_.message_.track_published_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.track_published)
}
inline ::livekit::TrackPublishedResponse* PROTOBUF_NONNULL SignalResponse::_internal_mutable_track_published() {
  if (message_case() != kTrackPublished) {
    clear_message();
    set_has_track_published();
    _impl_.message_.track_published_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::TrackPublishedResponse>(GetArena()));
  }
  return reinterpret_cast<::livekit::TrackPublishedResponse*>(_impl_.message_.track_published_);
}
inline ::livekit::TrackPublishedResponse* PROTOBUF_NONNULL SignalResponse::mutable_track_published()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::TrackPublishedResponse* _msg = _internal_mutable_track_published();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.track_published)
  return _msg;
}

// .livekit.LeaveRequest leave = 8;
inline bool SignalResponse::has_leave() const {
  return message_case() == kLeave;
}
inline bool SignalResponse::_internal_has_leave() const {
  return message_case() == kLeave;
}
inline void SignalResponse::set_has_leave() {
  _impl_._oneof_case_[0] = kLeave;
}
inline void SignalResponse::clear_leave() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kLeave) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.leave_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.leave_);
    }
    clear_has_message();
  }
}
inline ::livekit::LeaveRequest* PROTOBUF_NULLABLE SignalResponse::release_leave() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.leave)
  if (message_case() == kLeave) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::LeaveRequest*>(_impl_.message_.leave_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.leave_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::LeaveRequest& SignalResponse::_internal_leave() const {
  return message_case() == kLeave ? *reinterpret_cast<::livekit::LeaveRequest*>(_impl_.message_.leave_) : reinterpret_cast<::livekit::LeaveRequest&>(::livekit::_LeaveRequest_default_instance_);
}
inline const ::livekit::LeaveRequest& SignalResponse::leave() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.leave)
  return _internal_leave();
}
inline ::livekit::LeaveRequest* PROTOBUF_NULLABLE SignalResponse::unsafe_arena_release_leave() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.leave)
  if (message_case() == kLeave) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::LeaveRequest*>(_impl_.message_.leave_);
    _impl_.message_.leave_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_leave(
    ::livekit::LeaveRequest* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_leave();
    _impl_.message_.leave_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.leave)
}
inline ::livekit::LeaveRequest* PROTOBUF_NONNULL SignalResponse::_internal_mutable_leave() {
  if (message_case() != kLeave) {
    clear_message();
    set_has_leave();
    _impl_.message_.leave_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::LeaveRequest>(GetArena()));
  }
  return reinterpret_cast<::livekit::LeaveRequest*>(_impl_.message_.leave_);
}
inline ::livekit::LeaveRequest* PROTOBUF_NONNULL SignalResponse::mutable_leave()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::LeaveRequest* _msg = _internal_mutable_leave();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.leave)
  return _msg;
}

// .livekit.MuteTrackRequest mute = 9;
inline bool SignalResponse::has_mute() const {
  return message_case() == kMute;
}
inline bool SignalResponse::_internal_has_mute() const {
  return message_case() == kMute;
}
inline void SignalResponse::set_has_mute() {
  _impl_._oneof_case_[0] = kMute;
}
inline void SignalResponse::clear_mute() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kMute) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.mute_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.mute_);
    }
    clear_has_message();
  }
}
inline ::livekit::MuteTrackRequest* PROTOBUF_NULLABLE SignalResponse::release_mute() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.mute)
  if (message_case() == kMute) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::MuteTrackRequest*>(_impl_.message_.mute_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.mute_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::MuteTrackRequest& SignalResponse::_internal_mute() const {
  return message_case() == kMute ? *reinterpret_cast<::livekit::MuteTrackRequest*>(_impl_.message_.mute_) : reinterpret_cast<::livekit::MuteTrackRequest&>(::livekit::_MuteTrackRequest_default_instance_);
}
inline const ::livekit::MuteTrackRequest& SignalResponse::mute() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.mute)
  return _internal_mute();
}
inline ::livekit::MuteTrackRequest* PROTOBUF_NULLABLE SignalResponse::unsafe_arena_release_mute() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.mute)
  if (message_case() == kMute) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::MuteTrackRequest*>(_impl_.message_.mute_);
    _impl_.message_.mute_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_mute(
    ::livekit::MuteTrackRequest* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_mute();
    _impl_.message_.mute_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.mute)
}
inline ::livekit::MuteTrackRequest* PROTOBUF_NONNULL SignalResponse::_internal_mutable_mute() {
  if (message_case() != kMute) {
    clear_message();
    set_has_mute();
    _impl_.message_.mute_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::MuteTrackRequest>(GetArena()));
  }
  return reinterpret_cast<::livekit::MuteTrackRequest*>(_impl_.message_.mute_);
}
inline ::livekit::MuteTrackRequest* PROTOBUF_NONNULL SignalResponse::mutable_mute()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::MuteTrackRequest* _msg = _internal_mutable_mute();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.mute)
  return _msg;
}

// .livekit.SpeakersChanged speakers_changed = 10;
inline bool SignalResponse::has_speakers_changed() const {
  return message_case() == kSpeakersChanged;
}
inline bool SignalResponse::_internal_has_speakers_changed() const {
  return message_case() == kSpeakersChanged;
}
inline void SignalResponse::set_has_speakers_changed() {
  _impl_._oneof_case_[0] = kSpeakersChanged;
}
inline void SignalResponse::clear_speakers_changed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kSpeakersChanged) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.speakers_changed_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.speakers_changed_);
    }
    clear_has_message();
  }
}
inline ::livekit::SpeakersChanged* PROTOBUF_NULLABLE SignalResponse::release_speakers_changed() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.speakers_changed)
  if (message_case() == kSpeakersChanged) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::SpeakersChanged*>(_impl_.message_.speakers_changed_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.speakers_changed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::SpeakersChanged& SignalResponse::_internal_speakers_changed() const {
  return message_case() == kSpeakersChanged ? *reinterpret_cast<::livekit::SpeakersChanged*>(_impl_.message_.speakers_changed_) : reinterpret_cast<::livekit::SpeakersChanged&>(::livekit::_SpeakersChanged_default_instance_);
}
inline const ::livekit::SpeakersChanged& SignalResponse::speakers_changed() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.speakers_changed)
  return _internal_speakers_changed();
}
inline ::livekit::SpeakersChanged* PROTOBUF_NULLABLE SignalResponse::unsafe_arena_release_speakers_changed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.speakers_changed)
  if (message_case() == kSpeakersChanged) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::SpeakersChanged*>(_impl_.message_.speakers_changed_);
    _impl_.message_.speakers_changed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_speakers_changed(
    ::livekit::SpeakersChanged* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_speakers_changed();
    _impl_.message_.speakers_changed_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.speakers_changed)
}
inline ::livekit::SpeakersChanged* PROTOBUF_NONNULL SignalResponse::_internal_mutable_speakers_changed() {
  if (message_case() != kSpeakersChanged) {
    clear_message();
    set_has_speakers_changed();
    _impl_.message_.speakers_changed_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::SpeakersChanged>(GetArena()));
  }
  return reinterpret_cast<::livekit::SpeakersChanged*>(_impl_.message_.speakers_changed_);
}
inline ::livekit::SpeakersChanged* PROTOBUF_NONNULL SignalResponse::mutable_speakers_changed()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::SpeakersChanged* _msg = _internal_mutable_speakers_changed();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.speakers_changed)
  return _msg;
}

// .livekit.RoomUpdate room_update = 11;
inline bool SignalResponse::has_room_update() const {
  return message_case() == kRoomUpdate;
}
inline bool SignalResponse::_internal_has_room_update() const {
  return message_case() == kRoomUpdate;
}
inline void SignalResponse::set_has_room_update() {
  _impl_._oneof_case_[0] = kRoomUpdate;
}
inline void SignalResponse::clear_room_update() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kRoomUpdate) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.room_update_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.room_update_);
    }
    clear_has_message();
  }
}
inline ::livekit::RoomUpdate* PROTOBUF_NULLABLE SignalResponse::release_room_update() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.room_update)
  if (message_case() == kRoomUpdate) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::RoomUpdate*>(_impl_.message_.room_update_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.room_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::RoomUpdate& SignalResponse::_internal_room_update() const {
  return message_case() == kRoomUpdate ? *reinterpret_cast<::livekit::RoomUpdate*>(_impl_.message_.room_update_) : reinterpret_cast<::livekit::RoomUpdate&>(::livekit::_RoomUpdate_default_instance_);
}
inline const ::livekit::RoomUpdate& SignalResponse::room_update() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.room_update)
  return _internal_room_update();
}
inline ::livekit::RoomUpdate* PROTOBUF_NULLABLE SignalResponse::unsafe_arena_release_room_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.room_update)
  if (message_case() == kRoomUpdate) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::RoomUpdate*>(_impl_.message_.room_update_);
    _impl_.message_.room_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_room_update(
    ::livekit::RoomUpdate* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_room_update();
    _impl_.message_.room_update_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.room_update)
}
inline ::livekit::RoomUpdate* PROTOBUF_NONNULL SignalResponse::_internal_mutable_room_update() {
  if (message_case() != kRoomUpdate) {
    clear_message();
    set_has_room_update();
    _impl_.message_.room_update_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::RoomUpdate>(GetArena()));
  }
  return reinterpret_cast<::livekit::RoomUpdate*>(_impl_.message_.room_update_);
}
inline ::livekit::RoomUpdate* PROTOBUF_NONNULL SignalResponse::mutable_room_update()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::RoomUpdate* _msg = _internal_mutable_room_update();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.room_update)
  return _msg;
}

// .livekit.ConnectionQualityUpdate connection_quality = 12;
inline bool SignalResponse::has_connection_quality() const {
  return message_case() == kConnectionQuality;
}
inline bool SignalResponse::_internal_has_connection_quality() const {
  return message_case() == kConnectionQuality;
}
inline void SignalResponse::set_has_connection_quality() {
  _impl_._oneof_case_[0] = kConnectionQuality;
}
inline void SignalResponse::clear_connection_quality() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kConnectionQuality) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.connection_quality_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.connection_quality_);
    }
    clear_has_message();
  }
}
inline ::livekit::ConnectionQualityUpdate* PROTOBUF_NULLABLE SignalResponse::release_connection_quality() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.connection_quality)
  if (message_case() == kConnectionQuality) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::ConnectionQualityUpdate*>(_impl_.message_.connection_quality_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.connection_quality_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::ConnectionQualityUpdate& SignalResponse::_internal_connection_quality() const {
  return message_case() == kConnectionQuality ? *reinterpret_cast<::livekit::ConnectionQualityUpdate*>(_impl_.message_.connection_quality_) : reinterpret_cast<::livekit::ConnectionQualityUpdate&>(::livekit::_ConnectionQualityUpdate_default_instance_);
}
inline const ::livekit::ConnectionQualityUpdate& SignalResponse::connection_quality() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.connection_quality)
  return _internal_connection_quality();
}
inline ::livekit::ConnectionQualityUpdate* PROTOBUF_NULLABLE SignalResponse::unsafe_arena_release_connection_quality() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.connection_quality)
  if (message_case() == kConnectionQuality) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::ConnectionQualityUpdate*>(_impl_.message_.connection_quality_);
    _impl_.message_.connection_quality_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_connection_quality(
    ::livekit::ConnectionQualityUpdate* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_connection_quality();
    _impl_.message_.connection_quality_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.connection_quality)
}
inline ::livekit::ConnectionQualityUpdate* PROTOBUF_NONNULL SignalResponse::_internal_mutable_connection_quality() {
  if (message_case() != kConnectionQuality) {
    clear_message();
    set_has_connection_quality();
    _impl_.message_.connection_quality_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::ConnectionQualityUpdate>(GetArena()));
  }
  return reinterpret_cast<::livekit::ConnectionQualityUpdate*>(_impl_.message_.connection_quality_);
}
inline ::livekit::ConnectionQualityUpdate* PROTOBUF_NONNULL SignalResponse::mutable_connection_quality()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::ConnectionQualityUpdate* _msg = _internal_mutable_connection_quality();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.connection_quality)
  return _msg;
}

// .livekit.StreamStateUpdate stream_state_update = 13;
inline bool SignalResponse::has_stream_state_update() const {
  return message_case() == kStreamStateUpdate;
}
inline bool SignalResponse::_internal_has_stream_state_update() const {
  return message_case() == kStreamStateUpdate;
}
inline void SignalResponse::set_has_stream_state_update() {
  _impl_._oneof_case_[0] = kStreamStateUpdate;
}
inline void SignalResponse::clear_stream_state_update() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kStreamStateUpdate) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.stream_state_update_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.stream_state_update_);
    }
    clear_has_message();
  }
}
inline ::livekit::StreamStateUpdate* PROTOBUF_NULLABLE SignalResponse::release_stream_state_update() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.stream_state_update)
  if (message_case() == kStreamStateUpdate) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::StreamStateUpdate*>(_impl_.message_.stream_state_update_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.stream_state_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::StreamStateUpdate& SignalResponse::_internal_stream_state_update() const {
  return message_case() == kStreamStateUpdate ? *reinterpret_cast<::livekit::StreamStateUpdate*>(_impl_.message_.stream_state_update_) : reinterpret_cast<::livekit::StreamStateUpdate&>(::livekit::_StreamStateUpdate_default_instance_);
}
inline const ::livekit::StreamStateUpdate& SignalResponse::stream_state_update() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.stream_state_update)
  return _internal_stream_state_update();
}
inline ::livekit::StreamStateUpdate* PROTOBUF_NULLABLE SignalResponse::unsafe_arena_release_stream_state_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.stream_state_update)
  if (message_case() == kStreamStateUpdate) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::StreamStateUpdate*>(_impl_.message_.stream_state_update_);
    _impl_.message_.stream_state_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_stream_state_update(
    ::livekit::StreamStateUpdate* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_stream_state_update();
    _impl_.message_.stream_state_update_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.stream_state_update)
}
inline ::livekit::StreamStateUpdate* PROTOBUF_NONNULL SignalResponse::_internal_mutable_stream_state_update() {
  if (message_case() != kStreamStateUpdate) {
    clear_message();
    set_has_stream_state_update();
    _impl_.message_.stream_state_update_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::StreamStateUpdate>(GetArena()));
  }
  return reinterpret_cast<::livekit::StreamStateUpdate*>(_impl_.message_.stream_state_update_);
}
inline ::livekit::StreamStateUpdate* PROTOBUF_NONNULL SignalResponse::mutable_stream_state_update()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::StreamStateUpdate* _msg = _internal_mutable_stream_state_update();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.stream_state_update)
  return _msg;
}

// .livekit.SubscribedQualityUpdate subscribed_quality_update = 14;
inline bool SignalResponse::has_subscribed_quality_update() const {
  return message_case() == kSubscribedQualityUpdate;
}
inline bool SignalResponse::_internal_has_subscribed_quality_update() const {
  return message_case() == kSubscribedQualityUpdate;
}
inline void SignalResponse::set_has_subscribed_quality_update() {
  _impl_._oneof_case_[0] = kSubscribedQualityUpdate;
}
inline void SignalResponse::clear_subscribed_quality_update() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kSubscribedQualityUpdate) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.subscribed_quality_update_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.subscribed_quality_update_);
    }
    clear_has_message();
  }
}
inline ::livekit::SubscribedQualityUpdate* PROTOBUF_NULLABLE SignalResponse::release_subscribed_quality_update() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.subscribed_quality_update)
  if (message_case() == kSubscribedQualityUpdate) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::SubscribedQualityUpdate*>(_impl_.message_.subscribed_quality_update_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.subscribed_quality_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::SubscribedQualityUpdate& SignalResponse::_internal_subscribed_quality_update() const {
  return message_case() == kSubscribedQualityUpdate ? *reinterpret_cast<::livekit::SubscribedQualityUpdate*>(_impl_.message_.subscribed_quality_update_) : reinterpret_cast<::livekit::SubscribedQualityUpdate&>(::livekit::_SubscribedQualityUpdate_default_instance_);
}
inline const ::livekit::SubscribedQualityUpdate& SignalResponse::subscribed_quality_update() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.subscribed_quality_update)
  return _internal_subscribed_quality_update();
}
inline ::livekit::SubscribedQualityUpdate* PROTOBUF_NULLABLE SignalResponse::unsafe_arena_release_subscribed_quality_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.subscribed_quality_update)
  if (message_case() == kSubscribedQualityUpdate) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::SubscribedQualityUpdate*>(_impl_.message_.subscribed_quality_update_);
    _impl_.message_.subscribed_quality_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_subscribed_quality_update(
    ::livekit::SubscribedQualityUpdate* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_subscribed_quality_update();
    _impl_.message_.subscribed_quality_update_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.subscribed_quality_update)
}
inline ::livekit::SubscribedQualityUpdate* PROTOBUF_NONNULL SignalResponse::_internal_mutable_subscribed_quality_update() {
  if (message_case() != kSubscribedQualityUpdate) {
    clear_message();
    set_has_subscribed_quality_update();
    _impl_.message_.subscribed_quality_update_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::SubscribedQualityUpdate>(GetArena()));
  }
  return reinterpret_cast<::livekit::SubscribedQualityUpdate*>(_impl_.message_.subscribed_quality_update_);
}
inline ::livekit::SubscribedQualityUpdate* PROTOBUF_NONNULL SignalResponse::mutable_subscribed_quality_update()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::SubscribedQualityUpdate* _msg = _internal_mutable_subscribed_quality_update();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.subscribed_quality_update)
  return _msg;
}

// .livekit.SubscriptionPermissionUpdate subscription_permission_update = 15;
inline bool SignalResponse::has_subscription_permission_update() const {
  return message_case() == kSubscriptionPermissionUpdate;
}
inline bool SignalResponse::_internal_has_subscription_permission_update() const {
  return message_case() == kSubscriptionPermissionUpdate;
}
inline void SignalResponse::set_has_subscription_permission_update() {
  _impl_._oneof_case_[0] = kSubscriptionPermissionUpdate;
}
inline void SignalResponse::clear_subscription_permission_update() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kSubscriptionPermissionUpdate) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.subscription_permission_update_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.subscription_permission_update_);
    }
    clear_has_message();
  }
}
inline ::livekit::SubscriptionPermissionUpdate* PROTOBUF_NULLABLE SignalResponse::release_subscription_permission_update() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.subscription_permission_update)
  if (message_case() == kSubscriptionPermissionUpdate) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::SubscriptionPermissionUpdate*>(_impl_.message_.subscription_permission_update_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.subscription_permission_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::SubscriptionPermissionUpdate& SignalResponse::_internal_subscription_permission_update() const {
  return message_case() == kSubscriptionPermissionUpdate ? *reinterpret_cast<::livekit::SubscriptionPermissionUpdate*>(_impl_.message_.subscription_permission_update_) : reinterpret_cast<::livekit::SubscriptionPermissionUpdate&>(::livekit::_SubscriptionPermissionUpdate_default_instance_);
}
inline const ::livekit::SubscriptionPermissionUpdate& SignalResponse::subscription_permission_update() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.subscription_permission_update)
  return _internal_subscription_permission_update();
}
inline ::livekit::SubscriptionPermissionUpdate* PROTOBUF_NULLABLE SignalResponse::unsafe_arena_release_subscription_permission_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.subscription_permission_update)
  if (message_case() == kSubscriptionPermissionUpdate) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::SubscriptionPermissionUpdate*>(_impl_.message_.subscription_permission_update_);
    _impl_.message_.subscription_permission_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_subscription_permission_update(
    ::livekit::SubscriptionPermissionUpdate* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_subscription_permission_update();
    _impl_.message_.subscription_permission_update_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.subscription_permission_update)
}
inline ::livekit::SubscriptionPermissionUpdate* PROTOBUF_NONNULL SignalResponse::_internal_mutable_subscription_permission_update() {
  if (message_case() != kSubscriptionPermissionUpdate) {
    clear_message();
    set_has_subscription_permission_update();
    _impl_.message_.subscription_permission_update_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::SubscriptionPermissionUpdate>(GetArena()));
  }
  return reinterpret_cast<::livekit::SubscriptionPermissionUpdate*>(_impl_.message_.subscription_permission_update_);
}
inline ::livekit::SubscriptionPermissionUpdate* PROTOBUF_NONNULL SignalResponse::mutable_subscription_permission_update()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::SubscriptionPermissionUpdate* _msg = _internal_mutable_subscription_permission_update();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.subscription_permission_update)
  return _msg;
}

// string refresh_token = 16;
inline bool SignalResponse::has_refresh_token() const {
  return message_case() == kRefreshToken;
}
inline void SignalResponse::set_has_refresh_token() {
  _impl_._oneof_case_[0] = kRefreshToken;
}
inline void SignalResponse::clear_refresh_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kRefreshToken) {
    _impl_.message_.refresh_token_.Destroy();
    clear_has_message();
  }
}
inline const std::string& SignalResponse::refresh_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.refresh_token)
  return _internal_refresh_token();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SignalResponse::set_refresh_token(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() != kRefreshToken) {
    clear_message();

    set_has_refresh_token();
    _impl_.message_.refresh_token_.InitDefault();
  }
  _impl_.message_.refresh_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.SignalResponse.refresh_token)
}
inline std::string* PROTOBUF_NONNULL SignalResponse::mutable_refresh_token()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_refresh_token();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.refresh_token)
  return _s;
}
inline const std::string& SignalResponse::_internal_refresh_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (message_case() != kRefreshToken) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.message_.refresh_token_.Get();
}
inline void SignalResponse::_internal_set_refresh_token(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() != kRefreshToken) {
    clear_message();

    set_has_refresh_token();
    _impl_.message_.refresh_token_.InitDefault();
  }
  _impl_.message_.refresh_token_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL SignalResponse::_internal_mutable_refresh_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() != kRefreshToken) {
    clear_message();

    set_has_refresh_token();
    _impl_.message_.refresh_token_.InitDefault();
  }
  return _impl_.message_.refresh_token_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE SignalResponse::release_refresh_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.refresh_token)
  if (message_case() != kRefreshToken) {
    return nullptr;
  }
  clear_has_message();
  return _impl_.message_.refresh_token_.Release();
}
inline void SignalResponse::set_allocated_refresh_token(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_message()) {
    clear_message();
  }
  if (value != nullptr) {
    set_has_refresh_token();
    _impl_.message_.refresh_token_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.SignalResponse.refresh_token)
}

// .livekit.TrackUnpublishedResponse track_unpublished = 17;
inline bool SignalResponse::has_track_unpublished() const {
  return message_case() == kTrackUnpublished;
}
inline bool SignalResponse::_internal_has_track_unpublished() const {
  return message_case() == kTrackUnpublished;
}
inline void SignalResponse::set_has_track_unpublished() {
  _impl_._oneof_case_[0] = kTrackUnpublished;
}
inline void SignalResponse::clear_track_unpublished() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kTrackUnpublished) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.track_unpublished_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.track_unpublished_);
    }
    clear_has_message();
  }
}
inline ::livekit::TrackUnpublishedResponse* PROTOBUF_NULLABLE SignalResponse::release_track_unpublished() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.track_unpublished)
  if (message_case() == kTrackUnpublished) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::TrackUnpublishedResponse*>(_impl_.message_.track_unpublished_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.track_unpublished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::TrackUnpublishedResponse& SignalResponse::_internal_track_unpublished() const {
  return message_case() == kTrackUnpublished ? *reinterpret_cast<::livekit::TrackUnpublishedResponse*>(_impl_.message_.track_unpublished_) : reinterpret_cast<::livekit::TrackUnpublishedResponse&>(::livekit::_TrackUnpublishedResponse_default_instance_);
}
inline const ::livekit::TrackUnpublishedResponse& SignalResponse::track_unpublished() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.track_unpublished)
  return _internal_track_unpublished();
}
inline ::livekit::TrackUnpublishedResponse* PROTOBUF_NULLABLE SignalResponse::unsafe_arena_release_track_unpublished() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.track_unpublished)
  if (message_case() == kTrackUnpublished) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::TrackUnpublishedResponse*>(_impl_.message_.track_unpublished_);
    _impl_.message_.track_unpublished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_track_unpublished(
    ::livekit::TrackUnpublishedResponse* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_track_unpublished();
    _impl_.message_.track_unpublished_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.track_unpublished)
}
inline ::livekit::TrackUnpublishedResponse* PROTOBUF_NONNULL SignalResponse::_internal_mutable_track_unpublished() {
  if (message_case() != kTrackUnpublished) {
    clear_message();
    set_has_track_unpublished();
    _impl_.message_.track_unpublished_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::TrackUnpublishedResponse>(GetArena()));
  }
  return reinterpret_cast<::livekit::TrackUnpublishedResponse*>(_impl_.message_.track_unpublished_);
}
inline ::livekit::TrackUnpublishedResponse* PROTOBUF_NONNULL SignalResponse::mutable_track_unpublished()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::TrackUnpublishedResponse* _msg = _internal_mutable_track_unpublished();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.track_unpublished)
  return _msg;
}

// int64 pong = 18;
inline bool SignalResponse::has_pong() const {
  return message_case() == kPong;
}
inline void SignalResponse::set_has_pong() {
  _impl_._oneof_case_[0] = kPong;
}
inline void SignalResponse::clear_pong() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kPong) {
    _impl_.message_.pong_ = ::int64_t{0};
    clear_has_message();
  }
}
inline ::int64_t SignalResponse::pong() const {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.pong)
  return _internal_pong();
}
inline void SignalResponse::set_pong(::int64_t value) {
  if (message_case() != kPong) {
    clear_message();
    set_has_pong();
  }
  _impl_.message_.pong_ = value;
  // @@protoc_insertion_point(field_set:livekit.SignalResponse.pong)
}
inline ::int64_t SignalResponse::_internal_pong() const {
  if (message_case() == kPong) {
    return _impl_.message_.pong_;
  }
  return ::int64_t{0};
}

// .livekit.ReconnectResponse reconnect = 19;
inline bool SignalResponse::has_reconnect() const {
  return message_case() == kReconnect;
}
inline bool SignalResponse::_internal_has_reconnect() const {
  return message_case() == kReconnect;
}
inline void SignalResponse::set_has_reconnect() {
  _impl_._oneof_case_[0] = kReconnect;
}
inline void SignalResponse::clear_reconnect() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kReconnect) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.reconnect_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.reconnect_);
    }
    clear_has_message();
  }
}
inline ::livekit::ReconnectResponse* PROTOBUF_NULLABLE SignalResponse::release_reconnect() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.reconnect)
  if (message_case() == kReconnect) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::ReconnectResponse*>(_impl_.message_.reconnect_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.reconnect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::ReconnectResponse& SignalResponse::_internal_reconnect() const {
  return message_case() == kReconnect ? *reinterpret_cast<::livekit::ReconnectResponse*>(_impl_.message_.reconnect_) : reinterpret_cast<::livekit::ReconnectResponse&>(::livekit::_ReconnectResponse_default_instance_);
}
inline const ::livekit::ReconnectResponse& SignalResponse::reconnect() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.reconnect)
  return _internal_reconnect();
}
inline ::livekit::ReconnectResponse* PROTOBUF_NULLABLE SignalResponse::unsafe_arena_release_reconnect() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.reconnect)
  if (message_case() == kReconnect) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::ReconnectResponse*>(_impl_.message_.reconnect_);
    _impl_.message_.reconnect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_reconnect(
    ::livekit::ReconnectResponse* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_reconnect();
    _impl_.message_.reconnect_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.reconnect)
}
inline ::livekit::ReconnectResponse* PROTOBUF_NONNULL SignalResponse::_internal_mutable_reconnect() {
  if (message_case() != kReconnect) {
    clear_message();
    set_has_reconnect();
    _impl_.message_.reconnect_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::ReconnectResponse>(GetArena()));
  }
  return reinterpret_cast<::livekit::ReconnectResponse*>(_impl_.message_.reconnect_);
}
inline ::livekit::ReconnectResponse* PROTOBUF_NONNULL SignalResponse::mutable_reconnect()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::ReconnectResponse* _msg = _internal_mutable_reconnect();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.reconnect)
  return _msg;
}

// .livekit.Pong pong_resp = 20;
inline bool SignalResponse::has_pong_resp() const {
  return message_case() == kPongResp;
}
inline bool SignalResponse::_internal_has_pong_resp() const {
  return message_case() == kPongResp;
}
inline void SignalResponse::set_has_pong_resp() {
  _impl_._oneof_case_[0] = kPongResp;
}
inline void SignalResponse::clear_pong_resp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kPongResp) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.pong_resp_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.pong_resp_);
    }
    clear_has_message();
  }
}
inline ::livekit::Pong* PROTOBUF_NULLABLE SignalResponse::release_pong_resp() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.pong_resp)
  if (message_case() == kPongResp) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::Pong*>(_impl_.message_.pong_resp_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.pong_resp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::Pong& SignalResponse::_internal_pong_resp() const {
  return message_case() == kPongResp ? *reinterpret_cast<::livekit::Pong*>(_impl_.message_.pong_resp_) : reinterpret_cast<::livekit::Pong&>(::livekit::_Pong_default_instance_);
}
inline const ::livekit::Pong& SignalResponse::pong_resp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.pong_resp)
  return _internal_pong_resp();
}
inline ::livekit::Pong* PROTOBUF_NULLABLE SignalResponse::unsafe_arena_release_pong_resp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.pong_resp)
  if (message_case() == kPongResp) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::Pong*>(_impl_.message_.pong_resp_);
    _impl_.message_.pong_resp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_pong_resp(
    ::livekit::Pong* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_pong_resp();
    _impl_.message_.pong_resp_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.pong_resp)
}
inline ::livekit::Pong* PROTOBUF_NONNULL SignalResponse::_internal_mutable_pong_resp() {
  if (message_case() != kPongResp) {
    clear_message();
    set_has_pong_resp();
    _impl_.message_.pong_resp_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::Pong>(GetArena()));
  }
  return reinterpret_cast<::livekit::Pong*>(_impl_.message_.pong_resp_);
}
inline ::livekit::Pong* PROTOBUF_NONNULL SignalResponse::mutable_pong_resp()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::Pong* _msg = _internal_mutable_pong_resp();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.pong_resp)
  return _msg;
}

// .livekit.SubscriptionResponse subscription_response = 21;
inline bool SignalResponse::has_subscription_response() const {
  return message_case() == kSubscriptionResponse;
}
inline bool SignalResponse::_internal_has_subscription_response() const {
  return message_case() == kSubscriptionResponse;
}
inline void SignalResponse::set_has_subscription_response() {
  _impl_._oneof_case_[0] = kSubscriptionResponse;
}
inline void SignalResponse::clear_subscription_response() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kSubscriptionResponse) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.subscription_response_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.subscription_response_);
    }
    clear_has_message();
  }
}
inline ::livekit::SubscriptionResponse* PROTOBUF_NULLABLE SignalResponse::release_subscription_response() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.subscription_response)
  if (message_case() == kSubscriptionResponse) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::SubscriptionResponse*>(_impl_.message_.subscription_response_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.subscription_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::SubscriptionResponse& SignalResponse::_internal_subscription_response() const {
  return message_case() == kSubscriptionResponse ? *reinterpret_cast<::livekit::SubscriptionResponse*>(_impl_.message_.subscription_response_) : reinterpret_cast<::livekit::SubscriptionResponse&>(::livekit::_SubscriptionResponse_default_instance_);
}
inline const ::livekit::SubscriptionResponse& SignalResponse::subscription_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.subscription_response)
  return _internal_subscription_response();
}
inline ::livekit::SubscriptionResponse* PROTOBUF_NULLABLE SignalResponse::unsafe_arena_release_subscription_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.subscription_response)
  if (message_case() == kSubscriptionResponse) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::SubscriptionResponse*>(_impl_.message_.subscription_response_);
    _impl_.message_.subscription_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_subscription_response(
    ::livekit::SubscriptionResponse* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_subscription_response();
    _impl_.message_.subscription_response_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.subscription_response)
}
inline ::livekit::SubscriptionResponse* PROTOBUF_NONNULL SignalResponse::_internal_mutable_subscription_response() {
  if (message_case() != kSubscriptionResponse) {
    clear_message();
    set_has_subscription_response();
    _impl_.message_.subscription_response_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::SubscriptionResponse>(GetArena()));
  }
  return reinterpret_cast<::livekit::SubscriptionResponse*>(_impl_.message_.subscription_response_);
}
inline ::livekit::SubscriptionResponse* PROTOBUF_NONNULL SignalResponse::mutable_subscription_response()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::SubscriptionResponse* _msg = _internal_mutable_subscription_response();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.subscription_response)
  return _msg;
}

// .livekit.RequestResponse request_response = 22;
inline bool SignalResponse::has_request_response() const {
  return message_case() == kRequestResponse;
}
inline bool SignalResponse::_internal_has_request_response() const {
  return message_case() == kRequestResponse;
}
inline void SignalResponse::set_has_request_response() {
  _impl_._oneof_case_[0] = kRequestResponse;
}
inline void SignalResponse::clear_request_response() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kRequestResponse) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.request_response_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.request_response_);
    }
    clear_has_message();
  }
}
inline ::livekit::RequestResponse* PROTOBUF_NULLABLE SignalResponse::release_request_response() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.request_response)
  if (message_case() == kRequestResponse) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::RequestResponse*>(_impl_.message_.request_response_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.request_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::RequestResponse& SignalResponse::_internal_request_response() const {
  return message_case() == kRequestResponse ? *reinterpret_cast<::livekit::RequestResponse*>(_impl_.message_.request_response_) : reinterpret_cast<::livekit::RequestResponse&>(::livekit::_RequestResponse_default_instance_);
}
inline const ::livekit::RequestResponse& SignalResponse::request_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.request_response)
  return _internal_request_response();
}
inline ::livekit::RequestResponse* PROTOBUF_NULLABLE SignalResponse::unsafe_arena_release_request_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.request_response)
  if (message_case() == kRequestResponse) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::RequestResponse*>(_impl_.message_.request_response_);
    _impl_.message_.request_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_request_response(
    ::livekit::RequestResponse* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_request_response();
    _impl_.message_.request_response_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.request_response)
}
inline ::livekit::RequestResponse* PROTOBUF_NONNULL SignalResponse::_internal_mutable_request_response() {
  if (message_case() != kRequestResponse) {
    clear_message();
    set_has_request_response();
    _impl_.message_.request_response_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::RequestResponse>(GetArena()));
  }
  return reinterpret_cast<::livekit::RequestResponse*>(_impl_.message_.request_response_);
}
inline ::livekit::RequestResponse* PROTOBUF_NONNULL SignalResponse::mutable_request_response()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::RequestResponse* _msg = _internal_mutable_request_response();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.request_response)
  return _msg;
}

// .livekit.TrackSubscribed track_subscribed = 23;
inline bool SignalResponse::has_track_subscribed() const {
  return message_case() == kTrackSubscribed;
}
inline bool SignalResponse::_internal_has_track_subscribed() const {
  return message_case() == kTrackSubscribed;
}
inline void SignalResponse::set_has_track_subscribed() {
  _impl_._oneof_case_[0] = kTrackSubscribed;
}
inline void SignalResponse::clear_track_subscribed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kTrackSubscribed) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.track_subscribed_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.track_subscribed_);
    }
    clear_has_message();
  }
}
inline ::livekit::TrackSubscribed* PROTOBUF_NULLABLE SignalResponse::release_track_subscribed() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.track_subscribed)
  if (message_case() == kTrackSubscribed) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::TrackSubscribed*>(_impl_.message_.track_subscribed_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.track_subscribed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::TrackSubscribed& SignalResponse::_internal_track_subscribed() const {
  return message_case() == kTrackSubscribed ? *reinterpret_cast<::livekit::TrackSubscribed*>(_impl_.message_.track_subscribed_) : reinterpret_cast<::livekit::TrackSubscribed&>(::livekit::_TrackSubscribed_default_instance_);
}
inline const ::livekit::TrackSubscribed& SignalResponse::track_subscribed() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.track_subscribed)
  return _internal_track_subscribed();
}
inline ::livekit::TrackSubscribed* PROTOBUF_NULLABLE SignalResponse::unsafe_arena_release_track_subscribed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.track_subscribed)
  if (message_case() == kTrackSubscribed) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::TrackSubscribed*>(_impl_.message_.track_subscribed_);
    _impl_.message_.track_subscribed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_track_subscribed(
    ::livekit::TrackSubscribed* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_track_subscribed();
    _impl_.message_.track_subscribed_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.track_subscribed)
}
inline ::livekit::TrackSubscribed* PROTOBUF_NONNULL SignalResponse::_internal_mutable_track_subscribed() {
  if (message_case() != kTrackSubscribed) {
    clear_message();
    set_has_track_subscribed();
    _impl_.message_.track_subscribed_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::TrackSubscribed>(GetArena()));
  }
  return reinterpret_cast<::livekit::TrackSubscribed*>(_impl_.message_.track_subscribed_);
}
inline ::livekit::TrackSubscribed* PROTOBUF_NONNULL SignalResponse::mutable_track_subscribed()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::TrackSubscribed* _msg = _internal_mutable_track_subscribed();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.track_subscribed)
  return _msg;
}

inline bool SignalResponse::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void SignalResponse::clear_has_message() {
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}
inline SignalResponse::MessageCase SignalResponse::message_case() const {
  return SignalResponse::MessageCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SimulcastCodec

// string codec = 1;
inline void SimulcastCodec::clear_codec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.codec_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SimulcastCodec::codec() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SimulcastCodec.codec)
  return _internal_codec();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SimulcastCodec::set_codec(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.codec_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.SimulcastCodec.codec)
}
inline std::string* PROTOBUF_NONNULL SimulcastCodec::mutable_codec()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_codec();
  // @@protoc_insertion_point(field_mutable:livekit.SimulcastCodec.codec)
  return _s;
}
inline const std::string& SimulcastCodec::_internal_codec() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.codec_.Get();
}
inline void SimulcastCodec::_internal_set_codec(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.codec_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL SimulcastCodec::_internal_mutable_codec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.codec_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE SimulcastCodec::release_codec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.SimulcastCodec.codec)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.codec_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.codec_.Set("", GetArena());
  }
  return released;
}
inline void SimulcastCodec::set_allocated_codec(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.codec_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.codec_.IsDefault()) {
    _impl_.codec_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.SimulcastCodec.codec)
}

// string cid = 2;
inline void SimulcastCodec::clear_cid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SimulcastCodec::cid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SimulcastCodec.cid)
  return _internal_cid();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SimulcastCodec::set_cid(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.cid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.SimulcastCodec.cid)
}
inline std::string* PROTOBUF_NONNULL SimulcastCodec::mutable_cid()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:livekit.SimulcastCodec.cid)
  return _s;
}
inline const std::string& SimulcastCodec::_internal_cid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cid_.Get();
}
inline void SimulcastCodec::_internal_set_cid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.cid_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL SimulcastCodec::_internal_mutable_cid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.cid_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE SimulcastCodec::release_cid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.SimulcastCodec.cid)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.cid_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.cid_.Set("", GetArena());
  }
  return released;
}
inline void SimulcastCodec::set_allocated_cid(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.cid_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.cid_.IsDefault()) {
    _impl_.cid_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.SimulcastCodec.cid)
}

// -------------------------------------------------------------------

// AddTrackRequest

// string cid = 1;
inline void AddTrackRequest::clear_cid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AddTrackRequest::cid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.AddTrackRequest.cid)
  return _internal_cid();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AddTrackRequest::set_cid(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.cid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.AddTrackRequest.cid)
}
inline std::string* PROTOBUF_NONNULL AddTrackRequest::mutable_cid()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:livekit.AddTrackRequest.cid)
  return _s;
}
inline const std::string& AddTrackRequest::_internal_cid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cid_.Get();
}
inline void AddTrackRequest::_internal_set_cid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.cid_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL AddTrackRequest::_internal_mutable_cid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.cid_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE AddTrackRequest::release_cid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.AddTrackRequest.cid)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.cid_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.cid_.Set("", GetArena());
  }
  return released;
}
inline void AddTrackRequest::set_allocated_cid(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.cid_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.cid_.IsDefault()) {
    _impl_.cid_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.AddTrackRequest.cid)
}

// string name = 2;
inline void AddTrackRequest::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AddTrackRequest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.AddTrackRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AddTrackRequest::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.AddTrackRequest.name)
}
inline std::string* PROTOBUF_NONNULL AddTrackRequest::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:livekit.AddTrackRequest.name)
  return _s;
}
inline const std::string& AddTrackRequest::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void AddTrackRequest::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL AddTrackRequest::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE AddTrackRequest::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.AddTrackRequest.name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void AddTrackRequest::set_allocated_name(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.AddTrackRequest.name)
}

// .livekit.TrackType type = 3;
inline void AddTrackRequest::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::livekit::TrackType AddTrackRequest::type() const {
  // @@protoc_insertion_point(field_get:livekit.AddTrackRequest.type)
  return _internal_type();
}
inline void AddTrackRequest::set_type(::livekit::TrackType value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:livekit.AddTrackRequest.type)
}
inline ::livekit::TrackType AddTrackRequest::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::livekit::TrackType>(_impl_.type_);
}
inline void AddTrackRequest::_internal_set_type(::livekit::TrackType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// uint32 width = 4;
inline void AddTrackRequest::clear_width() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint32_t AddTrackRequest::width() const {
  // @@protoc_insertion_point(field_get:livekit.AddTrackRequest.width)
  return _internal_width();
}
inline void AddTrackRequest::set_width(::uint32_t value) {
  _internal_set_width(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:livekit.AddTrackRequest.width)
}
inline ::uint32_t AddTrackRequest::_internal_width() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.width_;
}
inline void AddTrackRequest::_internal_set_width(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_ = value;
}

// uint32 height = 5;
inline void AddTrackRequest::clear_height() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint32_t AddTrackRequest::height() const {
  // @@protoc_insertion_point(field_get:livekit.AddTrackRequest.height)
  return _internal_height();
}
inline void AddTrackRequest::set_height(::uint32_t value) {
  _internal_set_height(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:livekit.AddTrackRequest.height)
}
inline ::uint32_t AddTrackRequest::_internal_height() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.height_;
}
inline void AddTrackRequest::_internal_set_height(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = value;
}

// bool muted = 6;
inline void AddTrackRequest::clear_muted() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.muted_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool AddTrackRequest::muted() const {
  // @@protoc_insertion_point(field_get:livekit.AddTrackRequest.muted)
  return _internal_muted();
}
inline void AddTrackRequest::set_muted(bool value) {
  _internal_set_muted(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:livekit.AddTrackRequest.muted)
}
inline bool AddTrackRequest::_internal_muted() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.muted_;
}
inline void AddTrackRequest::_internal_set_muted(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.muted_ = value;
}

// bool disable_dtx = 7;
inline void AddTrackRequest::clear_disable_dtx() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.disable_dtx_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool AddTrackRequest::disable_dtx() const {
  // @@protoc_insertion_point(field_get:livekit.AddTrackRequest.disable_dtx)
  return _internal_disable_dtx();
}
inline void AddTrackRequest::set_disable_dtx(bool value) {
  _internal_set_disable_dtx(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:livekit.AddTrackRequest.disable_dtx)
}
inline bool AddTrackRequest::_internal_disable_dtx() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.disable_dtx_;
}
inline void AddTrackRequest::_internal_set_disable_dtx(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.disable_dtx_ = value;
}

// .livekit.TrackSource source = 8;
inline void AddTrackRequest::clear_source() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::livekit::TrackSource AddTrackRequest::source() const {
  // @@protoc_insertion_point(field_get:livekit.AddTrackRequest.source)
  return _internal_source();
}
inline void AddTrackRequest::set_source(::livekit::TrackSource value) {
  _internal_set_source(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:livekit.AddTrackRequest.source)
}
inline ::livekit::TrackSource AddTrackRequest::_internal_source() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::livekit::TrackSource>(_impl_.source_);
}
inline void AddTrackRequest::_internal_set_source(::livekit::TrackSource value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_ = value;
}

// repeated .livekit.VideoLayer layers = 9;
inline int AddTrackRequest::_internal_layers_size() const {
  return _internal_layers().size();
}
inline int AddTrackRequest::layers_size() const {
  return _internal_layers_size();
}
inline ::livekit::VideoLayer* PROTOBUF_NONNULL AddTrackRequest::mutable_layers(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.AddTrackRequest.layers)
  return _internal_mutable_layers()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::VideoLayer>* PROTOBUF_NONNULL AddTrackRequest::mutable_layers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.AddTrackRequest.layers)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_layers();
}
inline const ::livekit::VideoLayer& AddTrackRequest::layers(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.AddTrackRequest.layers)
  return _internal_layers().Get(index);
}
inline ::livekit::VideoLayer* PROTOBUF_NONNULL AddTrackRequest::add_layers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::VideoLayer* _add = _internal_mutable_layers()->Add();
  // @@protoc_insertion_point(field_add:livekit.AddTrackRequest.layers)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::VideoLayer>& AddTrackRequest::layers() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.AddTrackRequest.layers)
  return _internal_layers();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::VideoLayer>&
AddTrackRequest::_internal_layers() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.layers_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::VideoLayer>* PROTOBUF_NONNULL
AddTrackRequest::_internal_mutable_layers() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.layers_;
}

// repeated .livekit.SimulcastCodec simulcast_codecs = 10;
inline int AddTrackRequest::_internal_simulcast_codecs_size() const {
  return _internal_simulcast_codecs().size();
}
inline int AddTrackRequest::simulcast_codecs_size() const {
  return _internal_simulcast_codecs_size();
}
inline void AddTrackRequest::clear_simulcast_codecs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.simulcast_codecs_.Clear();
}
inline ::livekit::SimulcastCodec* PROTOBUF_NONNULL AddTrackRequest::mutable_simulcast_codecs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.AddTrackRequest.simulcast_codecs)
  return _internal_mutable_simulcast_codecs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::SimulcastCodec>* PROTOBUF_NONNULL AddTrackRequest::mutable_simulcast_codecs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.AddTrackRequest.simulcast_codecs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_simulcast_codecs();
}
inline const ::livekit::SimulcastCodec& AddTrackRequest::simulcast_codecs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.AddTrackRequest.simulcast_codecs)
  return _internal_simulcast_codecs().Get(index);
}
inline ::livekit::SimulcastCodec* PROTOBUF_NONNULL AddTrackRequest::add_simulcast_codecs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::SimulcastCodec* _add = _internal_mutable_simulcast_codecs()->Add();
  // @@protoc_insertion_point(field_add:livekit.AddTrackRequest.simulcast_codecs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::SimulcastCodec>& AddTrackRequest::simulcast_codecs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.AddTrackRequest.simulcast_codecs)
  return _internal_simulcast_codecs();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::SimulcastCodec>&
AddTrackRequest::_internal_simulcast_codecs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.simulcast_codecs_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::SimulcastCodec>* PROTOBUF_NONNULL
AddTrackRequest::_internal_mutable_simulcast_codecs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.simulcast_codecs_;
}

// string sid = 11;
inline void AddTrackRequest::clear_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AddTrackRequest::sid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.AddTrackRequest.sid)
  return _internal_sid();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AddTrackRequest::set_sid(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.sid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.AddTrackRequest.sid)
}
inline std::string* PROTOBUF_NONNULL AddTrackRequest::mutable_sid()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sid();
  // @@protoc_insertion_point(field_mutable:livekit.AddTrackRequest.sid)
  return _s;
}
inline const std::string& AddTrackRequest::_internal_sid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sid_.Get();
}
inline void AddTrackRequest::_internal_set_sid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.sid_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL AddTrackRequest::_internal_mutable_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.sid_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE AddTrackRequest::release_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.AddTrackRequest.sid)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.sid_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.sid_.Set("", GetArena());
  }
  return released;
}
inline void AddTrackRequest::set_allocated_sid(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.sid_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.sid_.IsDefault()) {
    _impl_.sid_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.AddTrackRequest.sid)
}

// bool stereo = 12;
inline void AddTrackRequest::clear_stereo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stereo_ = false;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool AddTrackRequest::stereo() const {
  // @@protoc_insertion_point(field_get:livekit.AddTrackRequest.stereo)
  return _internal_stereo();
}
inline void AddTrackRequest::set_stereo(bool value) {
  _internal_set_stereo(value);
  _impl_._has_bits_[0] |= 0x00000400u;
  // @@protoc_insertion_point(field_set:livekit.AddTrackRequest.stereo)
}
inline bool AddTrackRequest::_internal_stereo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stereo_;
}
inline void AddTrackRequest::_internal_set_stereo(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stereo_ = value;
}

// bool disable_red = 13;
inline void AddTrackRequest::clear_disable_red() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.disable_red_ = false;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool AddTrackRequest::disable_red() const {
  // @@protoc_insertion_point(field_get:livekit.AddTrackRequest.disable_red)
  return _internal_disable_red();
}
inline void AddTrackRequest::set_disable_red(bool value) {
  _internal_set_disable_red(value);
  _impl_._has_bits_[0] |= 0x00000800u;
  // @@protoc_insertion_point(field_set:livekit.AddTrackRequest.disable_red)
}
inline bool AddTrackRequest::_internal_disable_red() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.disable_red_;
}
inline void AddTrackRequest::_internal_set_disable_red(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.disable_red_ = value;
}

// .livekit.Encryption.Type encryption = 14;
inline void AddTrackRequest::clear_encryption() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encryption_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::livekit::Encryption_Type AddTrackRequest::encryption() const {
  // @@protoc_insertion_point(field_get:livekit.AddTrackRequest.encryption)
  return _internal_encryption();
}
inline void AddTrackRequest::set_encryption(::livekit::Encryption_Type value) {
  _internal_set_encryption(value);
  _impl_._has_bits_[0] |= 0x00001000u;
  // @@protoc_insertion_point(field_set:livekit.AddTrackRequest.encryption)
}
inline ::livekit::Encryption_Type AddTrackRequest::_internal_encryption() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::livekit::Encryption_Type>(_impl_.encryption_);
}
inline void AddTrackRequest::_internal_set_encryption(::livekit::Encryption_Type value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encryption_ = value;
}

// string stream = 15;
inline void AddTrackRequest::clear_stream() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stream_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& AddTrackRequest::stream() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.AddTrackRequest.stream)
  return _internal_stream();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AddTrackRequest::set_stream(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.stream_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.AddTrackRequest.stream)
}
inline std::string* PROTOBUF_NONNULL AddTrackRequest::mutable_stream()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:livekit.AddTrackRequest.stream)
  return _s;
}
inline const std::string& AddTrackRequest::_internal_stream() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stream_.Get();
}
inline void AddTrackRequest::_internal_set_stream(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.stream_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL AddTrackRequest::_internal_mutable_stream() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.stream_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE AddTrackRequest::release_stream() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.AddTrackRequest.stream)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.stream_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.stream_.Set("", GetArena());
  }
  return released;
}
inline void AddTrackRequest::set_allocated_stream(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.stream_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.stream_.IsDefault()) {
    _impl_.stream_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.AddTrackRequest.stream)
}

// .livekit.BackupCodecPolicy backup_codec_policy = 16;
inline void AddTrackRequest::clear_backup_codec_policy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.backup_codec_policy_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline ::livekit::BackupCodecPolicy AddTrackRequest::backup_codec_policy() const {
  // @@protoc_insertion_point(field_get:livekit.AddTrackRequest.backup_codec_policy)
  return _internal_backup_codec_policy();
}
inline void AddTrackRequest::set_backup_codec_policy(::livekit::BackupCodecPolicy value) {
  _internal_set_backup_codec_policy(value);
  _impl_._has_bits_[0] |= 0x00002000u;
  // @@protoc_insertion_point(field_set:livekit.AddTrackRequest.backup_codec_policy)
}
inline ::livekit::BackupCodecPolicy AddTrackRequest::_internal_backup_codec_policy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::livekit::BackupCodecPolicy>(_impl_.backup_codec_policy_);
}
inline void AddTrackRequest::_internal_set_backup_codec_policy(::livekit::BackupCodecPolicy value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.backup_codec_policy_ = value;
}

// -------------------------------------------------------------------

// TrickleRequest

// string candidateInit = 1;
inline void TrickleRequest::clear_candidateinit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.candidateinit_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TrickleRequest::candidateinit() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.TrickleRequest.candidateInit)
  return _internal_candidateinit();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void TrickleRequest::set_candidateinit(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.candidateinit_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.TrickleRequest.candidateInit)
}
inline std::string* PROTOBUF_NONNULL TrickleRequest::mutable_candidateinit()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_candidateinit();
  // @@protoc_insertion_point(field_mutable:livekit.TrickleRequest.candidateInit)
  return _s;
}
inline const std::string& TrickleRequest::_internal_candidateinit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.candidateinit_.Get();
}
inline void TrickleRequest::_internal_set_candidateinit(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.candidateinit_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL TrickleRequest::_internal_mutable_candidateinit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.candidateinit_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE TrickleRequest::release_candidateinit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.TrickleRequest.candidateInit)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.candidateinit_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.candidateinit_.Set("", GetArena());
  }
  return released;
}
inline void TrickleRequest::set_allocated_candidateinit(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.candidateinit_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.candidateinit_.IsDefault()) {
    _impl_.candidateinit_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.TrickleRequest.candidateInit)
}

// .livekit.SignalTarget target = 2;
inline void TrickleRequest::clear_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::livekit::SignalTarget TrickleRequest::target() const {
  // @@protoc_insertion_point(field_get:livekit.TrickleRequest.target)
  return _internal_target();
}
inline void TrickleRequest::set_target(::livekit::SignalTarget value) {
  _internal_set_target(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:livekit.TrickleRequest.target)
}
inline ::livekit::SignalTarget TrickleRequest::_internal_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::livekit::SignalTarget>(_impl_.target_);
}
inline void TrickleRequest::_internal_set_target(::livekit::SignalTarget value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_ = value;
}

// bool final = 3;
inline void TrickleRequest::clear_final() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.final_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool TrickleRequest::final() const {
  // @@protoc_insertion_point(field_get:livekit.TrickleRequest.final)
  return _internal_final();
}
inline void TrickleRequest::set_final(bool value) {
  _internal_set_final(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:livekit.TrickleRequest.final)
}
inline bool TrickleRequest::_internal_final() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.final_;
}
inline void TrickleRequest::_internal_set_final(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.final_ = value;
}

// -------------------------------------------------------------------

// MuteTrackRequest

// string sid = 1;
inline void MuteTrackRequest::clear_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MuteTrackRequest::sid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.MuteTrackRequest.sid)
  return _internal_sid();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void MuteTrackRequest::set_sid(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.MuteTrackRequest.sid)
}
inline std::string* PROTOBUF_NONNULL MuteTrackRequest::mutable_sid()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sid();
  // @@protoc_insertion_point(field_mutable:livekit.MuteTrackRequest.sid)
  return _s;
}
inline const std::string& MuteTrackRequest::_internal_sid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sid_.Get();
}
inline void MuteTrackRequest::_internal_set_sid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sid_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL MuteTrackRequest::_internal_mutable_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.sid_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE MuteTrackRequest::release_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.MuteTrackRequest.sid)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.sid_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.sid_.Set("", GetArena());
  }
  return released;
}
inline void MuteTrackRequest::set_allocated_sid(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.sid_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.sid_.IsDefault()) {
    _impl_.sid_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.MuteTrackRequest.sid)
}

// bool muted = 2;
inline void MuteTrackRequest::clear_muted() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.muted_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool MuteTrackRequest::muted() const {
  // @@protoc_insertion_point(field_get:livekit.MuteTrackRequest.muted)
  return _internal_muted();
}
inline void MuteTrackRequest::set_muted(bool value) {
  _internal_set_muted(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:livekit.MuteTrackRequest.muted)
}
inline bool MuteTrackRequest::_internal_muted() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.muted_;
}
inline void MuteTrackRequest::_internal_set_muted(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.muted_ = value;
}

// -------------------------------------------------------------------

// JoinResponse

// .livekit.Room room = 1;
inline bool JoinResponse::has_room() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.room_ != nullptr);
  return value;
}
inline const ::livekit::Room& JoinResponse::_internal_room() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::livekit::Room* p = _impl_.room_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::Room&>(::livekit::_Room_default_instance_);
}
inline const ::livekit::Room& JoinResponse::room() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.JoinResponse.room)
  return _internal_room();
}
inline void JoinResponse::unsafe_arena_set_allocated_room(
    ::livekit::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.room_);
  }
  _impl_.room_ = reinterpret_cast<::livekit::Room*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.JoinResponse.room)
}
inline ::livekit::Room* PROTOBUF_NULLABLE JoinResponse::release_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::livekit::Room* released = _impl_.room_;
  _impl_.room_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::livekit::Room* PROTOBUF_NULLABLE JoinResponse::unsafe_arena_release_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.JoinResponse.room)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::livekit::Room* temp = _impl_.room_;
  _impl_.room_ = nullptr;
  return temp;
}
inline ::livekit::Room* PROTOBUF_NONNULL JoinResponse::_internal_mutable_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.room_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::livekit::Room>(GetArena());
    _impl_.room_ = reinterpret_cast<::livekit::Room*>(p);
  }
  return _impl_.room_;
}
inline ::livekit::Room* PROTOBUF_NONNULL JoinResponse::mutable_room()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::livekit::Room* _msg = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:livekit.JoinResponse.room)
  return _msg;
}
inline void JoinResponse::set_allocated_room(::livekit::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.room_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.room_ = reinterpret_cast<::livekit::Room*>(value);
  // @@protoc_insertion_point(field_set_allocated:livekit.JoinResponse.room)
}

// .livekit.ParticipantInfo participant = 2;
inline bool JoinResponse::has_participant() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.participant_ != nullptr);
  return value;
}
inline const ::livekit::ParticipantInfo& JoinResponse::_internal_participant() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::livekit::ParticipantInfo* p = _impl_.participant_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::ParticipantInfo&>(::livekit::_ParticipantInfo_default_instance_);
}
inline const ::livekit::ParticipantInfo& JoinResponse::participant() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.JoinResponse.participant)
  return _internal_participant();
}
inline void JoinResponse::unsafe_arena_set_allocated_participant(
    ::livekit::ParticipantInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.participant_);
  }
  _impl_.participant_ = reinterpret_cast<::livekit::ParticipantInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.JoinResponse.participant)
}
inline ::livekit::ParticipantInfo* PROTOBUF_NULLABLE JoinResponse::release_participant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::livekit::ParticipantInfo* released = _impl_.participant_;
  _impl_.participant_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::livekit::ParticipantInfo* PROTOBUF_NULLABLE JoinResponse::unsafe_arena_release_participant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.JoinResponse.participant)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::livekit::ParticipantInfo* temp = _impl_.participant_;
  _impl_.participant_ = nullptr;
  return temp;
}
inline ::livekit::ParticipantInfo* PROTOBUF_NONNULL JoinResponse::_internal_mutable_participant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.participant_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::livekit::ParticipantInfo>(GetArena());
    _impl_.participant_ = reinterpret_cast<::livekit::ParticipantInfo*>(p);
  }
  return _impl_.participant_;
}
inline ::livekit::ParticipantInfo* PROTOBUF_NONNULL JoinResponse::mutable_participant()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::livekit::ParticipantInfo* _msg = _internal_mutable_participant();
  // @@protoc_insertion_point(field_mutable:livekit.JoinResponse.participant)
  return _msg;
}
inline void JoinResponse::set_allocated_participant(::livekit::ParticipantInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.participant_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.participant_ = reinterpret_cast<::livekit::ParticipantInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:livekit.JoinResponse.participant)
}

// repeated .livekit.ParticipantInfo other_participants = 3;
inline int JoinResponse::_internal_other_participants_size() const {
  return _internal_other_participants().size();
}
inline int JoinResponse::other_participants_size() const {
  return _internal_other_participants_size();
}
inline ::livekit::ParticipantInfo* PROTOBUF_NONNULL JoinResponse::mutable_other_participants(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.JoinResponse.other_participants)
  return _internal_mutable_other_participants()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::ParticipantInfo>* PROTOBUF_NONNULL JoinResponse::mutable_other_participants()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.JoinResponse.other_participants)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_other_participants();
}
inline const ::livekit::ParticipantInfo& JoinResponse::other_participants(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.JoinResponse.other_participants)
  return _internal_other_participants().Get(index);
}
inline ::livekit::ParticipantInfo* PROTOBUF_NONNULL JoinResponse::add_other_participants()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::ParticipantInfo* _add = _internal_mutable_other_participants()->Add();
  // @@protoc_insertion_point(field_add:livekit.JoinResponse.other_participants)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::ParticipantInfo>& JoinResponse::other_participants() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.JoinResponse.other_participants)
  return _internal_other_participants();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::ParticipantInfo>&
JoinResponse::_internal_other_participants() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.other_participants_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::ParticipantInfo>* PROTOBUF_NONNULL
JoinResponse::_internal_mutable_other_participants() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.other_participants_;
}

// string server_version = 4;
inline void JoinResponse::clear_server_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& JoinResponse::server_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.JoinResponse.server_version)
  return _internal_server_version();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void JoinResponse::set_server_version(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.server_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.JoinResponse.server_version)
}
inline std::string* PROTOBUF_NONNULL JoinResponse::mutable_server_version()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_server_version();
  // @@protoc_insertion_point(field_mutable:livekit.JoinResponse.server_version)
  return _s;
}
inline const std::string& JoinResponse::_internal_server_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.server_version_.Get();
}
inline void JoinResponse::_internal_set_server_version(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.server_version_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL JoinResponse::_internal_mutable_server_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.server_version_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE JoinResponse::release_server_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.JoinResponse.server_version)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.server_version_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.server_version_.Set("", GetArena());
  }
  return released;
}
inline void JoinResponse::set_allocated_server_version(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.server_version_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.server_version_.IsDefault()) {
    _impl_.server_version_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.JoinResponse.server_version)
}

// repeated .livekit.ICEServer ice_servers = 5;
inline int JoinResponse::_internal_ice_servers_size() const {
  return _internal_ice_servers().size();
}
inline int JoinResponse::ice_servers_size() const {
  return _internal_ice_servers_size();
}
inline void JoinResponse::clear_ice_servers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ice_servers_.Clear();
}
inline ::livekit::ICEServer* PROTOBUF_NONNULL JoinResponse::mutable_ice_servers(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.JoinResponse.ice_servers)
  return _internal_mutable_ice_servers()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::ICEServer>* PROTOBUF_NONNULL JoinResponse::mutable_ice_servers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.JoinResponse.ice_servers)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_ice_servers();
}
inline const ::livekit::ICEServer& JoinResponse::ice_servers(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.JoinResponse.ice_servers)
  return _internal_ice_servers().Get(index);
}
inline ::livekit::ICEServer* PROTOBUF_NONNULL JoinResponse::add_ice_servers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::ICEServer* _add = _internal_mutable_ice_servers()->Add();
  // @@protoc_insertion_point(field_add:livekit.JoinResponse.ice_servers)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::ICEServer>& JoinResponse::ice_servers() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.JoinResponse.ice_servers)
  return _internal_ice_servers();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::ICEServer>&
JoinResponse::_internal_ice_servers() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ice_servers_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::ICEServer>* PROTOBUF_NONNULL
JoinResponse::_internal_mutable_ice_servers() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.ice_servers_;
}

// bool subscriber_primary = 6;
inline void JoinResponse::clear_subscriber_primary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.subscriber_primary_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool JoinResponse::subscriber_primary() const {
  // @@protoc_insertion_point(field_get:livekit.JoinResponse.subscriber_primary)
  return _internal_subscriber_primary();
}
inline void JoinResponse::set_subscriber_primary(bool value) {
  _internal_set_subscriber_primary(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:livekit.JoinResponse.subscriber_primary)
}
inline bool JoinResponse::_internal_subscriber_primary() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.subscriber_primary_;
}
inline void JoinResponse::_internal_set_subscriber_primary(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.subscriber_primary_ = value;
}

// string alternative_url = 7;
inline void JoinResponse::clear_alternative_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alternative_url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& JoinResponse::alternative_url() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.JoinResponse.alternative_url)
  return _internal_alternative_url();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void JoinResponse::set_alternative_url(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.alternative_url_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.JoinResponse.alternative_url)
}
inline std::string* PROTOBUF_NONNULL JoinResponse::mutable_alternative_url()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_alternative_url();
  // @@protoc_insertion_point(field_mutable:livekit.JoinResponse.alternative_url)
  return _s;
}
inline const std::string& JoinResponse::_internal_alternative_url() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.alternative_url_.Get();
}
inline void JoinResponse::_internal_set_alternative_url(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.alternative_url_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL JoinResponse::_internal_mutable_alternative_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.alternative_url_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE JoinResponse::release_alternative_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.JoinResponse.alternative_url)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.alternative_url_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.alternative_url_.Set("", GetArena());
  }
  return released;
}
inline void JoinResponse::set_allocated_alternative_url(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.alternative_url_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.alternative_url_.IsDefault()) {
    _impl_.alternative_url_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.JoinResponse.alternative_url)
}

// .livekit.ClientConfiguration client_configuration = 8;
inline bool JoinResponse::has_client_configuration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.client_configuration_ != nullptr);
  return value;
}
inline const ::livekit::ClientConfiguration& JoinResponse::_internal_client_configuration() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::livekit::ClientConfiguration* p = _impl_.client_configuration_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::ClientConfiguration&>(::livekit::_ClientConfiguration_default_instance_);
}
inline const ::livekit::ClientConfiguration& JoinResponse::client_configuration() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.JoinResponse.client_configuration)
  return _internal_client_configuration();
}
inline void JoinResponse::unsafe_arena_set_allocated_client_configuration(
    ::livekit::ClientConfiguration* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.client_configuration_);
  }
  _impl_.client_configuration_ = reinterpret_cast<::livekit::ClientConfiguration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.JoinResponse.client_configuration)
}
inline ::livekit::ClientConfiguration* PROTOBUF_NULLABLE JoinResponse::release_client_configuration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::livekit::ClientConfiguration* released = _impl_.client_configuration_;
  _impl_.client_configuration_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::livekit::ClientConfiguration* PROTOBUF_NULLABLE JoinResponse::unsafe_arena_release_client_configuration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.JoinResponse.client_configuration)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::livekit::ClientConfiguration* temp = _impl_.client_configuration_;
  _impl_.client_configuration_ = nullptr;
  return temp;
}
inline ::livekit::ClientConfiguration* PROTOBUF_NONNULL JoinResponse::_internal_mutable_client_configuration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.client_configuration_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::livekit::ClientConfiguration>(GetArena());
    _impl_.client_configuration_ = reinterpret_cast<::livekit::ClientConfiguration*>(p);
  }
  return _impl_.client_configuration_;
}
inline ::livekit::ClientConfiguration* PROTOBUF_NONNULL JoinResponse::mutable_client_configuration()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000040u;
  ::livekit::ClientConfiguration* _msg = _internal_mutable_client_configuration();
  // @@protoc_insertion_point(field_mutable:livekit.JoinResponse.client_configuration)
  return _msg;
}
inline void JoinResponse::set_allocated_client_configuration(::livekit::ClientConfiguration* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.client_configuration_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.client_configuration_ = reinterpret_cast<::livekit::ClientConfiguration*>(value);
  // @@protoc_insertion_point(field_set_allocated:livekit.JoinResponse.client_configuration)
}

// string server_region = 9;
inline void JoinResponse::clear_server_region() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_region_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& JoinResponse::server_region() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.JoinResponse.server_region)
  return _internal_server_region();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void JoinResponse::set_server_region(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.server_region_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.JoinResponse.server_region)
}
inline std::string* PROTOBUF_NONNULL JoinResponse::mutable_server_region()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_server_region();
  // @@protoc_insertion_point(field_mutable:livekit.JoinResponse.server_region)
  return _s;
}
inline const std::string& JoinResponse::_internal_server_region() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.server_region_.Get();
}
inline void JoinResponse::_internal_set_server_region(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.server_region_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL JoinResponse::_internal_mutable_server_region() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.server_region_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE JoinResponse::release_server_region() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.JoinResponse.server_region)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.server_region_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.server_region_.Set("", GetArena());
  }
  return released;
}
inline void JoinResponse::set_allocated_server_region(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.server_region_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.server_region_.IsDefault()) {
    _impl_.server_region_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.JoinResponse.server_region)
}

// int32 ping_timeout = 10;
inline void JoinResponse::clear_ping_timeout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ping_timeout_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::int32_t JoinResponse::ping_timeout() const {
  // @@protoc_insertion_point(field_get:livekit.JoinResponse.ping_timeout)
  return _internal_ping_timeout();
}
inline void JoinResponse::set_ping_timeout(::int32_t value) {
  _internal_set_ping_timeout(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:livekit.JoinResponse.ping_timeout)
}
inline ::int32_t JoinResponse::_internal_ping_timeout() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ping_timeout_;
}
inline void JoinResponse::_internal_set_ping_timeout(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ping_timeout_ = value;
}

// int32 ping_interval = 11;
inline void JoinResponse::clear_ping_interval() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ping_interval_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::int32_t JoinResponse::ping_interval() const {
  // @@protoc_insertion_point(field_get:livekit.JoinResponse.ping_interval)
  return _internal_ping_interval();
}
inline void JoinResponse::set_ping_interval(::int32_t value) {
  _internal_set_ping_interval(value);
  _impl_._has_bits_[0] |= 0x00000800u;
  // @@protoc_insertion_point(field_set:livekit.JoinResponse.ping_interval)
}
inline ::int32_t JoinResponse::_internal_ping_interval() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ping_interval_;
}
inline void JoinResponse::_internal_set_ping_interval(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ping_interval_ = value;
}

// .livekit.ServerInfo server_info = 12;
inline bool JoinResponse::has_server_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.server_info_ != nullptr);
  return value;
}
inline const ::livekit::ServerInfo& JoinResponse::_internal_server_info() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::livekit::ServerInfo* p = _impl_.server_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::ServerInfo&>(::livekit::_ServerInfo_default_instance_);
}
inline const ::livekit::ServerInfo& JoinResponse::server_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.JoinResponse.server_info)
  return _internal_server_info();
}
inline void JoinResponse::unsafe_arena_set_allocated_server_info(
    ::livekit::ServerInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.server_info_);
  }
  _impl_.server_info_ = reinterpret_cast<::livekit::ServerInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.JoinResponse.server_info)
}
inline ::livekit::ServerInfo* PROTOBUF_NULLABLE JoinResponse::release_server_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::livekit::ServerInfo* released = _impl_.server_info_;
  _impl_.server_info_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::livekit::ServerInfo* PROTOBUF_NULLABLE JoinResponse::unsafe_arena_release_server_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.JoinResponse.server_info)

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::livekit::ServerInfo* temp = _impl_.server_info_;
  _impl_.server_info_ = nullptr;
  return temp;
}
inline ::livekit::ServerInfo* PROTOBUF_NONNULL JoinResponse::_internal_mutable_server_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.server_info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::livekit::ServerInfo>(GetArena());
    _impl_.server_info_ = reinterpret_cast<::livekit::ServerInfo*>(p);
  }
  return _impl_.server_info_;
}
inline ::livekit::ServerInfo* PROTOBUF_NONNULL JoinResponse::mutable_server_info()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000080u;
  ::livekit::ServerInfo* _msg = _internal_mutable_server_info();
  // @@protoc_insertion_point(field_mutable:livekit.JoinResponse.server_info)
  return _msg;
}
inline void JoinResponse::set_allocated_server_info(::livekit::ServerInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.server_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }

  _impl_.server_info_ = reinterpret_cast<::livekit::ServerInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:livekit.JoinResponse.server_info)
}

// bytes sif_trailer = 13;
inline void JoinResponse::clear_sif_trailer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sif_trailer_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& JoinResponse::sif_trailer() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.JoinResponse.sif_trailer)
  return _internal_sif_trailer();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void JoinResponse::set_sif_trailer(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.sif_trailer_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.JoinResponse.sif_trailer)
}
inline std::string* PROTOBUF_NONNULL JoinResponse::mutable_sif_trailer()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sif_trailer();
  // @@protoc_insertion_point(field_mutable:livekit.JoinResponse.sif_trailer)
  return _s;
}
inline const std::string& JoinResponse::_internal_sif_trailer() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sif_trailer_.Get();
}
inline void JoinResponse::_internal_set_sif_trailer(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.sif_trailer_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL JoinResponse::_internal_mutable_sif_trailer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.sif_trailer_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE JoinResponse::release_sif_trailer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.JoinResponse.sif_trailer)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.sif_trailer_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.sif_trailer_.Set("", GetArena());
  }
  return released;
}
inline void JoinResponse::set_allocated_sif_trailer(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.sif_trailer_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.sif_trailer_.IsDefault()) {
    _impl_.sif_trailer_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.JoinResponse.sif_trailer)
}

// repeated .livekit.Codec enabled_publish_codecs = 14;
inline int JoinResponse::_internal_enabled_publish_codecs_size() const {
  return _internal_enabled_publish_codecs().size();
}
inline int JoinResponse::enabled_publish_codecs_size() const {
  return _internal_enabled_publish_codecs_size();
}
inline ::livekit::Codec* PROTOBUF_NONNULL JoinResponse::mutable_enabled_publish_codecs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.JoinResponse.enabled_publish_codecs)
  return _internal_mutable_enabled_publish_codecs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::Codec>* PROTOBUF_NONNULL JoinResponse::mutable_enabled_publish_codecs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.JoinResponse.enabled_publish_codecs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_enabled_publish_codecs();
}
inline const ::livekit::Codec& JoinResponse::enabled_publish_codecs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.JoinResponse.enabled_publish_codecs)
  return _internal_enabled_publish_codecs().Get(index);
}
inline ::livekit::Codec* PROTOBUF_NONNULL JoinResponse::add_enabled_publish_codecs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::Codec* _add = _internal_mutable_enabled_publish_codecs()->Add();
  // @@protoc_insertion_point(field_add:livekit.JoinResponse.enabled_publish_codecs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::Codec>& JoinResponse::enabled_publish_codecs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.JoinResponse.enabled_publish_codecs)
  return _internal_enabled_publish_codecs();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::Codec>&
JoinResponse::_internal_enabled_publish_codecs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enabled_publish_codecs_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::Codec>* PROTOBUF_NONNULL
JoinResponse::_internal_mutable_enabled_publish_codecs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.enabled_publish_codecs_;
}

// bool fast_publish = 15;
inline void JoinResponse::clear_fast_publish() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fast_publish_ = false;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool JoinResponse::fast_publish() const {
  // @@protoc_insertion_point(field_get:livekit.JoinResponse.fast_publish)
  return _internal_fast_publish();
}
inline void JoinResponse::set_fast_publish(bool value) {
  _internal_set_fast_publish(value);
  _impl_._has_bits_[0] |= 0x00000400u;
  // @@protoc_insertion_point(field_set:livekit.JoinResponse.fast_publish)
}
inline bool JoinResponse::_internal_fast_publish() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fast_publish_;
}
inline void JoinResponse::_internal_set_fast_publish(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fast_publish_ = value;
}

// -------------------------------------------------------------------

// ReconnectResponse

// repeated .livekit.ICEServer ice_servers = 1;
inline int ReconnectResponse::_internal_ice_servers_size() const {
  return _internal_ice_servers().size();
}
inline int ReconnectResponse::ice_servers_size() const {
  return _internal_ice_servers_size();
}
inline void ReconnectResponse::clear_ice_servers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ice_servers_.Clear();
}
inline ::livekit::ICEServer* PROTOBUF_NONNULL ReconnectResponse::mutable_ice_servers(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.ReconnectResponse.ice_servers)
  return _internal_mutable_ice_servers()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::ICEServer>* PROTOBUF_NONNULL ReconnectResponse::mutable_ice_servers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.ReconnectResponse.ice_servers)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_ice_servers();
}
inline const ::livekit::ICEServer& ReconnectResponse::ice_servers(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.ReconnectResponse.ice_servers)
  return _internal_ice_servers().Get(index);
}
inline ::livekit::ICEServer* PROTOBUF_NONNULL ReconnectResponse::add_ice_servers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::ICEServer* _add = _internal_mutable_ice_servers()->Add();
  // @@protoc_insertion_point(field_add:livekit.ReconnectResponse.ice_servers)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::ICEServer>& ReconnectResponse::ice_servers() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.ReconnectResponse.ice_servers)
  return _internal_ice_servers();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::ICEServer>&
ReconnectResponse::_internal_ice_servers() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ice_servers_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::ICEServer>* PROTOBUF_NONNULL
ReconnectResponse::_internal_mutable_ice_servers() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.ice_servers_;
}

// .livekit.ClientConfiguration client_configuration = 2;
inline bool ReconnectResponse::has_client_configuration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.client_configuration_ != nullptr);
  return value;
}
inline const ::livekit::ClientConfiguration& ReconnectResponse::_internal_client_configuration() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::livekit::ClientConfiguration* p = _impl_.client_configuration_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::ClientConfiguration&>(::livekit::_ClientConfiguration_default_instance_);
}
inline const ::livekit::ClientConfiguration& ReconnectResponse::client_configuration() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.ReconnectResponse.client_configuration)
  return _internal_client_configuration();
}
inline void ReconnectResponse::unsafe_arena_set_allocated_client_configuration(
    ::livekit::ClientConfiguration* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.client_configuration_);
  }
  _impl_.client_configuration_ = reinterpret_cast<::livekit::ClientConfiguration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.ReconnectResponse.client_configuration)
}
inline ::livekit::ClientConfiguration* PROTOBUF_NULLABLE ReconnectResponse::release_client_configuration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::ClientConfiguration* released = _impl_.client_configuration_;
  _impl_.client_configuration_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::livekit::ClientConfiguration* PROTOBUF_NULLABLE ReconnectResponse::unsafe_arena_release_client_configuration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.ReconnectResponse.client_configuration)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::ClientConfiguration* temp = _impl_.client_configuration_;
  _impl_.client_configuration_ = nullptr;
  return temp;
}
inline ::livekit::ClientConfiguration* PROTOBUF_NONNULL ReconnectResponse::_internal_mutable_client_configuration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.client_configuration_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::livekit::ClientConfiguration>(GetArena());
    _impl_.client_configuration_ = reinterpret_cast<::livekit::ClientConfiguration*>(p);
  }
  return _impl_.client_configuration_;
}
inline ::livekit::ClientConfiguration* PROTOBUF_NONNULL ReconnectResponse::mutable_client_configuration()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::livekit::ClientConfiguration* _msg = _internal_mutable_client_configuration();
  // @@protoc_insertion_point(field_mutable:livekit.ReconnectResponse.client_configuration)
  return _msg;
}
inline void ReconnectResponse::set_allocated_client_configuration(::livekit::ClientConfiguration* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.client_configuration_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.client_configuration_ = reinterpret_cast<::livekit::ClientConfiguration*>(value);
  // @@protoc_insertion_point(field_set_allocated:livekit.ReconnectResponse.client_configuration)
}

// -------------------------------------------------------------------

// TrackPublishedResponse

// string cid = 1;
inline void TrackPublishedResponse::clear_cid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TrackPublishedResponse::cid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.TrackPublishedResponse.cid)
  return _internal_cid();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void TrackPublishedResponse::set_cid(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.cid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.TrackPublishedResponse.cid)
}
inline std::string* PROTOBUF_NONNULL TrackPublishedResponse::mutable_cid()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:livekit.TrackPublishedResponse.cid)
  return _s;
}
inline const std::string& TrackPublishedResponse::_internal_cid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cid_.Get();
}
inline void TrackPublishedResponse::_internal_set_cid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.cid_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL TrackPublishedResponse::_internal_mutable_cid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.cid_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE TrackPublishedResponse::release_cid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.TrackPublishedResponse.cid)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.cid_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.cid_.Set("", GetArena());
  }
  return released;
}
inline void TrackPublishedResponse::set_allocated_cid(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.cid_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.cid_.IsDefault()) {
    _impl_.cid_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.TrackPublishedResponse.cid)
}

// .livekit.TrackInfo track = 2;
inline bool TrackPublishedResponse::has_track() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.track_ != nullptr);
  return value;
}
inline const ::livekit::TrackInfo& TrackPublishedResponse::_internal_track() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::livekit::TrackInfo* p = _impl_.track_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::TrackInfo&>(::livekit::_TrackInfo_default_instance_);
}
inline const ::livekit::TrackInfo& TrackPublishedResponse::track() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.TrackPublishedResponse.track)
  return _internal_track();
}
inline void TrackPublishedResponse::unsafe_arena_set_allocated_track(
    ::livekit::TrackInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.track_);
  }
  _impl_.track_ = reinterpret_cast<::livekit::TrackInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.TrackPublishedResponse.track)
}
inline ::livekit::TrackInfo* PROTOBUF_NULLABLE TrackPublishedResponse::release_track() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::TrackInfo* released = _impl_.track_;
  _impl_.track_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::livekit::TrackInfo* PROTOBUF_NULLABLE TrackPublishedResponse::unsafe_arena_release_track() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.TrackPublishedResponse.track)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::TrackInfo* temp = _impl_.track_;
  _impl_.track_ = nullptr;
  return temp;
}
inline ::livekit::TrackInfo* PROTOBUF_NONNULL TrackPublishedResponse::_internal_mutable_track() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.track_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::livekit::TrackInfo>(GetArena());
    _impl_.track_ = reinterpret_cast<::livekit::TrackInfo*>(p);
  }
  return _impl_.track_;
}
inline ::livekit::TrackInfo* PROTOBUF_NONNULL TrackPublishedResponse::mutable_track()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::livekit::TrackInfo* _msg = _internal_mutable_track();
  // @@protoc_insertion_point(field_mutable:livekit.TrackPublishedResponse.track)
  return _msg;
}
inline void TrackPublishedResponse::set_allocated_track(::livekit::TrackInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.track_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.track_ = reinterpret_cast<::livekit::TrackInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:livekit.TrackPublishedResponse.track)
}

// -------------------------------------------------------------------

// TrackUnpublishedResponse

// string track_sid = 1;
inline void TrackUnpublishedResponse::clear_track_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.track_sid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TrackUnpublishedResponse::track_sid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.TrackUnpublishedResponse.track_sid)
  return _internal_track_sid();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void TrackUnpublishedResponse::set_track_sid(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.track_sid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.TrackUnpublishedResponse.track_sid)
}
inline std::string* PROTOBUF_NONNULL TrackUnpublishedResponse::mutable_track_sid()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_track_sid();
  // @@protoc_insertion_point(field_mutable:livekit.TrackUnpublishedResponse.track_sid)
  return _s;
}
inline const std::string& TrackUnpublishedResponse::_internal_track_sid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.track_sid_.Get();
}
inline void TrackUnpublishedResponse::_internal_set_track_sid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.track_sid_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL TrackUnpublishedResponse::_internal_mutable_track_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.track_sid_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE TrackUnpublishedResponse::release_track_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.TrackUnpublishedResponse.track_sid)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.track_sid_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.track_sid_.Set("", GetArena());
  }
  return released;
}
inline void TrackUnpublishedResponse::set_allocated_track_sid(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.track_sid_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.track_sid_.IsDefault()) {
    _impl_.track_sid_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.TrackUnpublishedResponse.track_sid)
}

// -------------------------------------------------------------------

// SessionDescription

// string type = 1;
inline void SessionDescription::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SessionDescription::type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SessionDescription.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SessionDescription::set_type(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.SessionDescription.type)
}
inline std::string* PROTOBUF_NONNULL SessionDescription::mutable_type()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:livekit.SessionDescription.type)
  return _s;
}
inline const std::string& SessionDescription::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.type_.Get();
}
inline void SessionDescription::_internal_set_type(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL SessionDescription::_internal_mutable_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.type_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE SessionDescription::release_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.SessionDescription.type)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.type_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.type_.Set("", GetArena());
  }
  return released;
}
inline void SessionDescription::set_allocated_type(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.SessionDescription.type)
}

// string sdp = 2;
inline void SessionDescription::clear_sdp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sdp_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SessionDescription::sdp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SessionDescription.sdp)
  return _internal_sdp();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SessionDescription::set_sdp(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.sdp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.SessionDescription.sdp)
}
inline std::string* PROTOBUF_NONNULL SessionDescription::mutable_sdp()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sdp();
  // @@protoc_insertion_point(field_mutable:livekit.SessionDescription.sdp)
  return _s;
}
inline const std::string& SessionDescription::_internal_sdp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sdp_.Get();
}
inline void SessionDescription::_internal_set_sdp(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.sdp_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL SessionDescription::_internal_mutable_sdp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.sdp_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE SessionDescription::release_sdp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.SessionDescription.sdp)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.sdp_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.sdp_.Set("", GetArena());
  }
  return released;
}
inline void SessionDescription::set_allocated_sdp(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.sdp_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.sdp_.IsDefault()) {
    _impl_.sdp_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.SessionDescription.sdp)
}

// -------------------------------------------------------------------

// ParticipantUpdate

// repeated .livekit.ParticipantInfo participants = 1;
inline int ParticipantUpdate::_internal_participants_size() const {
  return _internal_participants().size();
}
inline int ParticipantUpdate::participants_size() const {
  return _internal_participants_size();
}
inline ::livekit::ParticipantInfo* PROTOBUF_NONNULL ParticipantUpdate::mutable_participants(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.ParticipantUpdate.participants)
  return _internal_mutable_participants()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::ParticipantInfo>* PROTOBUF_NONNULL ParticipantUpdate::mutable_participants()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.ParticipantUpdate.participants)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_participants();
}
inline const ::livekit::ParticipantInfo& ParticipantUpdate::participants(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.ParticipantUpdate.participants)
  return _internal_participants().Get(index);
}
inline ::livekit::ParticipantInfo* PROTOBUF_NONNULL ParticipantUpdate::add_participants()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::ParticipantInfo* _add = _internal_mutable_participants()->Add();
  // @@protoc_insertion_point(field_add:livekit.ParticipantUpdate.participants)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::ParticipantInfo>& ParticipantUpdate::participants() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.ParticipantUpdate.participants)
  return _internal_participants();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::ParticipantInfo>&
ParticipantUpdate::_internal_participants() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.participants_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::ParticipantInfo>* PROTOBUF_NONNULL
ParticipantUpdate::_internal_mutable_participants() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.participants_;
}

// -------------------------------------------------------------------

// UpdateSubscription

// repeated string track_sids = 1;
inline int UpdateSubscription::_internal_track_sids_size() const {
  return _internal_track_sids().size();
}
inline int UpdateSubscription::track_sids_size() const {
  return _internal_track_sids_size();
}
inline void UpdateSubscription::clear_track_sids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.track_sids_.Clear();
}
inline std::string* PROTOBUF_NONNULL UpdateSubscription::add_track_sids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_track_sids()->Add();
  // @@protoc_insertion_point(field_add_mutable:livekit.UpdateSubscription.track_sids)
  return _s;
}
inline const std::string& UpdateSubscription::track_sids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.UpdateSubscription.track_sids)
  return _internal_track_sids().Get(index);
}
inline std::string* PROTOBUF_NONNULL UpdateSubscription::mutable_track_sids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.UpdateSubscription.track_sids)
  return _internal_mutable_track_sids()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void UpdateSubscription::set_track_sids(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_track_sids()->Mutable(index), std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:livekit.UpdateSubscription.track_sids)
}
template <typename Arg_, typename... Args_>
inline void UpdateSubscription::add_track_sids(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_track_sids(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:livekit.UpdateSubscription.track_sids)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>& UpdateSubscription::track_sids() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.UpdateSubscription.track_sids)
  return _internal_track_sids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* PROTOBUF_NONNULL
UpdateSubscription::mutable_track_sids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.UpdateSubscription.track_sids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_track_sids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
UpdateSubscription::_internal_track_sids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.track_sids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>* PROTOBUF_NONNULL
UpdateSubscription::_internal_mutable_track_sids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.track_sids_;
}

// bool subscribe = 2;
inline void UpdateSubscription::clear_subscribe() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.subscribe_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool UpdateSubscription::subscribe() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateSubscription.subscribe)
  return _internal_subscribe();
}
inline void UpdateSubscription::set_subscribe(bool value) {
  _internal_set_subscribe(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:livekit.UpdateSubscription.subscribe)
}
inline bool UpdateSubscription::_internal_subscribe() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.subscribe_;
}
inline void UpdateSubscription::_internal_set_subscribe(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.subscribe_ = value;
}

// repeated .livekit.ParticipantTracks participant_tracks = 3;
inline int UpdateSubscription::_internal_participant_tracks_size() const {
  return _internal_participant_tracks().size();
}
inline int UpdateSubscription::participant_tracks_size() const {
  return _internal_participant_tracks_size();
}
inline ::livekit::ParticipantTracks* PROTOBUF_NONNULL UpdateSubscription::mutable_participant_tracks(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.UpdateSubscription.participant_tracks)
  return _internal_mutable_participant_tracks()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::ParticipantTracks>* PROTOBUF_NONNULL UpdateSubscription::mutable_participant_tracks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.UpdateSubscription.participant_tracks)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_participant_tracks();
}
inline const ::livekit::ParticipantTracks& UpdateSubscription::participant_tracks(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.UpdateSubscription.participant_tracks)
  return _internal_participant_tracks().Get(index);
}
inline ::livekit::ParticipantTracks* PROTOBUF_NONNULL UpdateSubscription::add_participant_tracks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::ParticipantTracks* _add = _internal_mutable_participant_tracks()->Add();
  // @@protoc_insertion_point(field_add:livekit.UpdateSubscription.participant_tracks)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::ParticipantTracks>& UpdateSubscription::participant_tracks() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.UpdateSubscription.participant_tracks)
  return _internal_participant_tracks();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::ParticipantTracks>&
UpdateSubscription::_internal_participant_tracks() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.participant_tracks_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::ParticipantTracks>* PROTOBUF_NONNULL
UpdateSubscription::_internal_mutable_participant_tracks() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.participant_tracks_;
}

// -------------------------------------------------------------------

// UpdateTrackSettings

// repeated string track_sids = 1;
inline int UpdateTrackSettings::_internal_track_sids_size() const {
  return _internal_track_sids().size();
}
inline int UpdateTrackSettings::track_sids_size() const {
  return _internal_track_sids_size();
}
inline void UpdateTrackSettings::clear_track_sids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.track_sids_.Clear();
}
inline std::string* PROTOBUF_NONNULL UpdateTrackSettings::add_track_sids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_track_sids()->Add();
  // @@protoc_insertion_point(field_add_mutable:livekit.UpdateTrackSettings.track_sids)
  return _s;
}
inline const std::string& UpdateTrackSettings::track_sids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.UpdateTrackSettings.track_sids)
  return _internal_track_sids().Get(index);
}
inline std::string* PROTOBUF_NONNULL UpdateTrackSettings::mutable_track_sids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.UpdateTrackSettings.track_sids)
  return _internal_mutable_track_sids()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void UpdateTrackSettings::set_track_sids(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_track_sids()->Mutable(index), std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:livekit.UpdateTrackSettings.track_sids)
}
template <typename Arg_, typename... Args_>
inline void UpdateTrackSettings::add_track_sids(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_track_sids(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:livekit.UpdateTrackSettings.track_sids)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>& UpdateTrackSettings::track_sids() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.UpdateTrackSettings.track_sids)
  return _internal_track_sids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* PROTOBUF_NONNULL
UpdateTrackSettings::mutable_track_sids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.UpdateTrackSettings.track_sids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_track_sids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
UpdateTrackSettings::_internal_track_sids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.track_sids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>* PROTOBUF_NONNULL
UpdateTrackSettings::_internal_mutable_track_sids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.track_sids_;
}

// bool disabled = 3;
inline void UpdateTrackSettings::clear_disabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.disabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool UpdateTrackSettings::disabled() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateTrackSettings.disabled)
  return _internal_disabled();
}
inline void UpdateTrackSettings::set_disabled(bool value) {
  _internal_set_disabled(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:livekit.UpdateTrackSettings.disabled)
}
inline bool UpdateTrackSettings::_internal_disabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.disabled_;
}
inline void UpdateTrackSettings::_internal_set_disabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.disabled_ = value;
}

// .livekit.VideoQuality quality = 4;
inline void UpdateTrackSettings::clear_quality() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.quality_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::livekit::VideoQuality UpdateTrackSettings::quality() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateTrackSettings.quality)
  return _internal_quality();
}
inline void UpdateTrackSettings::set_quality(::livekit::VideoQuality value) {
  _internal_set_quality(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:livekit.UpdateTrackSettings.quality)
}
inline ::livekit::VideoQuality UpdateTrackSettings::_internal_quality() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::livekit::VideoQuality>(_impl_.quality_);
}
inline void UpdateTrackSettings::_internal_set_quality(::livekit::VideoQuality value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.quality_ = value;
}

// uint32 width = 5;
inline void UpdateTrackSettings::clear_width() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t UpdateTrackSettings::width() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateTrackSettings.width)
  return _internal_width();
}
inline void UpdateTrackSettings::set_width(::uint32_t value) {
  _internal_set_width(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:livekit.UpdateTrackSettings.width)
}
inline ::uint32_t UpdateTrackSettings::_internal_width() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.width_;
}
inline void UpdateTrackSettings::_internal_set_width(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_ = value;
}

// uint32 height = 6;
inline void UpdateTrackSettings::clear_height() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t UpdateTrackSettings::height() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateTrackSettings.height)
  return _internal_height();
}
inline void UpdateTrackSettings::set_height(::uint32_t value) {
  _internal_set_height(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:livekit.UpdateTrackSettings.height)
}
inline ::uint32_t UpdateTrackSettings::_internal_height() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.height_;
}
inline void UpdateTrackSettings::_internal_set_height(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = value;
}

// uint32 fps = 7;
inline void UpdateTrackSettings::clear_fps() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fps_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t UpdateTrackSettings::fps() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateTrackSettings.fps)
  return _internal_fps();
}
inline void UpdateTrackSettings::set_fps(::uint32_t value) {
  _internal_set_fps(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:livekit.UpdateTrackSettings.fps)
}
inline ::uint32_t UpdateTrackSettings::_internal_fps() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fps_;
}
inline void UpdateTrackSettings::_internal_set_fps(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fps_ = value;
}

// uint32 priority = 8;
inline void UpdateTrackSettings::clear_priority() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.priority_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint32_t UpdateTrackSettings::priority() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateTrackSettings.priority)
  return _internal_priority();
}
inline void UpdateTrackSettings::set_priority(::uint32_t value) {
  _internal_set_priority(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:livekit.UpdateTrackSettings.priority)
}
inline ::uint32_t UpdateTrackSettings::_internal_priority() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.priority_;
}
inline void UpdateTrackSettings::_internal_set_priority(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.priority_ = value;
}

// -------------------------------------------------------------------

// UpdateLocalAudioTrack

// string track_sid = 1;
inline void UpdateLocalAudioTrack::clear_track_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.track_sid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UpdateLocalAudioTrack::track_sid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.UpdateLocalAudioTrack.track_sid)
  return _internal_track_sid();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UpdateLocalAudioTrack::set_track_sid(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.track_sid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.UpdateLocalAudioTrack.track_sid)
}
inline std::string* PROTOBUF_NONNULL UpdateLocalAudioTrack::mutable_track_sid()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_track_sid();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateLocalAudioTrack.track_sid)
  return _s;
}
inline const std::string& UpdateLocalAudioTrack::_internal_track_sid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.track_sid_.Get();
}
inline void UpdateLocalAudioTrack::_internal_set_track_sid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.track_sid_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL UpdateLocalAudioTrack::_internal_mutable_track_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.track_sid_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE UpdateLocalAudioTrack::release_track_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.UpdateLocalAudioTrack.track_sid)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.track_sid_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.track_sid_.Set("", GetArena());
  }
  return released;
}
inline void UpdateLocalAudioTrack::set_allocated_track_sid(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.track_sid_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.track_sid_.IsDefault()) {
    _impl_.track_sid_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateLocalAudioTrack.track_sid)
}

// repeated .livekit.AudioTrackFeature features = 2;
inline int UpdateLocalAudioTrack::_internal_features_size() const {
  return _internal_features().size();
}
inline int UpdateLocalAudioTrack::features_size() const {
  return _internal_features_size();
}
inline void UpdateLocalAudioTrack::clear_features() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.features_.Clear();
}
inline ::livekit::AudioTrackFeature UpdateLocalAudioTrack::features(int index) const {
  // @@protoc_insertion_point(field_get:livekit.UpdateLocalAudioTrack.features)
  return static_cast<::livekit::AudioTrackFeature>(_internal_features().Get(index));
}
inline void UpdateLocalAudioTrack::set_features(int index, ::livekit::AudioTrackFeature value) {
  _internal_mutable_features()->Set(index, value);
  // @@protoc_insertion_point(field_set:livekit.UpdateLocalAudioTrack.features)
}
inline void UpdateLocalAudioTrack::add_features(::livekit::AudioTrackFeature value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_features()->Add(value);
  // @@protoc_insertion_point(field_add:livekit.UpdateLocalAudioTrack.features)
}
inline const ::google::protobuf::RepeatedField<int>& UpdateLocalAudioTrack::features() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.UpdateLocalAudioTrack.features)
  return _internal_features();
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL UpdateLocalAudioTrack::mutable_features()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.UpdateLocalAudioTrack.features)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_features();
}
inline const ::google::protobuf::RepeatedField<int>& UpdateLocalAudioTrack::_internal_features()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.features_;
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL
UpdateLocalAudioTrack::_internal_mutable_features() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.features_;
}

// -------------------------------------------------------------------

// UpdateLocalVideoTrack

// string track_sid = 1;
inline void UpdateLocalVideoTrack::clear_track_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.track_sid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UpdateLocalVideoTrack::track_sid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.UpdateLocalVideoTrack.track_sid)
  return _internal_track_sid();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UpdateLocalVideoTrack::set_track_sid(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.track_sid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.UpdateLocalVideoTrack.track_sid)
}
inline std::string* PROTOBUF_NONNULL UpdateLocalVideoTrack::mutable_track_sid()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_track_sid();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateLocalVideoTrack.track_sid)
  return _s;
}
inline const std::string& UpdateLocalVideoTrack::_internal_track_sid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.track_sid_.Get();
}
inline void UpdateLocalVideoTrack::_internal_set_track_sid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.track_sid_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL UpdateLocalVideoTrack::_internal_mutable_track_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.track_sid_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE UpdateLocalVideoTrack::release_track_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.UpdateLocalVideoTrack.track_sid)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.track_sid_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.track_sid_.Set("", GetArena());
  }
  return released;
}
inline void UpdateLocalVideoTrack::set_allocated_track_sid(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.track_sid_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.track_sid_.IsDefault()) {
    _impl_.track_sid_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateLocalVideoTrack.track_sid)
}

// uint32 width = 2;
inline void UpdateLocalVideoTrack::clear_width() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t UpdateLocalVideoTrack::width() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateLocalVideoTrack.width)
  return _internal_width();
}
inline void UpdateLocalVideoTrack::set_width(::uint32_t value) {
  _internal_set_width(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:livekit.UpdateLocalVideoTrack.width)
}
inline ::uint32_t UpdateLocalVideoTrack::_internal_width() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.width_;
}
inline void UpdateLocalVideoTrack::_internal_set_width(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_ = value;
}

// uint32 height = 3;
inline void UpdateLocalVideoTrack::clear_height() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t UpdateLocalVideoTrack::height() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateLocalVideoTrack.height)
  return _internal_height();
}
inline void UpdateLocalVideoTrack::set_height(::uint32_t value) {
  _internal_set_height(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:livekit.UpdateLocalVideoTrack.height)
}
inline ::uint32_t UpdateLocalVideoTrack::_internal_height() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.height_;
}
inline void UpdateLocalVideoTrack::_internal_set_height(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = value;
}

// -------------------------------------------------------------------

// LeaveRequest

// bool can_reconnect = 1;
inline void LeaveRequest::clear_can_reconnect() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.can_reconnect_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool LeaveRequest::can_reconnect() const {
  // @@protoc_insertion_point(field_get:livekit.LeaveRequest.can_reconnect)
  return _internal_can_reconnect();
}
inline void LeaveRequest::set_can_reconnect(bool value) {
  _internal_set_can_reconnect(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:livekit.LeaveRequest.can_reconnect)
}
inline bool LeaveRequest::_internal_can_reconnect() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.can_reconnect_;
}
inline void LeaveRequest::_internal_set_can_reconnect(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.can_reconnect_ = value;
}

// .livekit.DisconnectReason reason = 2;
inline void LeaveRequest::clear_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::livekit::DisconnectReason LeaveRequest::reason() const {
  // @@protoc_insertion_point(field_get:livekit.LeaveRequest.reason)
  return _internal_reason();
}
inline void LeaveRequest::set_reason(::livekit::DisconnectReason value) {
  _internal_set_reason(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:livekit.LeaveRequest.reason)
}
inline ::livekit::DisconnectReason LeaveRequest::_internal_reason() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::livekit::DisconnectReason>(_impl_.reason_);
}
inline void LeaveRequest::_internal_set_reason(::livekit::DisconnectReason value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_ = value;
}

// .livekit.LeaveRequest.Action action = 3;
inline void LeaveRequest::clear_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::livekit::LeaveRequest_Action LeaveRequest::action() const {
  // @@protoc_insertion_point(field_get:livekit.LeaveRequest.action)
  return _internal_action();
}
inline void LeaveRequest::set_action(::livekit::LeaveRequest_Action value) {
  _internal_set_action(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:livekit.LeaveRequest.action)
}
inline ::livekit::LeaveRequest_Action LeaveRequest::_internal_action() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::livekit::LeaveRequest_Action>(_impl_.action_);
}
inline void LeaveRequest::_internal_set_action(::livekit::LeaveRequest_Action value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_ = value;
}

// .livekit.RegionSettings regions = 4;
inline bool LeaveRequest::has_regions() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.regions_ != nullptr);
  return value;
}
inline void LeaveRequest::clear_regions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.regions_ != nullptr) _impl_.regions_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::livekit::RegionSettings& LeaveRequest::_internal_regions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::livekit::RegionSettings* p = _impl_.regions_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::RegionSettings&>(::livekit::_RegionSettings_default_instance_);
}
inline const ::livekit::RegionSettings& LeaveRequest::regions() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.LeaveRequest.regions)
  return _internal_regions();
}
inline void LeaveRequest::unsafe_arena_set_allocated_regions(
    ::livekit::RegionSettings* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.regions_);
  }
  _impl_.regions_ = reinterpret_cast<::livekit::RegionSettings*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.LeaveRequest.regions)
}
inline ::livekit::RegionSettings* PROTOBUF_NULLABLE LeaveRequest::release_regions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::RegionSettings* released = _impl_.regions_;
  _impl_.regions_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::livekit::RegionSettings* PROTOBUF_NULLABLE LeaveRequest::unsafe_arena_release_regions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.LeaveRequest.regions)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::RegionSettings* temp = _impl_.regions_;
  _impl_.regions_ = nullptr;
  return temp;
}
inline ::livekit::RegionSettings* PROTOBUF_NONNULL LeaveRequest::_internal_mutable_regions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.regions_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::livekit::RegionSettings>(GetArena());
    _impl_.regions_ = reinterpret_cast<::livekit::RegionSettings*>(p);
  }
  return _impl_.regions_;
}
inline ::livekit::RegionSettings* PROTOBUF_NONNULL LeaveRequest::mutable_regions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::livekit::RegionSettings* _msg = _internal_mutable_regions();
  // @@protoc_insertion_point(field_mutable:livekit.LeaveRequest.regions)
  return _msg;
}
inline void LeaveRequest::set_allocated_regions(::livekit::RegionSettings* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.regions_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.regions_ = reinterpret_cast<::livekit::RegionSettings*>(value);
  // @@protoc_insertion_point(field_set_allocated:livekit.LeaveRequest.regions)
}

// -------------------------------------------------------------------

// UpdateVideoLayers

// string track_sid = 1;
inline void UpdateVideoLayers::clear_track_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.track_sid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UpdateVideoLayers::track_sid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.UpdateVideoLayers.track_sid)
  return _internal_track_sid();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UpdateVideoLayers::set_track_sid(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.track_sid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.UpdateVideoLayers.track_sid)
}
inline std::string* PROTOBUF_NONNULL UpdateVideoLayers::mutable_track_sid()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_track_sid();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateVideoLayers.track_sid)
  return _s;
}
inline const std::string& UpdateVideoLayers::_internal_track_sid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.track_sid_.Get();
}
inline void UpdateVideoLayers::_internal_set_track_sid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.track_sid_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL UpdateVideoLayers::_internal_mutable_track_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.track_sid_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE UpdateVideoLayers::release_track_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.UpdateVideoLayers.track_sid)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.track_sid_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.track_sid_.Set("", GetArena());
  }
  return released;
}
inline void UpdateVideoLayers::set_allocated_track_sid(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.track_sid_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.track_sid_.IsDefault()) {
    _impl_.track_sid_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateVideoLayers.track_sid)
}

// repeated .livekit.VideoLayer layers = 2;
inline int UpdateVideoLayers::_internal_layers_size() const {
  return _internal_layers().size();
}
inline int UpdateVideoLayers::layers_size() const {
  return _internal_layers_size();
}
inline ::livekit::VideoLayer* PROTOBUF_NONNULL UpdateVideoLayers::mutable_layers(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.UpdateVideoLayers.layers)
  return _internal_mutable_layers()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::VideoLayer>* PROTOBUF_NONNULL UpdateVideoLayers::mutable_layers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.UpdateVideoLayers.layers)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_layers();
}
inline const ::livekit::VideoLayer& UpdateVideoLayers::layers(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.UpdateVideoLayers.layers)
  return _internal_layers().Get(index);
}
inline ::livekit::VideoLayer* PROTOBUF_NONNULL UpdateVideoLayers::add_layers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::VideoLayer* _add = _internal_mutable_layers()->Add();
  // @@protoc_insertion_point(field_add:livekit.UpdateVideoLayers.layers)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::VideoLayer>& UpdateVideoLayers::layers() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.UpdateVideoLayers.layers)
  return _internal_layers();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::VideoLayer>&
UpdateVideoLayers::_internal_layers() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.layers_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::VideoLayer>* PROTOBUF_NONNULL
UpdateVideoLayers::_internal_mutable_layers() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.layers_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// UpdateParticipantMetadata

// string metadata = 1;
inline void UpdateParticipantMetadata::clear_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.metadata_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UpdateParticipantMetadata::metadata() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.UpdateParticipantMetadata.metadata)
  return _internal_metadata();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UpdateParticipantMetadata::set_metadata(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.metadata_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.UpdateParticipantMetadata.metadata)
}
inline std::string* PROTOBUF_NONNULL UpdateParticipantMetadata::mutable_metadata()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateParticipantMetadata.metadata)
  return _s;
}
inline const std::string& UpdateParticipantMetadata::_internal_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.metadata_.Get();
}
inline void UpdateParticipantMetadata::_internal_set_metadata(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.metadata_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL UpdateParticipantMetadata::_internal_mutable_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.metadata_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE UpdateParticipantMetadata::release_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.UpdateParticipantMetadata.metadata)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.metadata_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.metadata_.Set("", GetArena());
  }
  return released;
}
inline void UpdateParticipantMetadata::set_allocated_metadata(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.metadata_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.metadata_.IsDefault()) {
    _impl_.metadata_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateParticipantMetadata.metadata)
}

// string name = 2;
inline void UpdateParticipantMetadata::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UpdateParticipantMetadata::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.UpdateParticipantMetadata.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UpdateParticipantMetadata::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.UpdateParticipantMetadata.name)
}
inline std::string* PROTOBUF_NONNULL UpdateParticipantMetadata::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateParticipantMetadata.name)
  return _s;
}
inline const std::string& UpdateParticipantMetadata::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void UpdateParticipantMetadata::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL UpdateParticipantMetadata::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE UpdateParticipantMetadata::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.UpdateParticipantMetadata.name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void UpdateParticipantMetadata::set_allocated_name(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateParticipantMetadata.name)
}

// map<string, string> attributes = 3;
inline int UpdateParticipantMetadata::_internal_attributes_size() const {
  return _internal_attributes().size();
}
inline int UpdateParticipantMetadata::attributes_size() const {
  return _internal_attributes_size();
}
inline void UpdateParticipantMetadata::clear_attributes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.attributes_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& UpdateParticipantMetadata::_internal_attributes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.attributes_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& UpdateParticipantMetadata::attributes() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:livekit.UpdateParticipantMetadata.attributes)
  return _internal_attributes();
}
inline ::google::protobuf::Map<std::string, std::string>* PROTOBUF_NONNULL UpdateParticipantMetadata::_internal_mutable_attributes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.attributes_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* PROTOBUF_NONNULL UpdateParticipantMetadata::mutable_attributes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:livekit.UpdateParticipantMetadata.attributes)
  return _internal_mutable_attributes();
}

// uint32 request_id = 4;
inline void UpdateParticipantMetadata::clear_request_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t UpdateParticipantMetadata::request_id() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateParticipantMetadata.request_id)
  return _internal_request_id();
}
inline void UpdateParticipantMetadata::set_request_id(::uint32_t value) {
  _internal_set_request_id(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:livekit.UpdateParticipantMetadata.request_id)
}
inline ::uint32_t UpdateParticipantMetadata::_internal_request_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.request_id_;
}
inline void UpdateParticipantMetadata::_internal_set_request_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_id_ = value;
}

// -------------------------------------------------------------------

// ICEServer

// repeated string urls = 1;
inline int ICEServer::_internal_urls_size() const {
  return _internal_urls().size();
}
inline int ICEServer::urls_size() const {
  return _internal_urls_size();
}
inline void ICEServer::clear_urls() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.urls_.Clear();
}
inline std::string* PROTOBUF_NONNULL ICEServer::add_urls()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_urls()->Add();
  // @@protoc_insertion_point(field_add_mutable:livekit.ICEServer.urls)
  return _s;
}
inline const std::string& ICEServer::urls(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.ICEServer.urls)
  return _internal_urls().Get(index);
}
inline std::string* PROTOBUF_NONNULL ICEServer::mutable_urls(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.ICEServer.urls)
  return _internal_mutable_urls()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void ICEServer::set_urls(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_urls()->Mutable(index), std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:livekit.ICEServer.urls)
}
template <typename Arg_, typename... Args_>
inline void ICEServer::add_urls(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_urls(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:livekit.ICEServer.urls)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>& ICEServer::urls() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.ICEServer.urls)
  return _internal_urls();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* PROTOBUF_NONNULL
ICEServer::mutable_urls() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.ICEServer.urls)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_urls();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ICEServer::_internal_urls() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.urls_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>* PROTOBUF_NONNULL
ICEServer::_internal_mutable_urls() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.urls_;
}

// string username = 2;
inline void ICEServer::clear_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ICEServer::username() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.ICEServer.username)
  return _internal_username();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ICEServer::set_username(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.username_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.ICEServer.username)
}
inline std::string* PROTOBUF_NONNULL ICEServer::mutable_username()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:livekit.ICEServer.username)
  return _s;
}
inline const std::string& ICEServer::_internal_username() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.username_.Get();
}
inline void ICEServer::_internal_set_username(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.username_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL ICEServer::_internal_mutable_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.username_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE ICEServer::release_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.ICEServer.username)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.username_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.username_.Set("", GetArena());
  }
  return released;
}
inline void ICEServer::set_allocated_username(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.username_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.ICEServer.username)
}

// string credential = 3;
inline void ICEServer::clear_credential() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.credential_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ICEServer::credential() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.ICEServer.credential)
  return _internal_credential();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ICEServer::set_credential(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.credential_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.ICEServer.credential)
}
inline std::string* PROTOBUF_NONNULL ICEServer::mutable_credential()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_credential();
  // @@protoc_insertion_point(field_mutable:livekit.ICEServer.credential)
  return _s;
}
inline const std::string& ICEServer::_internal_credential() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.credential_.Get();
}
inline void ICEServer::_internal_set_credential(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.credential_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL ICEServer::_internal_mutable_credential() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.credential_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE ICEServer::release_credential() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.ICEServer.credential)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.credential_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.credential_.Set("", GetArena());
  }
  return released;
}
inline void ICEServer::set_allocated_credential(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.credential_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.credential_.IsDefault()) {
    _impl_.credential_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.ICEServer.credential)
}

// -------------------------------------------------------------------

// SpeakersChanged

// repeated .livekit.SpeakerInfo speakers = 1;
inline int SpeakersChanged::_internal_speakers_size() const {
  return _internal_speakers().size();
}
inline int SpeakersChanged::speakers_size() const {
  return _internal_speakers_size();
}
inline ::livekit::SpeakerInfo* PROTOBUF_NONNULL SpeakersChanged::mutable_speakers(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.SpeakersChanged.speakers)
  return _internal_mutable_speakers()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::SpeakerInfo>* PROTOBUF_NONNULL SpeakersChanged::mutable_speakers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.SpeakersChanged.speakers)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_speakers();
}
inline const ::livekit::SpeakerInfo& SpeakersChanged::speakers(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SpeakersChanged.speakers)
  return _internal_speakers().Get(index);
}
inline ::livekit::SpeakerInfo* PROTOBUF_NONNULL SpeakersChanged::add_speakers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::SpeakerInfo* _add = _internal_mutable_speakers()->Add();
  // @@protoc_insertion_point(field_add:livekit.SpeakersChanged.speakers)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::SpeakerInfo>& SpeakersChanged::speakers() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.SpeakersChanged.speakers)
  return _internal_speakers();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::SpeakerInfo>&
SpeakersChanged::_internal_speakers() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.speakers_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::SpeakerInfo>* PROTOBUF_NONNULL
SpeakersChanged::_internal_mutable_speakers() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.speakers_;
}

// -------------------------------------------------------------------

// RoomUpdate

// .livekit.Room room = 1;
inline bool RoomUpdate::has_room() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.room_ != nullptr);
  return value;
}
inline const ::livekit::Room& RoomUpdate::_internal_room() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::livekit::Room* p = _impl_.room_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::Room&>(::livekit::_Room_default_instance_);
}
inline const ::livekit::Room& RoomUpdate::room() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.RoomUpdate.room)
  return _internal_room();
}
inline void RoomUpdate::unsafe_arena_set_allocated_room(
    ::livekit::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.room_);
  }
  _impl_.room_ = reinterpret_cast<::livekit::Room*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.RoomUpdate.room)
}
inline ::livekit::Room* PROTOBUF_NULLABLE RoomUpdate::release_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::Room* released = _impl_.room_;
  _impl_.room_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::livekit::Room* PROTOBUF_NULLABLE RoomUpdate::unsafe_arena_release_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.RoomUpdate.room)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::Room* temp = _impl_.room_;
  _impl_.room_ = nullptr;
  return temp;
}
inline ::livekit::Room* PROTOBUF_NONNULL RoomUpdate::_internal_mutable_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.room_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::livekit::Room>(GetArena());
    _impl_.room_ = reinterpret_cast<::livekit::Room*>(p);
  }
  return _impl_.room_;
}
inline ::livekit::Room* PROTOBUF_NONNULL RoomUpdate::mutable_room()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::livekit::Room* _msg = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:livekit.RoomUpdate.room)
  return _msg;
}
inline void RoomUpdate::set_allocated_room(::livekit::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.room_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.room_ = reinterpret_cast<::livekit::Room*>(value);
  // @@protoc_insertion_point(field_set_allocated:livekit.RoomUpdate.room)
}

// -------------------------------------------------------------------

// ConnectionQualityInfo

// string participant_sid = 1;
inline void ConnectionQualityInfo::clear_participant_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.participant_sid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConnectionQualityInfo::participant_sid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.ConnectionQualityInfo.participant_sid)
  return _internal_participant_sid();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ConnectionQualityInfo::set_participant_sid(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.participant_sid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.ConnectionQualityInfo.participant_sid)
}
inline std::string* PROTOBUF_NONNULL ConnectionQualityInfo::mutable_participant_sid()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_participant_sid();
  // @@protoc_insertion_point(field_mutable:livekit.ConnectionQualityInfo.participant_sid)
  return _s;
}
inline const std::string& ConnectionQualityInfo::_internal_participant_sid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.participant_sid_.Get();
}
inline void ConnectionQualityInfo::_internal_set_participant_sid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.participant_sid_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL ConnectionQualityInfo::_internal_mutable_participant_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.participant_sid_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE ConnectionQualityInfo::release_participant_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.ConnectionQualityInfo.participant_sid)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.participant_sid_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.participant_sid_.Set("", GetArena());
  }
  return released;
}
inline void ConnectionQualityInfo::set_allocated_participant_sid(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.participant_sid_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.participant_sid_.IsDefault()) {
    _impl_.participant_sid_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.ConnectionQualityInfo.participant_sid)
}

// .livekit.ConnectionQuality quality = 2;
inline void ConnectionQualityInfo::clear_quality() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.quality_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::livekit::ConnectionQuality ConnectionQualityInfo::quality() const {
  // @@protoc_insertion_point(field_get:livekit.ConnectionQualityInfo.quality)
  return _internal_quality();
}
inline void ConnectionQualityInfo::set_quality(::livekit::ConnectionQuality value) {
  _internal_set_quality(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:livekit.ConnectionQualityInfo.quality)
}
inline ::livekit::ConnectionQuality ConnectionQualityInfo::_internal_quality() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::livekit::ConnectionQuality>(_impl_.quality_);
}
inline void ConnectionQualityInfo::_internal_set_quality(::livekit::ConnectionQuality value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.quality_ = value;
}

// float score = 3;
inline void ConnectionQualityInfo::clear_score() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.score_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float ConnectionQualityInfo::score() const {
  // @@protoc_insertion_point(field_get:livekit.ConnectionQualityInfo.score)
  return _internal_score();
}
inline void ConnectionQualityInfo::set_score(float value) {
  _internal_set_score(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:livekit.ConnectionQualityInfo.score)
}
inline float ConnectionQualityInfo::_internal_score() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.score_;
}
inline void ConnectionQualityInfo::_internal_set_score(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.score_ = value;
}

// -------------------------------------------------------------------

// ConnectionQualityUpdate

// repeated .livekit.ConnectionQualityInfo updates = 1;
inline int ConnectionQualityUpdate::_internal_updates_size() const {
  return _internal_updates().size();
}
inline int ConnectionQualityUpdate::updates_size() const {
  return _internal_updates_size();
}
inline void ConnectionQualityUpdate::clear_updates() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.updates_.Clear();
}
inline ::livekit::ConnectionQualityInfo* PROTOBUF_NONNULL ConnectionQualityUpdate::mutable_updates(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.ConnectionQualityUpdate.updates)
  return _internal_mutable_updates()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::ConnectionQualityInfo>* PROTOBUF_NONNULL ConnectionQualityUpdate::mutable_updates()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.ConnectionQualityUpdate.updates)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_updates();
}
inline const ::livekit::ConnectionQualityInfo& ConnectionQualityUpdate::updates(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.ConnectionQualityUpdate.updates)
  return _internal_updates().Get(index);
}
inline ::livekit::ConnectionQualityInfo* PROTOBUF_NONNULL ConnectionQualityUpdate::add_updates()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::ConnectionQualityInfo* _add = _internal_mutable_updates()->Add();
  // @@protoc_insertion_point(field_add:livekit.ConnectionQualityUpdate.updates)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::ConnectionQualityInfo>& ConnectionQualityUpdate::updates() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.ConnectionQualityUpdate.updates)
  return _internal_updates();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::ConnectionQualityInfo>&
ConnectionQualityUpdate::_internal_updates() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.updates_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::ConnectionQualityInfo>* PROTOBUF_NONNULL
ConnectionQualityUpdate::_internal_mutable_updates() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.updates_;
}

// -------------------------------------------------------------------

// StreamStateInfo

// string participant_sid = 1;
inline void StreamStateInfo::clear_participant_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.participant_sid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StreamStateInfo::participant_sid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.StreamStateInfo.participant_sid)
  return _internal_participant_sid();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void StreamStateInfo::set_participant_sid(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.participant_sid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.StreamStateInfo.participant_sid)
}
inline std::string* PROTOBUF_NONNULL StreamStateInfo::mutable_participant_sid()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_participant_sid();
  // @@protoc_insertion_point(field_mutable:livekit.StreamStateInfo.participant_sid)
  return _s;
}
inline const std::string& StreamStateInfo::_internal_participant_sid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.participant_sid_.Get();
}
inline void StreamStateInfo::_internal_set_participant_sid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.participant_sid_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL StreamStateInfo::_internal_mutable_participant_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.participant_sid_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE StreamStateInfo::release_participant_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.StreamStateInfo.participant_sid)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.participant_sid_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.participant_sid_.Set("", GetArena());
  }
  return released;
}
inline void StreamStateInfo::set_allocated_participant_sid(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.participant_sid_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.participant_sid_.IsDefault()) {
    _impl_.participant_sid_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.StreamStateInfo.participant_sid)
}

// string track_sid = 2;
inline void StreamStateInfo::clear_track_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.track_sid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StreamStateInfo::track_sid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.StreamStateInfo.track_sid)
  return _internal_track_sid();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void StreamStateInfo::set_track_sid(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.track_sid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.StreamStateInfo.track_sid)
}
inline std::string* PROTOBUF_NONNULL StreamStateInfo::mutable_track_sid()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_track_sid();
  // @@protoc_insertion_point(field_mutable:livekit.StreamStateInfo.track_sid)
  return _s;
}
inline const std::string& StreamStateInfo::_internal_track_sid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.track_sid_.Get();
}
inline void StreamStateInfo::_internal_set_track_sid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.track_sid_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL StreamStateInfo::_internal_mutable_track_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.track_sid_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE StreamStateInfo::release_track_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.StreamStateInfo.track_sid)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.track_sid_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.track_sid_.Set("", GetArena());
  }
  return released;
}
inline void StreamStateInfo::set_allocated_track_sid(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.track_sid_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.track_sid_.IsDefault()) {
    _impl_.track_sid_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.StreamStateInfo.track_sid)
}

// .livekit.StreamState state = 3;
inline void StreamStateInfo::clear_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::livekit::StreamState StreamStateInfo::state() const {
  // @@protoc_insertion_point(field_get:livekit.StreamStateInfo.state)
  return _internal_state();
}
inline void StreamStateInfo::set_state(::livekit::StreamState value) {
  _internal_set_state(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:livekit.StreamStateInfo.state)
}
inline ::livekit::StreamState StreamStateInfo::_internal_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::livekit::StreamState>(_impl_.state_);
}
inline void StreamStateInfo::_internal_set_state(::livekit::StreamState value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.state_ = value;
}

// -------------------------------------------------------------------

// StreamStateUpdate

// repeated .livekit.StreamStateInfo stream_states = 1;
inline int StreamStateUpdate::_internal_stream_states_size() const {
  return _internal_stream_states().size();
}
inline int StreamStateUpdate::stream_states_size() const {
  return _internal_stream_states_size();
}
inline void StreamStateUpdate::clear_stream_states() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stream_states_.Clear();
}
inline ::livekit::StreamStateInfo* PROTOBUF_NONNULL StreamStateUpdate::mutable_stream_states(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.StreamStateUpdate.stream_states)
  return _internal_mutable_stream_states()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::StreamStateInfo>* PROTOBUF_NONNULL StreamStateUpdate::mutable_stream_states()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.StreamStateUpdate.stream_states)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_stream_states();
}
inline const ::livekit::StreamStateInfo& StreamStateUpdate::stream_states(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.StreamStateUpdate.stream_states)
  return _internal_stream_states().Get(index);
}
inline ::livekit::StreamStateInfo* PROTOBUF_NONNULL StreamStateUpdate::add_stream_states()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::StreamStateInfo* _add = _internal_mutable_stream_states()->Add();
  // @@protoc_insertion_point(field_add:livekit.StreamStateUpdate.stream_states)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::StreamStateInfo>& StreamStateUpdate::stream_states() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.StreamStateUpdate.stream_states)
  return _internal_stream_states();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::StreamStateInfo>&
StreamStateUpdate::_internal_stream_states() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stream_states_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::StreamStateInfo>* PROTOBUF_NONNULL
StreamStateUpdate::_internal_mutable_stream_states() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.stream_states_;
}

// -------------------------------------------------------------------

// SubscribedQuality

// .livekit.VideoQuality quality = 1;
inline void SubscribedQuality::clear_quality() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.quality_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::livekit::VideoQuality SubscribedQuality::quality() const {
  // @@protoc_insertion_point(field_get:livekit.SubscribedQuality.quality)
  return _internal_quality();
}
inline void SubscribedQuality::set_quality(::livekit::VideoQuality value) {
  _internal_set_quality(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:livekit.SubscribedQuality.quality)
}
inline ::livekit::VideoQuality SubscribedQuality::_internal_quality() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::livekit::VideoQuality>(_impl_.quality_);
}
inline void SubscribedQuality::_internal_set_quality(::livekit::VideoQuality value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.quality_ = value;
}

// bool enabled = 2;
inline void SubscribedQuality::clear_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool SubscribedQuality::enabled() const {
  // @@protoc_insertion_point(field_get:livekit.SubscribedQuality.enabled)
  return _internal_enabled();
}
inline void SubscribedQuality::set_enabled(bool value) {
  _internal_set_enabled(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:livekit.SubscribedQuality.enabled)
}
inline bool SubscribedQuality::_internal_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enabled_;
}
inline void SubscribedQuality::_internal_set_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enabled_ = value;
}

// -------------------------------------------------------------------

// SubscribedCodec

// string codec = 1;
inline void SubscribedCodec::clear_codec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.codec_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SubscribedCodec::codec() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SubscribedCodec.codec)
  return _internal_codec();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SubscribedCodec::set_codec(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.codec_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.SubscribedCodec.codec)
}
inline std::string* PROTOBUF_NONNULL SubscribedCodec::mutable_codec()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_codec();
  // @@protoc_insertion_point(field_mutable:livekit.SubscribedCodec.codec)
  return _s;
}
inline const std::string& SubscribedCodec::_internal_codec() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.codec_.Get();
}
inline void SubscribedCodec::_internal_set_codec(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.codec_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL SubscribedCodec::_internal_mutable_codec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.codec_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE SubscribedCodec::release_codec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.SubscribedCodec.codec)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.codec_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.codec_.Set("", GetArena());
  }
  return released;
}
inline void SubscribedCodec::set_allocated_codec(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.codec_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.codec_.IsDefault()) {
    _impl_.codec_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.SubscribedCodec.codec)
}

// repeated .livekit.SubscribedQuality qualities = 2;
inline int SubscribedCodec::_internal_qualities_size() const {
  return _internal_qualities().size();
}
inline int SubscribedCodec::qualities_size() const {
  return _internal_qualities_size();
}
inline void SubscribedCodec::clear_qualities() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.qualities_.Clear();
}
inline ::livekit::SubscribedQuality* PROTOBUF_NONNULL SubscribedCodec::mutable_qualities(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.SubscribedCodec.qualities)
  return _internal_mutable_qualities()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::SubscribedQuality>* PROTOBUF_NONNULL SubscribedCodec::mutable_qualities()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.SubscribedCodec.qualities)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_qualities();
}
inline const ::livekit::SubscribedQuality& SubscribedCodec::qualities(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SubscribedCodec.qualities)
  return _internal_qualities().Get(index);
}
inline ::livekit::SubscribedQuality* PROTOBUF_NONNULL SubscribedCodec::add_qualities()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::SubscribedQuality* _add = _internal_mutable_qualities()->Add();
  // @@protoc_insertion_point(field_add:livekit.SubscribedCodec.qualities)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::SubscribedQuality>& SubscribedCodec::qualities() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.SubscribedCodec.qualities)
  return _internal_qualities();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::SubscribedQuality>&
SubscribedCodec::_internal_qualities() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.qualities_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::SubscribedQuality>* PROTOBUF_NONNULL
SubscribedCodec::_internal_mutable_qualities() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.qualities_;
}

// -------------------------------------------------------------------

// SubscribedQualityUpdate

// string track_sid = 1;
inline void SubscribedQualityUpdate::clear_track_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.track_sid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SubscribedQualityUpdate::track_sid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SubscribedQualityUpdate.track_sid)
  return _internal_track_sid();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SubscribedQualityUpdate::set_track_sid(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.track_sid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.SubscribedQualityUpdate.track_sid)
}
inline std::string* PROTOBUF_NONNULL SubscribedQualityUpdate::mutable_track_sid()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_track_sid();
  // @@protoc_insertion_point(field_mutable:livekit.SubscribedQualityUpdate.track_sid)
  return _s;
}
inline const std::string& SubscribedQualityUpdate::_internal_track_sid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.track_sid_.Get();
}
inline void SubscribedQualityUpdate::_internal_set_track_sid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.track_sid_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL SubscribedQualityUpdate::_internal_mutable_track_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.track_sid_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE SubscribedQualityUpdate::release_track_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.SubscribedQualityUpdate.track_sid)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.track_sid_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.track_sid_.Set("", GetArena());
  }
  return released;
}
inline void SubscribedQualityUpdate::set_allocated_track_sid(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.track_sid_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.track_sid_.IsDefault()) {
    _impl_.track_sid_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.SubscribedQualityUpdate.track_sid)
}

// repeated .livekit.SubscribedQuality subscribed_qualities = 2;
inline int SubscribedQualityUpdate::_internal_subscribed_qualities_size() const {
  return _internal_subscribed_qualities().size();
}
inline int SubscribedQualityUpdate::subscribed_qualities_size() const {
  return _internal_subscribed_qualities_size();
}
inline void SubscribedQualityUpdate::clear_subscribed_qualities() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.subscribed_qualities_.Clear();
}
inline ::livekit::SubscribedQuality* PROTOBUF_NONNULL SubscribedQualityUpdate::mutable_subscribed_qualities(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.SubscribedQualityUpdate.subscribed_qualities)
  return _internal_mutable_subscribed_qualities()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::SubscribedQuality>* PROTOBUF_NONNULL SubscribedQualityUpdate::mutable_subscribed_qualities()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.SubscribedQualityUpdate.subscribed_qualities)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_subscribed_qualities();
}
inline const ::livekit::SubscribedQuality& SubscribedQualityUpdate::subscribed_qualities(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SubscribedQualityUpdate.subscribed_qualities)
  return _internal_subscribed_qualities().Get(index);
}
inline ::livekit::SubscribedQuality* PROTOBUF_NONNULL SubscribedQualityUpdate::add_subscribed_qualities()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::SubscribedQuality* _add = _internal_mutable_subscribed_qualities()->Add();
  // @@protoc_insertion_point(field_add:livekit.SubscribedQualityUpdate.subscribed_qualities)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::SubscribedQuality>& SubscribedQualityUpdate::subscribed_qualities() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.SubscribedQualityUpdate.subscribed_qualities)
  return _internal_subscribed_qualities();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::SubscribedQuality>&
SubscribedQualityUpdate::_internal_subscribed_qualities() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.subscribed_qualities_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::SubscribedQuality>* PROTOBUF_NONNULL
SubscribedQualityUpdate::_internal_mutable_subscribed_qualities() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.subscribed_qualities_;
}

// repeated .livekit.SubscribedCodec subscribed_codecs = 3;
inline int SubscribedQualityUpdate::_internal_subscribed_codecs_size() const {
  return _internal_subscribed_codecs().size();
}
inline int SubscribedQualityUpdate::subscribed_codecs_size() const {
  return _internal_subscribed_codecs_size();
}
inline void SubscribedQualityUpdate::clear_subscribed_codecs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.subscribed_codecs_.Clear();
}
inline ::livekit::SubscribedCodec* PROTOBUF_NONNULL SubscribedQualityUpdate::mutable_subscribed_codecs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.SubscribedQualityUpdate.subscribed_codecs)
  return _internal_mutable_subscribed_codecs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::SubscribedCodec>* PROTOBUF_NONNULL SubscribedQualityUpdate::mutable_subscribed_codecs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.SubscribedQualityUpdate.subscribed_codecs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_subscribed_codecs();
}
inline const ::livekit::SubscribedCodec& SubscribedQualityUpdate::subscribed_codecs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SubscribedQualityUpdate.subscribed_codecs)
  return _internal_subscribed_codecs().Get(index);
}
inline ::livekit::SubscribedCodec* PROTOBUF_NONNULL SubscribedQualityUpdate::add_subscribed_codecs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::SubscribedCodec* _add = _internal_mutable_subscribed_codecs()->Add();
  // @@protoc_insertion_point(field_add:livekit.SubscribedQualityUpdate.subscribed_codecs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::SubscribedCodec>& SubscribedQualityUpdate::subscribed_codecs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.SubscribedQualityUpdate.subscribed_codecs)
  return _internal_subscribed_codecs();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::SubscribedCodec>&
SubscribedQualityUpdate::_internal_subscribed_codecs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.subscribed_codecs_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::SubscribedCodec>* PROTOBUF_NONNULL
SubscribedQualityUpdate::_internal_mutable_subscribed_codecs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.subscribed_codecs_;
}

// -------------------------------------------------------------------

// TrackPermission

// string participant_sid = 1;
inline void TrackPermission::clear_participant_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.participant_sid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TrackPermission::participant_sid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.TrackPermission.participant_sid)
  return _internal_participant_sid();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void TrackPermission::set_participant_sid(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.participant_sid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.TrackPermission.participant_sid)
}
inline std::string* PROTOBUF_NONNULL TrackPermission::mutable_participant_sid()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_participant_sid();
  // @@protoc_insertion_point(field_mutable:livekit.TrackPermission.participant_sid)
  return _s;
}
inline const std::string& TrackPermission::_internal_participant_sid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.participant_sid_.Get();
}
inline void TrackPermission::_internal_set_participant_sid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.participant_sid_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL TrackPermission::_internal_mutable_participant_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.participant_sid_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE TrackPermission::release_participant_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.TrackPermission.participant_sid)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.participant_sid_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.participant_sid_.Set("", GetArena());
  }
  return released;
}
inline void TrackPermission::set_allocated_participant_sid(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.participant_sid_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.participant_sid_.IsDefault()) {
    _impl_.participant_sid_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.TrackPermission.participant_sid)
}

// bool all_tracks = 2;
inline void TrackPermission::clear_all_tracks() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.all_tracks_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool TrackPermission::all_tracks() const {
  // @@protoc_insertion_point(field_get:livekit.TrackPermission.all_tracks)
  return _internal_all_tracks();
}
inline void TrackPermission::set_all_tracks(bool value) {
  _internal_set_all_tracks(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:livekit.TrackPermission.all_tracks)
}
inline bool TrackPermission::_internal_all_tracks() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.all_tracks_;
}
inline void TrackPermission::_internal_set_all_tracks(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.all_tracks_ = value;
}

// repeated string track_sids = 3;
inline int TrackPermission::_internal_track_sids_size() const {
  return _internal_track_sids().size();
}
inline int TrackPermission::track_sids_size() const {
  return _internal_track_sids_size();
}
inline void TrackPermission::clear_track_sids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.track_sids_.Clear();
}
inline std::string* PROTOBUF_NONNULL TrackPermission::add_track_sids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_track_sids()->Add();
  // @@protoc_insertion_point(field_add_mutable:livekit.TrackPermission.track_sids)
  return _s;
}
inline const std::string& TrackPermission::track_sids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.TrackPermission.track_sids)
  return _internal_track_sids().Get(index);
}
inline std::string* PROTOBUF_NONNULL TrackPermission::mutable_track_sids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.TrackPermission.track_sids)
  return _internal_mutable_track_sids()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void TrackPermission::set_track_sids(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_track_sids()->Mutable(index), std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:livekit.TrackPermission.track_sids)
}
template <typename Arg_, typename... Args_>
inline void TrackPermission::add_track_sids(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_track_sids(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:livekit.TrackPermission.track_sids)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>& TrackPermission::track_sids() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.TrackPermission.track_sids)
  return _internal_track_sids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* PROTOBUF_NONNULL
TrackPermission::mutable_track_sids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.TrackPermission.track_sids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_track_sids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TrackPermission::_internal_track_sids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.track_sids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>* PROTOBUF_NONNULL
TrackPermission::_internal_mutable_track_sids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.track_sids_;
}

// string participant_identity = 4;
inline void TrackPermission::clear_participant_identity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.participant_identity_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TrackPermission::participant_identity() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.TrackPermission.participant_identity)
  return _internal_participant_identity();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void TrackPermission::set_participant_identity(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.participant_identity_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.TrackPermission.participant_identity)
}
inline std::string* PROTOBUF_NONNULL TrackPermission::mutable_participant_identity()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_participant_identity();
  // @@protoc_insertion_point(field_mutable:livekit.TrackPermission.participant_identity)
  return _s;
}
inline const std::string& TrackPermission::_internal_participant_identity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.participant_identity_.Get();
}
inline void TrackPermission::_internal_set_participant_identity(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.participant_identity_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL TrackPermission::_internal_mutable_participant_identity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.participant_identity_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE TrackPermission::release_participant_identity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.TrackPermission.participant_identity)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.participant_identity_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.participant_identity_.Set("", GetArena());
  }
  return released;
}
inline void TrackPermission::set_allocated_participant_identity(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.participant_identity_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.TrackPermission.participant_identity)
}

// -------------------------------------------------------------------

// SubscriptionPermission

// bool all_participants = 1;
inline void SubscriptionPermission::clear_all_participants() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.all_participants_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool SubscriptionPermission::all_participants() const {
  // @@protoc_insertion_point(field_get:livekit.SubscriptionPermission.all_participants)
  return _internal_all_participants();
}
inline void SubscriptionPermission::set_all_participants(bool value) {
  _internal_set_all_participants(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:livekit.SubscriptionPermission.all_participants)
}
inline bool SubscriptionPermission::_internal_all_participants() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.all_participants_;
}
inline void SubscriptionPermission::_internal_set_all_participants(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.all_participants_ = value;
}

// repeated .livekit.TrackPermission track_permissions = 2;
inline int SubscriptionPermission::_internal_track_permissions_size() const {
  return _internal_track_permissions().size();
}
inline int SubscriptionPermission::track_permissions_size() const {
  return _internal_track_permissions_size();
}
inline void SubscriptionPermission::clear_track_permissions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.track_permissions_.Clear();
}
inline ::livekit::TrackPermission* PROTOBUF_NONNULL SubscriptionPermission::mutable_track_permissions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.SubscriptionPermission.track_permissions)
  return _internal_mutable_track_permissions()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::TrackPermission>* PROTOBUF_NONNULL SubscriptionPermission::mutable_track_permissions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.SubscriptionPermission.track_permissions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_track_permissions();
}
inline const ::livekit::TrackPermission& SubscriptionPermission::track_permissions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SubscriptionPermission.track_permissions)
  return _internal_track_permissions().Get(index);
}
inline ::livekit::TrackPermission* PROTOBUF_NONNULL SubscriptionPermission::add_track_permissions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::TrackPermission* _add = _internal_mutable_track_permissions()->Add();
  // @@protoc_insertion_point(field_add:livekit.SubscriptionPermission.track_permissions)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::TrackPermission>& SubscriptionPermission::track_permissions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.SubscriptionPermission.track_permissions)
  return _internal_track_permissions();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::TrackPermission>&
SubscriptionPermission::_internal_track_permissions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.track_permissions_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::TrackPermission>* PROTOBUF_NONNULL
SubscriptionPermission::_internal_mutable_track_permissions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.track_permissions_;
}

// -------------------------------------------------------------------

// SubscriptionPermissionUpdate

// string participant_sid = 1;
inline void SubscriptionPermissionUpdate::clear_participant_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.participant_sid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SubscriptionPermissionUpdate::participant_sid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SubscriptionPermissionUpdate.participant_sid)
  return _internal_participant_sid();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SubscriptionPermissionUpdate::set_participant_sid(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.participant_sid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.SubscriptionPermissionUpdate.participant_sid)
}
inline std::string* PROTOBUF_NONNULL SubscriptionPermissionUpdate::mutable_participant_sid()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_participant_sid();
  // @@protoc_insertion_point(field_mutable:livekit.SubscriptionPermissionUpdate.participant_sid)
  return _s;
}
inline const std::string& SubscriptionPermissionUpdate::_internal_participant_sid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.participant_sid_.Get();
}
inline void SubscriptionPermissionUpdate::_internal_set_participant_sid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.participant_sid_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL SubscriptionPermissionUpdate::_internal_mutable_participant_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.participant_sid_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE SubscriptionPermissionUpdate::release_participant_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.SubscriptionPermissionUpdate.participant_sid)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.participant_sid_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.participant_sid_.Set("", GetArena());
  }
  return released;
}
inline void SubscriptionPermissionUpdate::set_allocated_participant_sid(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.participant_sid_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.participant_sid_.IsDefault()) {
    _impl_.participant_sid_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.SubscriptionPermissionUpdate.participant_sid)
}

// string track_sid = 2;
inline void SubscriptionPermissionUpdate::clear_track_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.track_sid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SubscriptionPermissionUpdate::track_sid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SubscriptionPermissionUpdate.track_sid)
  return _internal_track_sid();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SubscriptionPermissionUpdate::set_track_sid(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.track_sid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.SubscriptionPermissionUpdate.track_sid)
}
inline std::string* PROTOBUF_NONNULL SubscriptionPermissionUpdate::mutable_track_sid()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_track_sid();
  // @@protoc_insertion_point(field_mutable:livekit.SubscriptionPermissionUpdate.track_sid)
  return _s;
}
inline const std::string& SubscriptionPermissionUpdate::_internal_track_sid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.track_sid_.Get();
}
inline void SubscriptionPermissionUpdate::_internal_set_track_sid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.track_sid_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL SubscriptionPermissionUpdate::_internal_mutable_track_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.track_sid_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE SubscriptionPermissionUpdate::release_track_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.SubscriptionPermissionUpdate.track_sid)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.track_sid_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.track_sid_.Set("", GetArena());
  }
  return released;
}
inline void SubscriptionPermissionUpdate::set_allocated_track_sid(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.track_sid_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.track_sid_.IsDefault()) {
    _impl_.track_sid_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.SubscriptionPermissionUpdate.track_sid)
}

// bool allowed = 3;
inline void SubscriptionPermissionUpdate::clear_allowed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.allowed_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool SubscriptionPermissionUpdate::allowed() const {
  // @@protoc_insertion_point(field_get:livekit.SubscriptionPermissionUpdate.allowed)
  return _internal_allowed();
}
inline void SubscriptionPermissionUpdate::set_allowed(bool value) {
  _internal_set_allowed(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:livekit.SubscriptionPermissionUpdate.allowed)
}
inline bool SubscriptionPermissionUpdate::_internal_allowed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.allowed_;
}
inline void SubscriptionPermissionUpdate::_internal_set_allowed(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.allowed_ = value;
}

// -------------------------------------------------------------------

// SyncState

// .livekit.SessionDescription answer = 1;
inline bool SyncState::has_answer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.answer_ != nullptr);
  return value;
}
inline void SyncState::clear_answer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.answer_ != nullptr) _impl_.answer_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::livekit::SessionDescription& SyncState::_internal_answer() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::livekit::SessionDescription* p = _impl_.answer_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::SessionDescription&>(::livekit::_SessionDescription_default_instance_);
}
inline const ::livekit::SessionDescription& SyncState::answer() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SyncState.answer)
  return _internal_answer();
}
inline void SyncState::unsafe_arena_set_allocated_answer(
    ::livekit::SessionDescription* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.answer_);
  }
  _impl_.answer_ = reinterpret_cast<::livekit::SessionDescription*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SyncState.answer)
}
inline ::livekit::SessionDescription* PROTOBUF_NULLABLE SyncState::release_answer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::SessionDescription* released = _impl_.answer_;
  _impl_.answer_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::livekit::SessionDescription* PROTOBUF_NULLABLE SyncState::unsafe_arena_release_answer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.SyncState.answer)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::SessionDescription* temp = _impl_.answer_;
  _impl_.answer_ = nullptr;
  return temp;
}
inline ::livekit::SessionDescription* PROTOBUF_NONNULL SyncState::_internal_mutable_answer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.answer_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::livekit::SessionDescription>(GetArena());
    _impl_.answer_ = reinterpret_cast<::livekit::SessionDescription*>(p);
  }
  return _impl_.answer_;
}
inline ::livekit::SessionDescription* PROTOBUF_NONNULL SyncState::mutable_answer()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::livekit::SessionDescription* _msg = _internal_mutable_answer();
  // @@protoc_insertion_point(field_mutable:livekit.SyncState.answer)
  return _msg;
}
inline void SyncState::set_allocated_answer(::livekit::SessionDescription* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.answer_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.answer_ = reinterpret_cast<::livekit::SessionDescription*>(value);
  // @@protoc_insertion_point(field_set_allocated:livekit.SyncState.answer)
}

// .livekit.UpdateSubscription subscription = 2;
inline bool SyncState::has_subscription() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.subscription_ != nullptr);
  return value;
}
inline void SyncState::clear_subscription() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.subscription_ != nullptr) _impl_.subscription_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::livekit::UpdateSubscription& SyncState::_internal_subscription() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::livekit::UpdateSubscription* p = _impl_.subscription_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::UpdateSubscription&>(::livekit::_UpdateSubscription_default_instance_);
}
inline const ::livekit::UpdateSubscription& SyncState::subscription() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SyncState.subscription)
  return _internal_subscription();
}
inline void SyncState::unsafe_arena_set_allocated_subscription(
    ::livekit::UpdateSubscription* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.subscription_);
  }
  _impl_.subscription_ = reinterpret_cast<::livekit::UpdateSubscription*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SyncState.subscription)
}
inline ::livekit::UpdateSubscription* PROTOBUF_NULLABLE SyncState::release_subscription() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::UpdateSubscription* released = _impl_.subscription_;
  _impl_.subscription_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::livekit::UpdateSubscription* PROTOBUF_NULLABLE SyncState::unsafe_arena_release_subscription() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.SyncState.subscription)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::UpdateSubscription* temp = _impl_.subscription_;
  _impl_.subscription_ = nullptr;
  return temp;
}
inline ::livekit::UpdateSubscription* PROTOBUF_NONNULL SyncState::_internal_mutable_subscription() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.subscription_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::livekit::UpdateSubscription>(GetArena());
    _impl_.subscription_ = reinterpret_cast<::livekit::UpdateSubscription*>(p);
  }
  return _impl_.subscription_;
}
inline ::livekit::UpdateSubscription* PROTOBUF_NONNULL SyncState::mutable_subscription()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::livekit::UpdateSubscription* _msg = _internal_mutable_subscription();
  // @@protoc_insertion_point(field_mutable:livekit.SyncState.subscription)
  return _msg;
}
inline void SyncState::set_allocated_subscription(::livekit::UpdateSubscription* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.subscription_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.subscription_ = reinterpret_cast<::livekit::UpdateSubscription*>(value);
  // @@protoc_insertion_point(field_set_allocated:livekit.SyncState.subscription)
}

// repeated .livekit.TrackPublishedResponse publish_tracks = 3;
inline int SyncState::_internal_publish_tracks_size() const {
  return _internal_publish_tracks().size();
}
inline int SyncState::publish_tracks_size() const {
  return _internal_publish_tracks_size();
}
inline void SyncState::clear_publish_tracks() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.publish_tracks_.Clear();
}
inline ::livekit::TrackPublishedResponse* PROTOBUF_NONNULL SyncState::mutable_publish_tracks(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.SyncState.publish_tracks)
  return _internal_mutable_publish_tracks()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::TrackPublishedResponse>* PROTOBUF_NONNULL SyncState::mutable_publish_tracks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.SyncState.publish_tracks)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_publish_tracks();
}
inline const ::livekit::TrackPublishedResponse& SyncState::publish_tracks(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SyncState.publish_tracks)
  return _internal_publish_tracks().Get(index);
}
inline ::livekit::TrackPublishedResponse* PROTOBUF_NONNULL SyncState::add_publish_tracks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::TrackPublishedResponse* _add = _internal_mutable_publish_tracks()->Add();
  // @@protoc_insertion_point(field_add:livekit.SyncState.publish_tracks)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::TrackPublishedResponse>& SyncState::publish_tracks() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.SyncState.publish_tracks)
  return _internal_publish_tracks();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::TrackPublishedResponse>&
SyncState::_internal_publish_tracks() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.publish_tracks_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::TrackPublishedResponse>* PROTOBUF_NONNULL
SyncState::_internal_mutable_publish_tracks() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.publish_tracks_;
}

// repeated .livekit.DataChannelInfo data_channels = 4;
inline int SyncState::_internal_data_channels_size() const {
  return _internal_data_channels().size();
}
inline int SyncState::data_channels_size() const {
  return _internal_data_channels_size();
}
inline void SyncState::clear_data_channels() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_channels_.Clear();
}
inline ::livekit::DataChannelInfo* PROTOBUF_NONNULL SyncState::mutable_data_channels(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.SyncState.data_channels)
  return _internal_mutable_data_channels()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::DataChannelInfo>* PROTOBUF_NONNULL SyncState::mutable_data_channels()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.SyncState.data_channels)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_data_channels();
}
inline const ::livekit::DataChannelInfo& SyncState::data_channels(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SyncState.data_channels)
  return _internal_data_channels().Get(index);
}
inline ::livekit::DataChannelInfo* PROTOBUF_NONNULL SyncState::add_data_channels()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::DataChannelInfo* _add = _internal_mutable_data_channels()->Add();
  // @@protoc_insertion_point(field_add:livekit.SyncState.data_channels)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::DataChannelInfo>& SyncState::data_channels() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.SyncState.data_channels)
  return _internal_data_channels();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::DataChannelInfo>&
SyncState::_internal_data_channels() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_channels_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::DataChannelInfo>* PROTOBUF_NONNULL
SyncState::_internal_mutable_data_channels() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.data_channels_;
}

// .livekit.SessionDescription offer = 5;
inline bool SyncState::has_offer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.offer_ != nullptr);
  return value;
}
inline void SyncState::clear_offer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.offer_ != nullptr) _impl_.offer_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::livekit::SessionDescription& SyncState::_internal_offer() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::livekit::SessionDescription* p = _impl_.offer_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::SessionDescription&>(::livekit::_SessionDescription_default_instance_);
}
inline const ::livekit::SessionDescription& SyncState::offer() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SyncState.offer)
  return _internal_offer();
}
inline void SyncState::unsafe_arena_set_allocated_offer(
    ::livekit::SessionDescription* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.offer_);
  }
  _impl_.offer_ = reinterpret_cast<::livekit::SessionDescription*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SyncState.offer)
}
inline ::livekit::SessionDescription* PROTOBUF_NULLABLE SyncState::release_offer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::livekit::SessionDescription* released = _impl_.offer_;
  _impl_.offer_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::livekit::SessionDescription* PROTOBUF_NULLABLE SyncState::unsafe_arena_release_offer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.SyncState.offer)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::livekit::SessionDescription* temp = _impl_.offer_;
  _impl_.offer_ = nullptr;
  return temp;
}
inline ::livekit::SessionDescription* PROTOBUF_NONNULL SyncState::_internal_mutable_offer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.offer_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::livekit::SessionDescription>(GetArena());
    _impl_.offer_ = reinterpret_cast<::livekit::SessionDescription*>(p);
  }
  return _impl_.offer_;
}
inline ::livekit::SessionDescription* PROTOBUF_NONNULL SyncState::mutable_offer()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::livekit::SessionDescription* _msg = _internal_mutable_offer();
  // @@protoc_insertion_point(field_mutable:livekit.SyncState.offer)
  return _msg;
}
inline void SyncState::set_allocated_offer(::livekit::SessionDescription* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.offer_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.offer_ = reinterpret_cast<::livekit::SessionDescription*>(value);
  // @@protoc_insertion_point(field_set_allocated:livekit.SyncState.offer)
}

// repeated string track_sids_disabled = 6;
inline int SyncState::_internal_track_sids_disabled_size() const {
  return _internal_track_sids_disabled().size();
}
inline int SyncState::track_sids_disabled_size() const {
  return _internal_track_sids_disabled_size();
}
inline void SyncState::clear_track_sids_disabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.track_sids_disabled_.Clear();
}
inline std::string* PROTOBUF_NONNULL SyncState::add_track_sids_disabled()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_track_sids_disabled()->Add();
  // @@protoc_insertion_point(field_add_mutable:livekit.SyncState.track_sids_disabled)
  return _s;
}
inline const std::string& SyncState::track_sids_disabled(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SyncState.track_sids_disabled)
  return _internal_track_sids_disabled().Get(index);
}
inline std::string* PROTOBUF_NONNULL SyncState::mutable_track_sids_disabled(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.SyncState.track_sids_disabled)
  return _internal_mutable_track_sids_disabled()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void SyncState::set_track_sids_disabled(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_track_sids_disabled()->Mutable(index), std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:livekit.SyncState.track_sids_disabled)
}
template <typename Arg_, typename... Args_>
inline void SyncState::add_track_sids_disabled(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_track_sids_disabled(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:livekit.SyncState.track_sids_disabled)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>& SyncState::track_sids_disabled() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.SyncState.track_sids_disabled)
  return _internal_track_sids_disabled();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* PROTOBUF_NONNULL
SyncState::mutable_track_sids_disabled() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.SyncState.track_sids_disabled)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_track_sids_disabled();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SyncState::_internal_track_sids_disabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.track_sids_disabled_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>* PROTOBUF_NONNULL
SyncState::_internal_mutable_track_sids_disabled() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.track_sids_disabled_;
}

// -------------------------------------------------------------------

// DataChannelInfo

// string label = 1;
inline void DataChannelInfo::clear_label() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.label_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DataChannelInfo::label() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.DataChannelInfo.label)
  return _internal_label();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DataChannelInfo::set_label(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.label_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.DataChannelInfo.label)
}
inline std::string* PROTOBUF_NONNULL DataChannelInfo::mutable_label()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:livekit.DataChannelInfo.label)
  return _s;
}
inline const std::string& DataChannelInfo::_internal_label() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.label_.Get();
}
inline void DataChannelInfo::_internal_set_label(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.label_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL DataChannelInfo::_internal_mutable_label() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.label_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE DataChannelInfo::release_label() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.DataChannelInfo.label)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.label_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.label_.Set("", GetArena());
  }
  return released;
}
inline void DataChannelInfo::set_allocated_label(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.label_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.label_.IsDefault()) {
    _impl_.label_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.DataChannelInfo.label)
}

// uint32 id = 2;
inline void DataChannelInfo::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t DataChannelInfo::id() const {
  // @@protoc_insertion_point(field_get:livekit.DataChannelInfo.id)
  return _internal_id();
}
inline void DataChannelInfo::set_id(::uint32_t value) {
  _internal_set_id(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:livekit.DataChannelInfo.id)
}
inline ::uint32_t DataChannelInfo::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void DataChannelInfo::_internal_set_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// .livekit.SignalTarget target = 3;
inline void DataChannelInfo::clear_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::livekit::SignalTarget DataChannelInfo::target() const {
  // @@protoc_insertion_point(field_get:livekit.DataChannelInfo.target)
  return _internal_target();
}
inline void DataChannelInfo::set_target(::livekit::SignalTarget value) {
  _internal_set_target(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:livekit.DataChannelInfo.target)
}
inline ::livekit::SignalTarget DataChannelInfo::_internal_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::livekit::SignalTarget>(_impl_.target_);
}
inline void DataChannelInfo::_internal_set_target(::livekit::SignalTarget value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_ = value;
}

// -------------------------------------------------------------------

// SimulateScenario

// int32 speaker_update = 1;
inline bool SimulateScenario::has_speaker_update() const {
  return scenario_case() == kSpeakerUpdate;
}
inline void SimulateScenario::set_has_speaker_update() {
  _impl_._oneof_case_[0] = kSpeakerUpdate;
}
inline void SimulateScenario::clear_speaker_update() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (scenario_case() == kSpeakerUpdate) {
    _impl_.scenario_.speaker_update_ = 0;
    clear_has_scenario();
  }
}
inline ::int32_t SimulateScenario::speaker_update() const {
  // @@protoc_insertion_point(field_get:livekit.SimulateScenario.speaker_update)
  return _internal_speaker_update();
}
inline void SimulateScenario::set_speaker_update(::int32_t value) {
  if (scenario_case() != kSpeakerUpdate) {
    clear_scenario();
    set_has_speaker_update();
  }
  _impl_.scenario_.speaker_update_ = value;
  // @@protoc_insertion_point(field_set:livekit.SimulateScenario.speaker_update)
}
inline ::int32_t SimulateScenario::_internal_speaker_update() const {
  if (scenario_case() == kSpeakerUpdate) {
    return _impl_.scenario_.speaker_update_;
  }
  return 0;
}

// bool node_failure = 2;
inline bool SimulateScenario::has_node_failure() const {
  return scenario_case() == kNodeFailure;
}
inline void SimulateScenario::set_has_node_failure() {
  _impl_._oneof_case_[0] = kNodeFailure;
}
inline void SimulateScenario::clear_node_failure() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (scenario_case() == kNodeFailure) {
    _impl_.scenario_.node_failure_ = false;
    clear_has_scenario();
  }
}
inline bool SimulateScenario::node_failure() const {
  // @@protoc_insertion_point(field_get:livekit.SimulateScenario.node_failure)
  return _internal_node_failure();
}
inline void SimulateScenario::set_node_failure(bool value) {
  if (scenario_case() != kNodeFailure) {
    clear_scenario();
    set_has_node_failure();
  }
  _impl_.scenario_.node_failure_ = value;
  // @@protoc_insertion_point(field_set:livekit.SimulateScenario.node_failure)
}
inline bool SimulateScenario::_internal_node_failure() const {
  if (scenario_case() == kNodeFailure) {
    return _impl_.scenario_.node_failure_;
  }
  return false;
}

// bool migration = 3;
inline bool SimulateScenario::has_migration() const {
  return scenario_case() == kMigration;
}
inline void SimulateScenario::set_has_migration() {
  _impl_._oneof_case_[0] = kMigration;
}
inline void SimulateScenario::clear_migration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (scenario_case() == kMigration) {
    _impl_.scenario_.migration_ = false;
    clear_has_scenario();
  }
}
inline bool SimulateScenario::migration() const {
  // @@protoc_insertion_point(field_get:livekit.SimulateScenario.migration)
  return _internal_migration();
}
inline void SimulateScenario::set_migration(bool value) {
  if (scenario_case() != kMigration) {
    clear_scenario();
    set_has_migration();
  }
  _impl_.scenario_.migration_ = value;
  // @@protoc_insertion_point(field_set:livekit.SimulateScenario.migration)
}
inline bool SimulateScenario::_internal_migration() const {
  if (scenario_case() == kMigration) {
    return _impl_.scenario_.migration_;
  }
  return false;
}

// bool server_leave = 4;
inline bool SimulateScenario::has_server_leave() const {
  return scenario_case() == kServerLeave;
}
inline void SimulateScenario::set_has_server_leave() {
  _impl_._oneof_case_[0] = kServerLeave;
}
inline void SimulateScenario::clear_server_leave() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (scenario_case() == kServerLeave) {
    _impl_.scenario_.server_leave_ = false;
    clear_has_scenario();
  }
}
inline bool SimulateScenario::server_leave() const {
  // @@protoc_insertion_point(field_get:livekit.SimulateScenario.server_leave)
  return _internal_server_leave();
}
inline void SimulateScenario::set_server_leave(bool value) {
  if (scenario_case() != kServerLeave) {
    clear_scenario();
    set_has_server_leave();
  }
  _impl_.scenario_.server_leave_ = value;
  // @@protoc_insertion_point(field_set:livekit.SimulateScenario.server_leave)
}
inline bool SimulateScenario::_internal_server_leave() const {
  if (scenario_case() == kServerLeave) {
    return _impl_.scenario_.server_leave_;
  }
  return false;
}

// .livekit.CandidateProtocol switch_candidate_protocol = 5;
inline bool SimulateScenario::has_switch_candidate_protocol() const {
  return scenario_case() == kSwitchCandidateProtocol;
}
inline void SimulateScenario::set_has_switch_candidate_protocol() {
  _impl_._oneof_case_[0] = kSwitchCandidateProtocol;
}
inline void SimulateScenario::clear_switch_candidate_protocol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (scenario_case() == kSwitchCandidateProtocol) {
    _impl_.scenario_.switch_candidate_protocol_ = 0;
    clear_has_scenario();
  }
}
inline ::livekit::CandidateProtocol SimulateScenario::switch_candidate_protocol() const {
  // @@protoc_insertion_point(field_get:livekit.SimulateScenario.switch_candidate_protocol)
  return _internal_switch_candidate_protocol();
}
inline void SimulateScenario::set_switch_candidate_protocol(::livekit::CandidateProtocol value) {
  if (scenario_case() != kSwitchCandidateProtocol) {
    clear_scenario();
    set_has_switch_candidate_protocol();
  }
  _impl_.scenario_.switch_candidate_protocol_ = value;
  // @@protoc_insertion_point(field_set:livekit.SimulateScenario.switch_candidate_protocol)
}
inline ::livekit::CandidateProtocol SimulateScenario::_internal_switch_candidate_protocol() const {
  if (scenario_case() == kSwitchCandidateProtocol) {
    return static_cast<::livekit::CandidateProtocol>(_impl_.scenario_.switch_candidate_protocol_);
  }
  return static_cast<::livekit::CandidateProtocol>(0);
}

// int64 subscriber_bandwidth = 6;
inline bool SimulateScenario::has_subscriber_bandwidth() const {
  return scenario_case() == kSubscriberBandwidth;
}
inline void SimulateScenario::set_has_subscriber_bandwidth() {
  _impl_._oneof_case_[0] = kSubscriberBandwidth;
}
inline void SimulateScenario::clear_subscriber_bandwidth() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (scenario_case() == kSubscriberBandwidth) {
    _impl_.scenario_.subscriber_bandwidth_ = ::int64_t{0};
    clear_has_scenario();
  }
}
inline ::int64_t SimulateScenario::subscriber_bandwidth() const {
  // @@protoc_insertion_point(field_get:livekit.SimulateScenario.subscriber_bandwidth)
  return _internal_subscriber_bandwidth();
}
inline void SimulateScenario::set_subscriber_bandwidth(::int64_t value) {
  if (scenario_case() != kSubscriberBandwidth) {
    clear_scenario();
    set_has_subscriber_bandwidth();
  }
  _impl_.scenario_.subscriber_bandwidth_ = value;
  // @@protoc_insertion_point(field_set:livekit.SimulateScenario.subscriber_bandwidth)
}
inline ::int64_t SimulateScenario::_internal_subscriber_bandwidth() const {
  if (scenario_case() == kSubscriberBandwidth) {
    return _impl_.scenario_.subscriber_bandwidth_;
  }
  return ::int64_t{0};
}

// bool disconnect_signal_on_resume = 7;
inline bool SimulateScenario::has_disconnect_signal_on_resume() const {
  return scenario_case() == kDisconnectSignalOnResume;
}
inline void SimulateScenario::set_has_disconnect_signal_on_resume() {
  _impl_._oneof_case_[0] = kDisconnectSignalOnResume;
}
inline void SimulateScenario::clear_disconnect_signal_on_resume() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (scenario_case() == kDisconnectSignalOnResume) {
    _impl_.scenario_.disconnect_signal_on_resume_ = false;
    clear_has_scenario();
  }
}
inline bool SimulateScenario::disconnect_signal_on_resume() const {
  // @@protoc_insertion_point(field_get:livekit.SimulateScenario.disconnect_signal_on_resume)
  return _internal_disconnect_signal_on_resume();
}
inline void SimulateScenario::set_disconnect_signal_on_resume(bool value) {
  if (scenario_case() != kDisconnectSignalOnResume) {
    clear_scenario();
    set_has_disconnect_signal_on_resume();
  }
  _impl_.scenario_.disconnect_signal_on_resume_ = value;
  // @@protoc_insertion_point(field_set:livekit.SimulateScenario.disconnect_signal_on_resume)
}
inline bool SimulateScenario::_internal_disconnect_signal_on_resume() const {
  if (scenario_case() == kDisconnectSignalOnResume) {
    return _impl_.scenario_.disconnect_signal_on_resume_;
  }
  return false;
}

// bool disconnect_signal_on_resume_no_messages = 8;
inline bool SimulateScenario::has_disconnect_signal_on_resume_no_messages() const {
  return scenario_case() == kDisconnectSignalOnResumeNoMessages;
}
inline void SimulateScenario::set_has_disconnect_signal_on_resume_no_messages() {
  _impl_._oneof_case_[0] = kDisconnectSignalOnResumeNoMessages;
}
inline void SimulateScenario::clear_disconnect_signal_on_resume_no_messages() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (scenario_case() == kDisconnectSignalOnResumeNoMessages) {
    _impl_.scenario_.disconnect_signal_on_resume_no_messages_ = false;
    clear_has_scenario();
  }
}
inline bool SimulateScenario::disconnect_signal_on_resume_no_messages() const {
  // @@protoc_insertion_point(field_get:livekit.SimulateScenario.disconnect_signal_on_resume_no_messages)
  return _internal_disconnect_signal_on_resume_no_messages();
}
inline void SimulateScenario::set_disconnect_signal_on_resume_no_messages(bool value) {
  if (scenario_case() != kDisconnectSignalOnResumeNoMessages) {
    clear_scenario();
    set_has_disconnect_signal_on_resume_no_messages();
  }
  _impl_.scenario_.disconnect_signal_on_resume_no_messages_ = value;
  // @@protoc_insertion_point(field_set:livekit.SimulateScenario.disconnect_signal_on_resume_no_messages)
}
inline bool SimulateScenario::_internal_disconnect_signal_on_resume_no_messages() const {
  if (scenario_case() == kDisconnectSignalOnResumeNoMessages) {
    return _impl_.scenario_.disconnect_signal_on_resume_no_messages_;
  }
  return false;
}

// bool leave_request_full_reconnect = 9;
inline bool SimulateScenario::has_leave_request_full_reconnect() const {
  return scenario_case() == kLeaveRequestFullReconnect;
}
inline void SimulateScenario::set_has_leave_request_full_reconnect() {
  _impl_._oneof_case_[0] = kLeaveRequestFullReconnect;
}
inline void SimulateScenario::clear_leave_request_full_reconnect() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (scenario_case() == kLeaveRequestFullReconnect) {
    _impl_.scenario_.leave_request_full_reconnect_ = false;
    clear_has_scenario();
  }
}
inline bool SimulateScenario::leave_request_full_reconnect() const {
  // @@protoc_insertion_point(field_get:livekit.SimulateScenario.leave_request_full_reconnect)
  return _internal_leave_request_full_reconnect();
}
inline void SimulateScenario::set_leave_request_full_reconnect(bool value) {
  if (scenario_case() != kLeaveRequestFullReconnect) {
    clear_scenario();
    set_has_leave_request_full_reconnect();
  }
  _impl_.scenario_.leave_request_full_reconnect_ = value;
  // @@protoc_insertion_point(field_set:livekit.SimulateScenario.leave_request_full_reconnect)
}
inline bool SimulateScenario::_internal_leave_request_full_reconnect() const {
  if (scenario_case() == kLeaveRequestFullReconnect) {
    return _impl_.scenario_.leave_request_full_reconnect_;
  }
  return false;
}

inline bool SimulateScenario::has_scenario() const {
  return scenario_case() != SCENARIO_NOT_SET;
}
inline void SimulateScenario::clear_has_scenario() {
  _impl_._oneof_case_[0] = SCENARIO_NOT_SET;
}
inline SimulateScenario::ScenarioCase SimulateScenario::scenario_case() const {
  return SimulateScenario::ScenarioCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Ping

// int64 timestamp = 1;
inline void Ping::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t Ping::timestamp() const {
  // @@protoc_insertion_point(field_get:livekit.Ping.timestamp)
  return _internal_timestamp();
}
inline void Ping::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:livekit.Ping.timestamp)
}
inline ::int64_t Ping::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_;
}
inline void Ping::_internal_set_timestamp(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = value;
}

// int64 rtt = 2;
inline void Ping::clear_rtt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rtt_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t Ping::rtt() const {
  // @@protoc_insertion_point(field_get:livekit.Ping.rtt)
  return _internal_rtt();
}
inline void Ping::set_rtt(::int64_t value) {
  _internal_set_rtt(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:livekit.Ping.rtt)
}
inline ::int64_t Ping::_internal_rtt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rtt_;
}
inline void Ping::_internal_set_rtt(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rtt_ = value;
}

// -------------------------------------------------------------------

// Pong

// int64 last_ping_timestamp = 1;
inline void Pong::clear_last_ping_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_ping_timestamp_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t Pong::last_ping_timestamp() const {
  // @@protoc_insertion_point(field_get:livekit.Pong.last_ping_timestamp)
  return _internal_last_ping_timestamp();
}
inline void Pong::set_last_ping_timestamp(::int64_t value) {
  _internal_set_last_ping_timestamp(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:livekit.Pong.last_ping_timestamp)
}
inline ::int64_t Pong::_internal_last_ping_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.last_ping_timestamp_;
}
inline void Pong::_internal_set_last_ping_timestamp(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_ping_timestamp_ = value;
}

// int64 timestamp = 2;
inline void Pong::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t Pong::timestamp() const {
  // @@protoc_insertion_point(field_get:livekit.Pong.timestamp)
  return _internal_timestamp();
}
inline void Pong::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:livekit.Pong.timestamp)
}
inline ::int64_t Pong::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_;
}
inline void Pong::_internal_set_timestamp(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = value;
}

// -------------------------------------------------------------------

// RegionSettings

// repeated .livekit.RegionInfo regions = 1;
inline int RegionSettings::_internal_regions_size() const {
  return _internal_regions().size();
}
inline int RegionSettings::regions_size() const {
  return _internal_regions_size();
}
inline void RegionSettings::clear_regions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.regions_.Clear();
}
inline ::livekit::RegionInfo* PROTOBUF_NONNULL RegionSettings::mutable_regions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.RegionSettings.regions)
  return _internal_mutable_regions()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::RegionInfo>* PROTOBUF_NONNULL RegionSettings::mutable_regions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.RegionSettings.regions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_regions();
}
inline const ::livekit::RegionInfo& RegionSettings::regions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.RegionSettings.regions)
  return _internal_regions().Get(index);
}
inline ::livekit::RegionInfo* PROTOBUF_NONNULL RegionSettings::add_regions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::RegionInfo* _add = _internal_mutable_regions()->Add();
  // @@protoc_insertion_point(field_add:livekit.RegionSettings.regions)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::RegionInfo>& RegionSettings::regions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.RegionSettings.regions)
  return _internal_regions();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::RegionInfo>&
RegionSettings::_internal_regions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.regions_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::RegionInfo>* PROTOBUF_NONNULL
RegionSettings::_internal_mutable_regions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.regions_;
}

// -------------------------------------------------------------------

// RegionInfo

// string region = 1;
inline void RegionInfo::clear_region() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.region_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RegionInfo::region() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.RegionInfo.region)
  return _internal_region();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RegionInfo::set_region(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.region_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.RegionInfo.region)
}
inline std::string* PROTOBUF_NONNULL RegionInfo::mutable_region()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:livekit.RegionInfo.region)
  return _s;
}
inline const std::string& RegionInfo::_internal_region() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.region_.Get();
}
inline void RegionInfo::_internal_set_region(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.region_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL RegionInfo::_internal_mutable_region() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.region_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE RegionInfo::release_region() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.RegionInfo.region)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.region_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.region_.Set("", GetArena());
  }
  return released;
}
inline void RegionInfo::set_allocated_region(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.region_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.region_.IsDefault()) {
    _impl_.region_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.RegionInfo.region)
}

// string url = 2;
inline void RegionInfo::clear_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RegionInfo::url() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.RegionInfo.url)
  return _internal_url();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RegionInfo::set_url(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.url_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.RegionInfo.url)
}
inline std::string* PROTOBUF_NONNULL RegionInfo::mutable_url()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:livekit.RegionInfo.url)
  return _s;
}
inline const std::string& RegionInfo::_internal_url() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.url_.Get();
}
inline void RegionInfo::_internal_set_url(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.url_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL RegionInfo::_internal_mutable_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.url_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE RegionInfo::release_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.RegionInfo.url)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.url_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.url_.Set("", GetArena());
  }
  return released;
}
inline void RegionInfo::set_allocated_url(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.url_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.RegionInfo.url)
}

// int64 distance = 3;
inline void RegionInfo::clear_distance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.distance_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t RegionInfo::distance() const {
  // @@protoc_insertion_point(field_get:livekit.RegionInfo.distance)
  return _internal_distance();
}
inline void RegionInfo::set_distance(::int64_t value) {
  _internal_set_distance(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:livekit.RegionInfo.distance)
}
inline ::int64_t RegionInfo::_internal_distance() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.distance_;
}
inline void RegionInfo::_internal_set_distance(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.distance_ = value;
}

// -------------------------------------------------------------------

// SubscriptionResponse

// string track_sid = 1;
inline void SubscriptionResponse::clear_track_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.track_sid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SubscriptionResponse::track_sid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SubscriptionResponse.track_sid)
  return _internal_track_sid();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SubscriptionResponse::set_track_sid(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.track_sid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.SubscriptionResponse.track_sid)
}
inline std::string* PROTOBUF_NONNULL SubscriptionResponse::mutable_track_sid()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_track_sid();
  // @@protoc_insertion_point(field_mutable:livekit.SubscriptionResponse.track_sid)
  return _s;
}
inline const std::string& SubscriptionResponse::_internal_track_sid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.track_sid_.Get();
}
inline void SubscriptionResponse::_internal_set_track_sid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.track_sid_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL SubscriptionResponse::_internal_mutable_track_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.track_sid_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE SubscriptionResponse::release_track_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.SubscriptionResponse.track_sid)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.track_sid_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.track_sid_.Set("", GetArena());
  }
  return released;
}
inline void SubscriptionResponse::set_allocated_track_sid(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.track_sid_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.track_sid_.IsDefault()) {
    _impl_.track_sid_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.SubscriptionResponse.track_sid)
}

// .livekit.SubscriptionError err = 2;
inline void SubscriptionResponse::clear_err() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.err_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::livekit::SubscriptionError SubscriptionResponse::err() const {
  // @@protoc_insertion_point(field_get:livekit.SubscriptionResponse.err)
  return _internal_err();
}
inline void SubscriptionResponse::set_err(::livekit::SubscriptionError value) {
  _internal_set_err(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:livekit.SubscriptionResponse.err)
}
inline ::livekit::SubscriptionError SubscriptionResponse::_internal_err() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::livekit::SubscriptionError>(_impl_.err_);
}
inline void SubscriptionResponse::_internal_set_err(::livekit::SubscriptionError value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.err_ = value;
}

// -------------------------------------------------------------------

// RequestResponse

// uint32 request_id = 1;
inline void RequestResponse::clear_request_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t RequestResponse::request_id() const {
  // @@protoc_insertion_point(field_get:livekit.RequestResponse.request_id)
  return _internal_request_id();
}
inline void RequestResponse::set_request_id(::uint32_t value) {
  _internal_set_request_id(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:livekit.RequestResponse.request_id)
}
inline ::uint32_t RequestResponse::_internal_request_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.request_id_;
}
inline void RequestResponse::_internal_set_request_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_id_ = value;
}

// .livekit.RequestResponse.Reason reason = 2;
inline void RequestResponse::clear_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::livekit::RequestResponse_Reason RequestResponse::reason() const {
  // @@protoc_insertion_point(field_get:livekit.RequestResponse.reason)
  return _internal_reason();
}
inline void RequestResponse::set_reason(::livekit::RequestResponse_Reason value) {
  _internal_set_reason(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:livekit.RequestResponse.reason)
}
inline ::livekit::RequestResponse_Reason RequestResponse::_internal_reason() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::livekit::RequestResponse_Reason>(_impl_.reason_);
}
inline void RequestResponse::_internal_set_reason(::livekit::RequestResponse_Reason value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_ = value;
}

// string message = 3;
inline void RequestResponse::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RequestResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.RequestResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RequestResponse::set_message(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.RequestResponse.message)
}
inline std::string* PROTOBUF_NONNULL RequestResponse::mutable_message()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:livekit.RequestResponse.message)
  return _s;
}
inline const std::string& RequestResponse::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_.Get();
}
inline void RequestResponse::_internal_set_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL RequestResponse::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE RequestResponse::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.RequestResponse.message)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.message_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.message_.Set("", GetArena());
  }
  return released;
}
inline void RequestResponse::set_allocated_message(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.RequestResponse.message)
}

// -------------------------------------------------------------------

// TrackSubscribed

// string track_sid = 1;
inline void TrackSubscribed::clear_track_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.track_sid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TrackSubscribed::track_sid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.TrackSubscribed.track_sid)
  return _internal_track_sid();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void TrackSubscribed::set_track_sid(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.track_sid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.TrackSubscribed.track_sid)
}
inline std::string* PROTOBUF_NONNULL TrackSubscribed::mutable_track_sid()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_track_sid();
  // @@protoc_insertion_point(field_mutable:livekit.TrackSubscribed.track_sid)
  return _s;
}
inline const std::string& TrackSubscribed::_internal_track_sid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.track_sid_.Get();
}
inline void TrackSubscribed::_internal_set_track_sid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.track_sid_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL TrackSubscribed::_internal_mutable_track_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.track_sid_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE TrackSubscribed::release_track_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.TrackSubscribed.track_sid)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.track_sid_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.track_sid_.Set("", GetArena());
  }
  return released;
}
inline void TrackSubscribed::set_allocated_track_sid(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.track_sid_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.track_sid_.IsDefault()) {
    _impl_.track_sid_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.TrackSubscribed.track_sid)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace livekit


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::livekit::LeaveRequest_Action> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::livekit::LeaveRequest_Action>() {
  return ::livekit::LeaveRequest_Action_descriptor();
}
template <>
struct is_proto_enum<::livekit::RequestResponse_Reason> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::livekit::RequestResponse_Reason>() {
  return ::livekit::RequestResponse_Reason_descriptor();
}
template <>
struct is_proto_enum<::livekit::SignalTarget> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::livekit::SignalTarget>() {
  return ::livekit::SignalTarget_descriptor();
}
template <>
struct is_proto_enum<::livekit::StreamState> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::livekit::StreamState>() {
  return ::livekit::StreamState_descriptor();
}
template <>
struct is_proto_enum<::livekit::CandidateProtocol> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::livekit::CandidateProtocol>() {
  return ::livekit::CandidateProtocol_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // livekit_5frtc_2eproto_2epb_2eh
