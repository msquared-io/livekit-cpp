// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: livekit_agent.proto
// Protobuf C++ Version: 6.30.1

#ifndef livekit_5fagent_2eproto_2epb_2eh
#define livekit_5fagent_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6030001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_type_handler.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "livekit_models.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_livekit_5fagent_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_livekit_5fagent_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_livekit_5fagent_2eproto;
}  // extern "C"
namespace livekit {
enum JobStatus : int;
extern const uint32_t JobStatus_internal_data_[];
enum JobType : int;
extern const uint32_t JobType_internal_data_[];
enum WorkerStatus : int;
extern const uint32_t WorkerStatus_internal_data_[];
class AvailabilityRequest;
struct AvailabilityRequestDefaultTypeInternal;
extern AvailabilityRequestDefaultTypeInternal _AvailabilityRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull AvailabilityRequest_class_data_;
class AvailabilityResponse;
struct AvailabilityResponseDefaultTypeInternal;
extern AvailabilityResponseDefaultTypeInternal _AvailabilityResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull AvailabilityResponse_class_data_;
class AvailabilityResponse_ParticipantAttributesEntry_DoNotUse;
struct AvailabilityResponse_ParticipantAttributesEntry_DoNotUseDefaultTypeInternal;
extern AvailabilityResponse_ParticipantAttributesEntry_DoNotUseDefaultTypeInternal _AvailabilityResponse_ParticipantAttributesEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull AvailabilityResponse_ParticipantAttributesEntry_DoNotUse_class_data_;
class Job;
struct JobDefaultTypeInternal;
extern JobDefaultTypeInternal _Job_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Job_class_data_;
class JobAssignment;
struct JobAssignmentDefaultTypeInternal;
extern JobAssignmentDefaultTypeInternal _JobAssignment_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull JobAssignment_class_data_;
class JobState;
struct JobStateDefaultTypeInternal;
extern JobStateDefaultTypeInternal _JobState_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull JobState_class_data_;
class JobTermination;
struct JobTerminationDefaultTypeInternal;
extern JobTerminationDefaultTypeInternal _JobTermination_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull JobTermination_class_data_;
class MigrateJobRequest;
struct MigrateJobRequestDefaultTypeInternal;
extern MigrateJobRequestDefaultTypeInternal _MigrateJobRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MigrateJobRequest_class_data_;
class RegisterWorkerRequest;
struct RegisterWorkerRequestDefaultTypeInternal;
extern RegisterWorkerRequestDefaultTypeInternal _RegisterWorkerRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RegisterWorkerRequest_class_data_;
class RegisterWorkerResponse;
struct RegisterWorkerResponseDefaultTypeInternal;
extern RegisterWorkerResponseDefaultTypeInternal _RegisterWorkerResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RegisterWorkerResponse_class_data_;
class ServerMessage;
struct ServerMessageDefaultTypeInternal;
extern ServerMessageDefaultTypeInternal _ServerMessage_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ServerMessage_class_data_;
class SimulateJobRequest;
struct SimulateJobRequestDefaultTypeInternal;
extern SimulateJobRequestDefaultTypeInternal _SimulateJobRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SimulateJobRequest_class_data_;
class UpdateJobStatus;
struct UpdateJobStatusDefaultTypeInternal;
extern UpdateJobStatusDefaultTypeInternal _UpdateJobStatus_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UpdateJobStatus_class_data_;
class UpdateWorkerStatus;
struct UpdateWorkerStatusDefaultTypeInternal;
extern UpdateWorkerStatusDefaultTypeInternal _UpdateWorkerStatus_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UpdateWorkerStatus_class_data_;
class WorkerMessage;
struct WorkerMessageDefaultTypeInternal;
extern WorkerMessageDefaultTypeInternal _WorkerMessage_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull WorkerMessage_class_data_;
class WorkerPing;
struct WorkerPingDefaultTypeInternal;
extern WorkerPingDefaultTypeInternal _WorkerPing_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull WorkerPing_class_data_;
class WorkerPong;
struct WorkerPongDefaultTypeInternal;
extern WorkerPongDefaultTypeInternal _WorkerPong_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull WorkerPong_class_data_;
}  // namespace livekit
namespace google {
namespace protobuf {
template <>
internal::EnumTraitsT<::livekit::JobStatus_internal_data_>
    internal::EnumTraitsImpl::value<::livekit::JobStatus>;
template <>
internal::EnumTraitsT<::livekit::JobType_internal_data_>
    internal::EnumTraitsImpl::value<::livekit::JobType>;
template <>
internal::EnumTraitsT<::livekit::WorkerStatus_internal_data_>
    internal::EnumTraitsImpl::value<::livekit::WorkerStatus>;
}  // namespace protobuf
}  // namespace google

namespace livekit {
enum JobType : int {
  JT_ROOM = 0,
  JT_PUBLISHER = 1,
  JT_PARTICIPANT = 2,
  JobType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  JobType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t JobType_internal_data_[];
inline constexpr JobType JobType_MIN =
    static_cast<JobType>(0);
inline constexpr JobType JobType_MAX =
    static_cast<JobType>(2);
inline bool JobType_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int JobType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL JobType_descriptor();
template <typename T>
const std::string& JobType_Name(T value) {
  static_assert(std::is_same<T, JobType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to JobType_Name().");
  return JobType_Name(static_cast<JobType>(value));
}
template <>
inline const std::string& JobType_Name(JobType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<JobType_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool JobType_Parse(
    absl::string_view name, JobType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<JobType>(JobType_descriptor(), name,
                                           value);
}
enum WorkerStatus : int {
  WS_AVAILABLE = 0,
  WS_FULL = 1,
  WorkerStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  WorkerStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t WorkerStatus_internal_data_[];
inline constexpr WorkerStatus WorkerStatus_MIN =
    static_cast<WorkerStatus>(0);
inline constexpr WorkerStatus WorkerStatus_MAX =
    static_cast<WorkerStatus>(1);
inline bool WorkerStatus_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int WorkerStatus_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL WorkerStatus_descriptor();
template <typename T>
const std::string& WorkerStatus_Name(T value) {
  static_assert(std::is_same<T, WorkerStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to WorkerStatus_Name().");
  return WorkerStatus_Name(static_cast<WorkerStatus>(value));
}
template <>
inline const std::string& WorkerStatus_Name(WorkerStatus value) {
  return ::google::protobuf::internal::NameOfDenseEnum<WorkerStatus_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool WorkerStatus_Parse(
    absl::string_view name, WorkerStatus* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<WorkerStatus>(WorkerStatus_descriptor(), name,
                                           value);
}
enum JobStatus : int {
  JS_PENDING = 0,
  JS_RUNNING = 1,
  JS_SUCCESS = 2,
  JS_FAILED = 3,
  JobStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  JobStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t JobStatus_internal_data_[];
inline constexpr JobStatus JobStatus_MIN =
    static_cast<JobStatus>(0);
inline constexpr JobStatus JobStatus_MAX =
    static_cast<JobStatus>(3);
inline bool JobStatus_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int JobStatus_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL JobStatus_descriptor();
template <typename T>
const std::string& JobStatus_Name(T value) {
  static_assert(std::is_same<T, JobStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to JobStatus_Name().");
  return JobStatus_Name(static_cast<JobStatus>(value));
}
template <>
inline const std::string& JobStatus_Name(JobStatus value) {
  return ::google::protobuf::internal::NameOfDenseEnum<JobStatus_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool JobStatus_Parse(
    absl::string_view name, JobStatus* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<JobStatus>(JobStatus_descriptor(), name,
                                           value);
}

// ===================================================================


// -------------------------------------------------------------------

class WorkerPong final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.WorkerPong) */ {
 public:
  inline WorkerPong() : WorkerPong(nullptr) {}
  ~WorkerPong() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(WorkerPong* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(WorkerPong));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WorkerPong(::google::protobuf::internal::ConstantInitialized);

  inline WorkerPong(const WorkerPong& from) : WorkerPong(nullptr, from) {}
  inline WorkerPong(WorkerPong&& from) noexcept
      : WorkerPong(nullptr, std::move(from)) {}
  inline WorkerPong& operator=(const WorkerPong& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkerPong& operator=(WorkerPong&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkerPong& default_instance() {
    return *reinterpret_cast<const WorkerPong*>(
        &_WorkerPong_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(WorkerPong& a, WorkerPong& b) { a.Swap(&b); }
  inline void Swap(WorkerPong* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkerPong* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkerPong* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<WorkerPong>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WorkerPong& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const WorkerPong& from) { WorkerPong::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(WorkerPong* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.WorkerPong"; }

 protected:
  explicit WorkerPong(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  WorkerPong(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const WorkerPong& from);
  WorkerPong(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, WorkerPong&& from) noexcept
      : WorkerPong(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLastTimestampFieldNumber = 1,
    kTimestampFieldNumber = 2,
  };
  // int64 last_timestamp = 1;
  void clear_last_timestamp() ;
  ::int64_t last_timestamp() const;
  void set_last_timestamp(::int64_t value);

  private:
  ::int64_t _internal_last_timestamp() const;
  void _internal_set_last_timestamp(::int64_t value);

  public:
  // int64 timestamp = 2;
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.WorkerPong)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const WorkerPong& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t last_timestamp_;
    ::int64_t timestamp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fagent_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull WorkerPong_class_data_;
// -------------------------------------------------------------------

class WorkerPing final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.WorkerPing) */ {
 public:
  inline WorkerPing() : WorkerPing(nullptr) {}
  ~WorkerPing() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(WorkerPing* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(WorkerPing));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WorkerPing(::google::protobuf::internal::ConstantInitialized);

  inline WorkerPing(const WorkerPing& from) : WorkerPing(nullptr, from) {}
  inline WorkerPing(WorkerPing&& from) noexcept
      : WorkerPing(nullptr, std::move(from)) {}
  inline WorkerPing& operator=(const WorkerPing& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkerPing& operator=(WorkerPing&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkerPing& default_instance() {
    return *reinterpret_cast<const WorkerPing*>(
        &_WorkerPing_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(WorkerPing& a, WorkerPing& b) { a.Swap(&b); }
  inline void Swap(WorkerPing* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkerPing* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkerPing* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<WorkerPing>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WorkerPing& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const WorkerPing& from) { WorkerPing::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(WorkerPing* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.WorkerPing"; }

 protected:
  explicit WorkerPing(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  WorkerPing(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const WorkerPing& from);
  WorkerPing(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, WorkerPing&& from) noexcept
      : WorkerPing(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTimestampFieldNumber = 1,
  };
  // int64 timestamp = 1;
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.WorkerPing)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const WorkerPing& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t timestamp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fagent_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull WorkerPing_class_data_;
// -------------------------------------------------------------------

class UpdateWorkerStatus final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.UpdateWorkerStatus) */ {
 public:
  inline UpdateWorkerStatus() : UpdateWorkerStatus(nullptr) {}
  ~UpdateWorkerStatus() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateWorkerStatus* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateWorkerStatus));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateWorkerStatus(::google::protobuf::internal::ConstantInitialized);

  inline UpdateWorkerStatus(const UpdateWorkerStatus& from) : UpdateWorkerStatus(nullptr, from) {}
  inline UpdateWorkerStatus(UpdateWorkerStatus&& from) noexcept
      : UpdateWorkerStatus(nullptr, std::move(from)) {}
  inline UpdateWorkerStatus& operator=(const UpdateWorkerStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateWorkerStatus& operator=(UpdateWorkerStatus&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateWorkerStatus& default_instance() {
    return *reinterpret_cast<const UpdateWorkerStatus*>(
        &_UpdateWorkerStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(UpdateWorkerStatus& a, UpdateWorkerStatus& b) { a.Swap(&b); }
  inline void Swap(UpdateWorkerStatus* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateWorkerStatus* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateWorkerStatus* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateWorkerStatus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateWorkerStatus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateWorkerStatus& from) { UpdateWorkerStatus::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateWorkerStatus* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.UpdateWorkerStatus"; }

 protected:
  explicit UpdateWorkerStatus(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UpdateWorkerStatus(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UpdateWorkerStatus& from);
  UpdateWorkerStatus(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UpdateWorkerStatus&& from) noexcept
      : UpdateWorkerStatus(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStatusFieldNumber = 1,
    kLoadFieldNumber = 3,
    kJobCountFieldNumber = 4,
  };
  // optional .livekit.WorkerStatus status = 1;
  bool has_status() const;
  void clear_status() ;
  ::livekit::WorkerStatus status() const;
  void set_status(::livekit::WorkerStatus value);

  private:
  ::livekit::WorkerStatus _internal_status() const;
  void _internal_set_status(::livekit::WorkerStatus value);

  public:
  // float load = 3;
  void clear_load() ;
  float load() const;
  void set_load(float value);

  private:
  float _internal_load() const;
  void _internal_set_load(float value);

  public:
  // uint32 job_count = 4;
  void clear_job_count() ;
  ::uint32_t job_count() const;
  void set_job_count(::uint32_t value);

  private:
  ::uint32_t _internal_job_count() const;
  void _internal_set_job_count(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.UpdateWorkerStatus)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UpdateWorkerStatus& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int status_;
    float load_;
    ::uint32_t job_count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fagent_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UpdateWorkerStatus_class_data_;
// -------------------------------------------------------------------

class UpdateJobStatus final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.UpdateJobStatus) */ {
 public:
  inline UpdateJobStatus() : UpdateJobStatus(nullptr) {}
  ~UpdateJobStatus() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateJobStatus* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateJobStatus));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateJobStatus(::google::protobuf::internal::ConstantInitialized);

  inline UpdateJobStatus(const UpdateJobStatus& from) : UpdateJobStatus(nullptr, from) {}
  inline UpdateJobStatus(UpdateJobStatus&& from) noexcept
      : UpdateJobStatus(nullptr, std::move(from)) {}
  inline UpdateJobStatus& operator=(const UpdateJobStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateJobStatus& operator=(UpdateJobStatus&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateJobStatus& default_instance() {
    return *reinterpret_cast<const UpdateJobStatus*>(
        &_UpdateJobStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(UpdateJobStatus& a, UpdateJobStatus& b) { a.Swap(&b); }
  inline void Swap(UpdateJobStatus* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateJobStatus* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateJobStatus* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateJobStatus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateJobStatus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateJobStatus& from) { UpdateJobStatus::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateJobStatus* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.UpdateJobStatus"; }

 protected:
  explicit UpdateJobStatus(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UpdateJobStatus(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UpdateJobStatus& from);
  UpdateJobStatus(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UpdateJobStatus&& from) noexcept
      : UpdateJobStatus(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kJobIdFieldNumber = 1,
    kErrorFieldNumber = 3,
    kStatusFieldNumber = 2,
  };
  // string job_id = 1;
  void clear_job_id() ;
  const std::string& job_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_job_id(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_job_id();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_job_id();
  void set_allocated_job_id(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_job_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_job_id(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_job_id();

  public:
  // string error = 3;
  void clear_error() ;
  const std::string& error() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_error();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_error();
  void set_allocated_error(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_error() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_error();

  public:
  // .livekit.JobStatus status = 2;
  void clear_status() ;
  ::livekit::JobStatus status() const;
  void set_status(::livekit::JobStatus value);

  private:
  ::livekit::JobStatus _internal_status() const;
  void _internal_set_status(::livekit::JobStatus value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.UpdateJobStatus)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 43,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UpdateJobStatus& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr job_id_;
    ::google::protobuf::internal::ArenaStringPtr error_;
    int status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fagent_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UpdateJobStatus_class_data_;
// -------------------------------------------------------------------

class MigrateJobRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.MigrateJobRequest) */ {
 public:
  inline MigrateJobRequest() : MigrateJobRequest(nullptr) {}
  ~MigrateJobRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MigrateJobRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MigrateJobRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MigrateJobRequest(::google::protobuf::internal::ConstantInitialized);

  inline MigrateJobRequest(const MigrateJobRequest& from) : MigrateJobRequest(nullptr, from) {}
  inline MigrateJobRequest(MigrateJobRequest&& from) noexcept
      : MigrateJobRequest(nullptr, std::move(from)) {}
  inline MigrateJobRequest& operator=(const MigrateJobRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MigrateJobRequest& operator=(MigrateJobRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MigrateJobRequest& default_instance() {
    return *reinterpret_cast<const MigrateJobRequest*>(
        &_MigrateJobRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(MigrateJobRequest& a, MigrateJobRequest& b) { a.Swap(&b); }
  inline void Swap(MigrateJobRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MigrateJobRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MigrateJobRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MigrateJobRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MigrateJobRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MigrateJobRequest& from) { MigrateJobRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MigrateJobRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.MigrateJobRequest"; }

 protected:
  explicit MigrateJobRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MigrateJobRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MigrateJobRequest& from);
  MigrateJobRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MigrateJobRequest&& from) noexcept
      : MigrateJobRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kJobIdsFieldNumber = 2,
  };
  // repeated string job_ids = 2;
  int job_ids_size() const;
  private:
  int _internal_job_ids_size() const;

  public:
  void clear_job_ids() ;
  const std::string& job_ids(int index) const;
  std::string* PROTOBUF_NONNULL mutable_job_ids(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_job_ids(int index, Arg_&& value, Args_... args);
  std::string* PROTOBUF_NONNULL add_job_ids();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_job_ids(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& job_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* PROTOBUF_NONNULL mutable_job_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_job_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* PROTOBUF_NONNULL _internal_mutable_job_ids();

  public:
  // @@protoc_insertion_point(class_scope:livekit.MigrateJobRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 41,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MigrateJobRequest& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> job_ids_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fagent_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MigrateJobRequest_class_data_;
// -------------------------------------------------------------------

class JobTermination final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.JobTermination) */ {
 public:
  inline JobTermination() : JobTermination(nullptr) {}
  ~JobTermination() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(JobTermination* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(JobTermination));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR JobTermination(::google::protobuf::internal::ConstantInitialized);

  inline JobTermination(const JobTermination& from) : JobTermination(nullptr, from) {}
  inline JobTermination(JobTermination&& from) noexcept
      : JobTermination(nullptr, std::move(from)) {}
  inline JobTermination& operator=(const JobTermination& from) {
    CopyFrom(from);
    return *this;
  }
  inline JobTermination& operator=(JobTermination&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JobTermination& default_instance() {
    return *reinterpret_cast<const JobTermination*>(
        &_JobTermination_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(JobTermination& a, JobTermination& b) { a.Swap(&b); }
  inline void Swap(JobTermination* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JobTermination* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JobTermination* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<JobTermination>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const JobTermination& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const JobTermination& from) { JobTermination::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(JobTermination* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.JobTermination"; }

 protected:
  explicit JobTermination(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  JobTermination(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const JobTermination& from);
  JobTermination(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, JobTermination&& from) noexcept
      : JobTermination(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kJobIdFieldNumber = 1,
  };
  // string job_id = 1;
  void clear_job_id() ;
  const std::string& job_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_job_id(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_job_id();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_job_id();
  void set_allocated_job_id(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_job_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_job_id(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_job_id();

  public:
  // @@protoc_insertion_point(class_scope:livekit.JobTermination)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 37,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const JobTermination& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr job_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fagent_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull JobTermination_class_data_;
// -------------------------------------------------------------------

class JobState final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.JobState) */ {
 public:
  inline JobState() : JobState(nullptr) {}
  ~JobState() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(JobState* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(JobState));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR JobState(::google::protobuf::internal::ConstantInitialized);

  inline JobState(const JobState& from) : JobState(nullptr, from) {}
  inline JobState(JobState&& from) noexcept
      : JobState(nullptr, std::move(from)) {}
  inline JobState& operator=(const JobState& from) {
    CopyFrom(from);
    return *this;
  }
  inline JobState& operator=(JobState&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JobState& default_instance() {
    return *reinterpret_cast<const JobState*>(
        &_JobState_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(JobState& a, JobState& b) { a.Swap(&b); }
  inline void Swap(JobState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JobState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JobState* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<JobState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const JobState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const JobState& from) { JobState::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(JobState* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.JobState"; }

 protected:
  explicit JobState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  JobState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const JobState& from);
  JobState(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, JobState&& from) noexcept
      : JobState(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kErrorFieldNumber = 2,
    kParticipantIdentityFieldNumber = 6,
    kStartedAtFieldNumber = 3,
    kEndedAtFieldNumber = 4,
    kUpdatedAtFieldNumber = 5,
    kStatusFieldNumber = 1,
  };
  // string error = 2;
  void clear_error() ;
  const std::string& error() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_error();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_error();
  void set_allocated_error(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_error() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_error();

  public:
  // string participant_identity = 6;
  void clear_participant_identity() ;
  const std::string& participant_identity() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_participant_identity(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_participant_identity();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_participant_identity();
  void set_allocated_participant_identity(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_participant_identity() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_participant_identity(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_participant_identity();

  public:
  // int64 started_at = 3;
  void clear_started_at() ;
  ::int64_t started_at() const;
  void set_started_at(::int64_t value);

  private:
  ::int64_t _internal_started_at() const;
  void _internal_set_started_at(::int64_t value);

  public:
  // int64 ended_at = 4;
  void clear_ended_at() ;
  ::int64_t ended_at() const;
  void set_ended_at(::int64_t value);

  private:
  ::int64_t _internal_ended_at() const;
  void _internal_set_ended_at(::int64_t value);

  public:
  // int64 updated_at = 5;
  void clear_updated_at() ;
  ::int64_t updated_at() const;
  void set_updated_at(::int64_t value);

  private:
  ::int64_t _internal_updated_at() const;
  void _internal_set_updated_at(::int64_t value);

  public:
  // .livekit.JobStatus status = 1;
  void clear_status() ;
  ::livekit::JobStatus status() const;
  void set_status(::livekit::JobStatus value);

  private:
  ::livekit::JobStatus _internal_status() const;
  void _internal_set_status(::livekit::JobStatus value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.JobState)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   0, 50,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const JobState& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr error_;
    ::google::protobuf::internal::ArenaStringPtr participant_identity_;
    ::int64_t started_at_;
    ::int64_t ended_at_;
    ::int64_t updated_at_;
    int status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fagent_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull JobState_class_data_;
// -------------------------------------------------------------------

class AvailabilityResponse_ParticipantAttributesEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<std::string, std::string,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  AvailabilityResponse_ParticipantAttributesEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AvailabilityResponse_ParticipantAttributesEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit AvailabilityResponse_ParticipantAttributesEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_AvailabilityResponse_ParticipantAttributesEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_livekit_5fagent_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 72,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull AvailabilityResponse_ParticipantAttributesEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class RegisterWorkerResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.RegisterWorkerResponse) */ {
 public:
  inline RegisterWorkerResponse() : RegisterWorkerResponse(nullptr) {}
  ~RegisterWorkerResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RegisterWorkerResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RegisterWorkerResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegisterWorkerResponse(::google::protobuf::internal::ConstantInitialized);

  inline RegisterWorkerResponse(const RegisterWorkerResponse& from) : RegisterWorkerResponse(nullptr, from) {}
  inline RegisterWorkerResponse(RegisterWorkerResponse&& from) noexcept
      : RegisterWorkerResponse(nullptr, std::move(from)) {}
  inline RegisterWorkerResponse& operator=(const RegisterWorkerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterWorkerResponse& operator=(RegisterWorkerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterWorkerResponse& default_instance() {
    return *reinterpret_cast<const RegisterWorkerResponse*>(
        &_RegisterWorkerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(RegisterWorkerResponse& a, RegisterWorkerResponse& b) { a.Swap(&b); }
  inline void Swap(RegisterWorkerResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterWorkerResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterWorkerResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RegisterWorkerResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegisterWorkerResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegisterWorkerResponse& from) { RegisterWorkerResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RegisterWorkerResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.RegisterWorkerResponse"; }

 protected:
  explicit RegisterWorkerResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RegisterWorkerResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RegisterWorkerResponse& from);
  RegisterWorkerResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RegisterWorkerResponse&& from) noexcept
      : RegisterWorkerResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kWorkerIdFieldNumber = 1,
    kServerInfoFieldNumber = 3,
  };
  // string worker_id = 1;
  void clear_worker_id() ;
  const std::string& worker_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_worker_id(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_worker_id();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_worker_id();
  void set_allocated_worker_id(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_worker_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_worker_id(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_worker_id();

  public:
  // .livekit.ServerInfo server_info = 3;
  bool has_server_info() const;
  void clear_server_info() ;
  const ::livekit::ServerInfo& server_info() const;
  [[nodiscard]] ::livekit::ServerInfo* PROTOBUF_NULLABLE release_server_info();
  ::livekit::ServerInfo* PROTOBUF_NONNULL mutable_server_info();
  void set_allocated_server_info(::livekit::ServerInfo* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_server_info(::livekit::ServerInfo* PROTOBUF_NULLABLE value);
  ::livekit::ServerInfo* PROTOBUF_NULLABLE unsafe_arena_release_server_info();

  private:
  const ::livekit::ServerInfo& _internal_server_info() const;
  ::livekit::ServerInfo* PROTOBUF_NONNULL _internal_mutable_server_info();

  public:
  // @@protoc_insertion_point(class_scope:livekit.RegisterWorkerResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 2,
                                   1, 48,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RegisterWorkerResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr worker_id_;
    ::livekit::ServerInfo* PROTOBUF_NULLABLE server_info_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fagent_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RegisterWorkerResponse_class_data_;
// -------------------------------------------------------------------

class RegisterWorkerRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.RegisterWorkerRequest) */ {
 public:
  inline RegisterWorkerRequest() : RegisterWorkerRequest(nullptr) {}
  ~RegisterWorkerRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RegisterWorkerRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RegisterWorkerRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegisterWorkerRequest(::google::protobuf::internal::ConstantInitialized);

  inline RegisterWorkerRequest(const RegisterWorkerRequest& from) : RegisterWorkerRequest(nullptr, from) {}
  inline RegisterWorkerRequest(RegisterWorkerRequest&& from) noexcept
      : RegisterWorkerRequest(nullptr, std::move(from)) {}
  inline RegisterWorkerRequest& operator=(const RegisterWorkerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterWorkerRequest& operator=(RegisterWorkerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterWorkerRequest& default_instance() {
    return *reinterpret_cast<const RegisterWorkerRequest*>(
        &_RegisterWorkerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(RegisterWorkerRequest& a, RegisterWorkerRequest& b) { a.Swap(&b); }
  inline void Swap(RegisterWorkerRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterWorkerRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterWorkerRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RegisterWorkerRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegisterWorkerRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegisterWorkerRequest& from) { RegisterWorkerRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RegisterWorkerRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.RegisterWorkerRequest"; }

 protected:
  explicit RegisterWorkerRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RegisterWorkerRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RegisterWorkerRequest& from);
  RegisterWorkerRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RegisterWorkerRequest&& from) noexcept
      : RegisterWorkerRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kVersionFieldNumber = 3,
    kNamespaceFieldNumber = 6,
    kAgentNameFieldNumber = 8,
    kAllowedPermissionsFieldNumber = 7,
    kTypeFieldNumber = 1,
    kPingIntervalFieldNumber = 5,
  };
  // string version = 3;
  void clear_version() ;
  const std::string& version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_version(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_version();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_version();
  void set_allocated_version(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_version() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_version();

  public:
  // optional string namespace = 6;
  bool has_namespace_() const;
  void clear_namespace_() ;
  const std::string& namespace_() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_namespace_(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_namespace_();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_namespace_();
  void set_allocated_namespace_(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_namespace_() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_namespace_();

  public:
  // string agent_name = 8;
  void clear_agent_name() ;
  const std::string& agent_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_agent_name(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_agent_name();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_agent_name();
  void set_allocated_agent_name(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_agent_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_agent_name(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_agent_name();

  public:
  // .livekit.ParticipantPermission allowed_permissions = 7;
  bool has_allowed_permissions() const;
  void clear_allowed_permissions() ;
  const ::livekit::ParticipantPermission& allowed_permissions() const;
  [[nodiscard]] ::livekit::ParticipantPermission* PROTOBUF_NULLABLE release_allowed_permissions();
  ::livekit::ParticipantPermission* PROTOBUF_NONNULL mutable_allowed_permissions();
  void set_allocated_allowed_permissions(::livekit::ParticipantPermission* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_allowed_permissions(::livekit::ParticipantPermission* PROTOBUF_NULLABLE value);
  ::livekit::ParticipantPermission* PROTOBUF_NULLABLE unsafe_arena_release_allowed_permissions();

  private:
  const ::livekit::ParticipantPermission& _internal_allowed_permissions() const;
  ::livekit::ParticipantPermission* PROTOBUF_NONNULL _internal_mutable_allowed_permissions();

  public:
  // .livekit.JobType type = 1;
  void clear_type() ;
  ::livekit::JobType type() const;
  void set_type(::livekit::JobType value);

  private:
  ::livekit::JobType _internal_type() const;
  void _internal_set_type(::livekit::JobType value);

  public:
  // uint32 ping_interval = 5;
  void clear_ping_interval() ;
  ::uint32_t ping_interval() const;
  void set_ping_interval(::uint32_t value);

  private:
  ::uint32_t _internal_ping_interval() const;
  void _internal_set_ping_interval(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.RegisterWorkerRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   1, 64,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RegisterWorkerRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr version_;
    ::google::protobuf::internal::ArenaStringPtr namespace__;
    ::google::protobuf::internal::ArenaStringPtr agent_name_;
    ::livekit::ParticipantPermission* PROTOBUF_NULLABLE allowed_permissions_;
    int type_;
    ::uint32_t ping_interval_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fagent_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RegisterWorkerRequest_class_data_;
// -------------------------------------------------------------------

class AvailabilityResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.AvailabilityResponse) */ {
 public:
  inline AvailabilityResponse() : AvailabilityResponse(nullptr) {}
  ~AvailabilityResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AvailabilityResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AvailabilityResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AvailabilityResponse(::google::protobuf::internal::ConstantInitialized);

  inline AvailabilityResponse(const AvailabilityResponse& from) : AvailabilityResponse(nullptr, from) {}
  inline AvailabilityResponse(AvailabilityResponse&& from) noexcept
      : AvailabilityResponse(nullptr, std::move(from)) {}
  inline AvailabilityResponse& operator=(const AvailabilityResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AvailabilityResponse& operator=(AvailabilityResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AvailabilityResponse& default_instance() {
    return *reinterpret_cast<const AvailabilityResponse*>(
        &_AvailabilityResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(AvailabilityResponse& a, AvailabilityResponse& b) { a.Swap(&b); }
  inline void Swap(AvailabilityResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AvailabilityResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AvailabilityResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AvailabilityResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AvailabilityResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AvailabilityResponse& from) { AvailabilityResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AvailabilityResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.AvailabilityResponse"; }

 protected:
  explicit AvailabilityResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  AvailabilityResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const AvailabilityResponse& from);
  AvailabilityResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, AvailabilityResponse&& from) noexcept
      : AvailabilityResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kParticipantAttributesFieldNumber = 7,
    kJobIdFieldNumber = 1,
    kParticipantNameFieldNumber = 4,
    kParticipantIdentityFieldNumber = 5,
    kParticipantMetadataFieldNumber = 6,
    kAvailableFieldNumber = 2,
    kSupportsResumeFieldNumber = 3,
  };
  // map<string, string> participant_attributes = 7;
  int participant_attributes_size() const;
  private:
  int _internal_participant_attributes_size() const;

  public:
  void clear_participant_attributes() ;
  const ::google::protobuf::Map<std::string, std::string>& participant_attributes() const;
  ::google::protobuf::Map<std::string, std::string>* PROTOBUF_NONNULL mutable_participant_attributes();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_participant_attributes() const;
  ::google::protobuf::Map<std::string, std::string>* PROTOBUF_NONNULL _internal_mutable_participant_attributes();

  public:
  // string job_id = 1;
  void clear_job_id() ;
  const std::string& job_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_job_id(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_job_id();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_job_id();
  void set_allocated_job_id(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_job_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_job_id(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_job_id();

  public:
  // string participant_name = 4;
  void clear_participant_name() ;
  const std::string& participant_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_participant_name(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_participant_name();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_participant_name();
  void set_allocated_participant_name(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_participant_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_participant_name(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_participant_name();

  public:
  // string participant_identity = 5;
  void clear_participant_identity() ;
  const std::string& participant_identity() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_participant_identity(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_participant_identity();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_participant_identity();
  void set_allocated_participant_identity(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_participant_identity() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_participant_identity(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_participant_identity();

  public:
  // string participant_metadata = 6;
  void clear_participant_metadata() ;
  const std::string& participant_metadata() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_participant_metadata(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_participant_metadata();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_participant_metadata();
  void set_allocated_participant_metadata(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_participant_metadata() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_participant_metadata(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_participant_metadata();

  public:
  // bool available = 2;
  void clear_available() ;
  bool available() const;
  void set_available(bool value);

  private:
  bool _internal_available() const;
  void _internal_set_available(bool value);

  public:
  // bool supports_resume = 3;
  void clear_supports_resume() ;
  bool supports_resume() const;
  void set_supports_resume(bool value);

  private:
  bool _internal_supports_resume() const;
  void _internal_set_supports_resume(bool value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.AvailabilityResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7,
                                   1, 121,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const AvailabilityResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::MapField<AvailabilityResponse_ParticipantAttributesEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        participant_attributes_;
    ::google::protobuf::internal::ArenaStringPtr job_id_;
    ::google::protobuf::internal::ArenaStringPtr participant_name_;
    ::google::protobuf::internal::ArenaStringPtr participant_identity_;
    ::google::protobuf::internal::ArenaStringPtr participant_metadata_;
    bool available_;
    bool supports_resume_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fagent_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull AvailabilityResponse_class_data_;
// -------------------------------------------------------------------

class SimulateJobRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.SimulateJobRequest) */ {
 public:
  inline SimulateJobRequest() : SimulateJobRequest(nullptr) {}
  ~SimulateJobRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SimulateJobRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SimulateJobRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SimulateJobRequest(::google::protobuf::internal::ConstantInitialized);

  inline SimulateJobRequest(const SimulateJobRequest& from) : SimulateJobRequest(nullptr, from) {}
  inline SimulateJobRequest(SimulateJobRequest&& from) noexcept
      : SimulateJobRequest(nullptr, std::move(from)) {}
  inline SimulateJobRequest& operator=(const SimulateJobRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimulateJobRequest& operator=(SimulateJobRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SimulateJobRequest& default_instance() {
    return *reinterpret_cast<const SimulateJobRequest*>(
        &_SimulateJobRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(SimulateJobRequest& a, SimulateJobRequest& b) { a.Swap(&b); }
  inline void Swap(SimulateJobRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimulateJobRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SimulateJobRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SimulateJobRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SimulateJobRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SimulateJobRequest& from) { SimulateJobRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SimulateJobRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.SimulateJobRequest"; }

 protected:
  explicit SimulateJobRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SimulateJobRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SimulateJobRequest& from);
  SimulateJobRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SimulateJobRequest&& from) noexcept
      : SimulateJobRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRoomFieldNumber = 2,
    kParticipantFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // .livekit.Room room = 2;
  bool has_room() const;
  void clear_room() ;
  const ::livekit::Room& room() const;
  [[nodiscard]] ::livekit::Room* PROTOBUF_NULLABLE release_room();
  ::livekit::Room* PROTOBUF_NONNULL mutable_room();
  void set_allocated_room(::livekit::Room* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_room(::livekit::Room* PROTOBUF_NULLABLE value);
  ::livekit::Room* PROTOBUF_NULLABLE unsafe_arena_release_room();

  private:
  const ::livekit::Room& _internal_room() const;
  ::livekit::Room* PROTOBUF_NONNULL _internal_mutable_room();

  public:
  // .livekit.ParticipantInfo participant = 3;
  bool has_participant() const;
  void clear_participant() ;
  const ::livekit::ParticipantInfo& participant() const;
  [[nodiscard]] ::livekit::ParticipantInfo* PROTOBUF_NULLABLE release_participant();
  ::livekit::ParticipantInfo* PROTOBUF_NONNULL mutable_participant();
  void set_allocated_participant(::livekit::ParticipantInfo* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_participant(::livekit::ParticipantInfo* PROTOBUF_NULLABLE value);
  ::livekit::ParticipantInfo* PROTOBUF_NULLABLE unsafe_arena_release_participant();

  private:
  const ::livekit::ParticipantInfo& _internal_participant() const;
  ::livekit::ParticipantInfo* PROTOBUF_NONNULL _internal_mutable_participant();

  public:
  // .livekit.JobType type = 1;
  void clear_type() ;
  ::livekit::JobType type() const;
  void set_type(::livekit::JobType value);

  private:
  ::livekit::JobType _internal_type() const;
  void _internal_set_type(::livekit::JobType value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.SimulateJobRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SimulateJobRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::livekit::Room* PROTOBUF_NULLABLE room_;
    ::livekit::ParticipantInfo* PROTOBUF_NULLABLE participant_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fagent_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SimulateJobRequest_class_data_;
// -------------------------------------------------------------------

class Job final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.Job) */ {
 public:
  inline Job() : Job(nullptr) {}
  ~Job() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Job* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Job));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Job(::google::protobuf::internal::ConstantInitialized);

  inline Job(const Job& from) : Job(nullptr, from) {}
  inline Job(Job&& from) noexcept
      : Job(nullptr, std::move(from)) {}
  inline Job& operator=(const Job& from) {
    CopyFrom(from);
    return *this;
  }
  inline Job& operator=(Job&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Job& default_instance() {
    return *reinterpret_cast<const Job*>(
        &_Job_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Job& a, Job& b) { a.Swap(&b); }
  inline void Swap(Job* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Job* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Job* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Job>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Job& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Job& from) { Job::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Job* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.Job"; }

 protected:
  explicit Job(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Job(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Job& from);
  Job(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Job&& from) noexcept
      : Job(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kNamespaceFieldNumber = 5,
    kMetadataFieldNumber = 6,
    kAgentNameFieldNumber = 7,
    kDispatchIdFieldNumber = 9,
    kRoomFieldNumber = 3,
    kParticipantFieldNumber = 4,
    kStateFieldNumber = 8,
    kTypeFieldNumber = 2,
  };
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_id();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_id();
  void set_allocated_id(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_id();

  public:
  // string namespace = 5 [deprecated = true];
  [[deprecated]]  void clear_namespace_() ;
  [[deprecated]] const std::string& namespace_() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  [[deprecated]] void set_namespace_(Arg_&& arg, Args_... args);
  [[deprecated]] std::string* PROTOBUF_NONNULL mutable_namespace_();
  [[deprecated]] [[nodiscard]] std::string* PROTOBUF_NULLABLE release_namespace_();
  [[deprecated]] void set_allocated_namespace_(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_namespace_() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_namespace_();

  public:
  // string metadata = 6;
  void clear_metadata() ;
  const std::string& metadata() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_metadata(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_metadata();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_metadata();
  void set_allocated_metadata(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_metadata() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_metadata(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_metadata();

  public:
  // string agent_name = 7;
  void clear_agent_name() ;
  const std::string& agent_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_agent_name(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_agent_name();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_agent_name();
  void set_allocated_agent_name(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_agent_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_agent_name(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_agent_name();

  public:
  // string dispatch_id = 9;
  void clear_dispatch_id() ;
  const std::string& dispatch_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dispatch_id(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_dispatch_id();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_dispatch_id();
  void set_allocated_dispatch_id(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_dispatch_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_dispatch_id(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_dispatch_id();

  public:
  // .livekit.Room room = 3;
  bool has_room() const;
  void clear_room() ;
  const ::livekit::Room& room() const;
  [[nodiscard]] ::livekit::Room* PROTOBUF_NULLABLE release_room();
  ::livekit::Room* PROTOBUF_NONNULL mutable_room();
  void set_allocated_room(::livekit::Room* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_room(::livekit::Room* PROTOBUF_NULLABLE value);
  ::livekit::Room* PROTOBUF_NULLABLE unsafe_arena_release_room();

  private:
  const ::livekit::Room& _internal_room() const;
  ::livekit::Room* PROTOBUF_NONNULL _internal_mutable_room();

  public:
  // optional .livekit.ParticipantInfo participant = 4;
  bool has_participant() const;
  void clear_participant() ;
  const ::livekit::ParticipantInfo& participant() const;
  [[nodiscard]] ::livekit::ParticipantInfo* PROTOBUF_NULLABLE release_participant();
  ::livekit::ParticipantInfo* PROTOBUF_NONNULL mutable_participant();
  void set_allocated_participant(::livekit::ParticipantInfo* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_participant(::livekit::ParticipantInfo* PROTOBUF_NULLABLE value);
  ::livekit::ParticipantInfo* PROTOBUF_NULLABLE unsafe_arena_release_participant();

  private:
  const ::livekit::ParticipantInfo& _internal_participant() const;
  ::livekit::ParticipantInfo* PROTOBUF_NONNULL _internal_mutable_participant();

  public:
  // .livekit.JobState state = 8;
  bool has_state() const;
  void clear_state() ;
  const ::livekit::JobState& state() const;
  [[nodiscard]] ::livekit::JobState* PROTOBUF_NULLABLE release_state();
  ::livekit::JobState* PROTOBUF_NONNULL mutable_state();
  void set_allocated_state(::livekit::JobState* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_state(::livekit::JobState* PROTOBUF_NULLABLE value);
  ::livekit::JobState* PROTOBUF_NULLABLE unsafe_arena_release_state();

  private:
  const ::livekit::JobState& _internal_state() const;
  ::livekit::JobState* PROTOBUF_NONNULL _internal_mutable_state();

  public:
  // .livekit.JobType type = 2;
  void clear_type() ;
  ::livekit::JobType type() const;
  void set_type(::livekit::JobType value);

  private:
  ::livekit::JobType _internal_type() const;
  void _internal_set_type(::livekit::JobType value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.Job)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 9,
                                   3, 68,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Job& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr namespace__;
    ::google::protobuf::internal::ArenaStringPtr metadata_;
    ::google::protobuf::internal::ArenaStringPtr agent_name_;
    ::google::protobuf::internal::ArenaStringPtr dispatch_id_;
    ::livekit::Room* PROTOBUF_NULLABLE room_;
    ::livekit::ParticipantInfo* PROTOBUF_NULLABLE participant_;
    ::livekit::JobState* PROTOBUF_NULLABLE state_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fagent_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Job_class_data_;
// -------------------------------------------------------------------

class WorkerMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.WorkerMessage) */ {
 public:
  inline WorkerMessage() : WorkerMessage(nullptr) {}
  ~WorkerMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(WorkerMessage* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(WorkerMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WorkerMessage(::google::protobuf::internal::ConstantInitialized);

  inline WorkerMessage(const WorkerMessage& from) : WorkerMessage(nullptr, from) {}
  inline WorkerMessage(WorkerMessage&& from) noexcept
      : WorkerMessage(nullptr, std::move(from)) {}
  inline WorkerMessage& operator=(const WorkerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkerMessage& operator=(WorkerMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkerMessage& default_instance() {
    return *reinterpret_cast<const WorkerMessage*>(
        &_WorkerMessage_default_instance_);
  }
  enum MessageCase {
    kRegister = 1,
    kAvailability = 2,
    kUpdateWorker = 3,
    kUpdateJob = 4,
    kPing = 5,
    kSimulateJob = 6,
    kMigrateJob = 7,
    MESSAGE_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(WorkerMessage& a, WorkerMessage& b) { a.Swap(&b); }
  inline void Swap(WorkerMessage* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkerMessage* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkerMessage* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<WorkerMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WorkerMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const WorkerMessage& from) { WorkerMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(WorkerMessage* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.WorkerMessage"; }

 protected:
  explicit WorkerMessage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  WorkerMessage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const WorkerMessage& from);
  WorkerMessage(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, WorkerMessage&& from) noexcept
      : WorkerMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRegisterFieldNumber = 1,
    kAvailabilityFieldNumber = 2,
    kUpdateWorkerFieldNumber = 3,
    kUpdateJobFieldNumber = 4,
    kPingFieldNumber = 5,
    kSimulateJobFieldNumber = 6,
    kMigrateJobFieldNumber = 7,
  };
  // .livekit.RegisterWorkerRequest register = 1;
  bool has_register_() const;
  private:
  bool _internal_has_register_() const;

  public:
  void clear_register_() ;
  const ::livekit::RegisterWorkerRequest& register_() const;
  [[nodiscard]] ::livekit::RegisterWorkerRequest* PROTOBUF_NULLABLE release_register_();
  ::livekit::RegisterWorkerRequest* PROTOBUF_NONNULL mutable_register_();
  void set_allocated_register_(::livekit::RegisterWorkerRequest* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_register_(::livekit::RegisterWorkerRequest* PROTOBUF_NULLABLE value);
  ::livekit::RegisterWorkerRequest* PROTOBUF_NULLABLE unsafe_arena_release_register_();

  private:
  const ::livekit::RegisterWorkerRequest& _internal_register_() const;
  ::livekit::RegisterWorkerRequest* PROTOBUF_NONNULL _internal_mutable_register_();

  public:
  // .livekit.AvailabilityResponse availability = 2;
  bool has_availability() const;
  private:
  bool _internal_has_availability() const;

  public:
  void clear_availability() ;
  const ::livekit::AvailabilityResponse& availability() const;
  [[nodiscard]] ::livekit::AvailabilityResponse* PROTOBUF_NULLABLE release_availability();
  ::livekit::AvailabilityResponse* PROTOBUF_NONNULL mutable_availability();
  void set_allocated_availability(::livekit::AvailabilityResponse* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_availability(::livekit::AvailabilityResponse* PROTOBUF_NULLABLE value);
  ::livekit::AvailabilityResponse* PROTOBUF_NULLABLE unsafe_arena_release_availability();

  private:
  const ::livekit::AvailabilityResponse& _internal_availability() const;
  ::livekit::AvailabilityResponse* PROTOBUF_NONNULL _internal_mutable_availability();

  public:
  // .livekit.UpdateWorkerStatus update_worker = 3;
  bool has_update_worker() const;
  private:
  bool _internal_has_update_worker() const;

  public:
  void clear_update_worker() ;
  const ::livekit::UpdateWorkerStatus& update_worker() const;
  [[nodiscard]] ::livekit::UpdateWorkerStatus* PROTOBUF_NULLABLE release_update_worker();
  ::livekit::UpdateWorkerStatus* PROTOBUF_NONNULL mutable_update_worker();
  void set_allocated_update_worker(::livekit::UpdateWorkerStatus* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_update_worker(::livekit::UpdateWorkerStatus* PROTOBUF_NULLABLE value);
  ::livekit::UpdateWorkerStatus* PROTOBUF_NULLABLE unsafe_arena_release_update_worker();

  private:
  const ::livekit::UpdateWorkerStatus& _internal_update_worker() const;
  ::livekit::UpdateWorkerStatus* PROTOBUF_NONNULL _internal_mutable_update_worker();

  public:
  // .livekit.UpdateJobStatus update_job = 4;
  bool has_update_job() const;
  private:
  bool _internal_has_update_job() const;

  public:
  void clear_update_job() ;
  const ::livekit::UpdateJobStatus& update_job() const;
  [[nodiscard]] ::livekit::UpdateJobStatus* PROTOBUF_NULLABLE release_update_job();
  ::livekit::UpdateJobStatus* PROTOBUF_NONNULL mutable_update_job();
  void set_allocated_update_job(::livekit::UpdateJobStatus* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_update_job(::livekit::UpdateJobStatus* PROTOBUF_NULLABLE value);
  ::livekit::UpdateJobStatus* PROTOBUF_NULLABLE unsafe_arena_release_update_job();

  private:
  const ::livekit::UpdateJobStatus& _internal_update_job() const;
  ::livekit::UpdateJobStatus* PROTOBUF_NONNULL _internal_mutable_update_job();

  public:
  // .livekit.WorkerPing ping = 5;
  bool has_ping() const;
  private:
  bool _internal_has_ping() const;

  public:
  void clear_ping() ;
  const ::livekit::WorkerPing& ping() const;
  [[nodiscard]] ::livekit::WorkerPing* PROTOBUF_NULLABLE release_ping();
  ::livekit::WorkerPing* PROTOBUF_NONNULL mutable_ping();
  void set_allocated_ping(::livekit::WorkerPing* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_ping(::livekit::WorkerPing* PROTOBUF_NULLABLE value);
  ::livekit::WorkerPing* PROTOBUF_NULLABLE unsafe_arena_release_ping();

  private:
  const ::livekit::WorkerPing& _internal_ping() const;
  ::livekit::WorkerPing* PROTOBUF_NONNULL _internal_mutable_ping();

  public:
  // .livekit.SimulateJobRequest simulate_job = 6;
  bool has_simulate_job() const;
  private:
  bool _internal_has_simulate_job() const;

  public:
  void clear_simulate_job() ;
  const ::livekit::SimulateJobRequest& simulate_job() const;
  [[nodiscard]] ::livekit::SimulateJobRequest* PROTOBUF_NULLABLE release_simulate_job();
  ::livekit::SimulateJobRequest* PROTOBUF_NONNULL mutable_simulate_job();
  void set_allocated_simulate_job(::livekit::SimulateJobRequest* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_simulate_job(::livekit::SimulateJobRequest* PROTOBUF_NULLABLE value);
  ::livekit::SimulateJobRequest* PROTOBUF_NULLABLE unsafe_arena_release_simulate_job();

  private:
  const ::livekit::SimulateJobRequest& _internal_simulate_job() const;
  ::livekit::SimulateJobRequest* PROTOBUF_NONNULL _internal_mutable_simulate_job();

  public:
  // .livekit.MigrateJobRequest migrate_job = 7;
  bool has_migrate_job() const;
  private:
  bool _internal_has_migrate_job() const;

  public:
  void clear_migrate_job() ;
  const ::livekit::MigrateJobRequest& migrate_job() const;
  [[nodiscard]] ::livekit::MigrateJobRequest* PROTOBUF_NULLABLE release_migrate_job();
  ::livekit::MigrateJobRequest* PROTOBUF_NONNULL mutable_migrate_job();
  void set_allocated_migrate_job(::livekit::MigrateJobRequest* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_migrate_job(::livekit::MigrateJobRequest* PROTOBUF_NULLABLE value);
  ::livekit::MigrateJobRequest* PROTOBUF_NULLABLE unsafe_arena_release_migrate_job();

  private:
  const ::livekit::MigrateJobRequest& _internal_migrate_job() const;
  ::livekit::MigrateJobRequest* PROTOBUF_NONNULL _internal_mutable_migrate_job();

  public:
  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:livekit.WorkerMessage)
 private:
  class _Internal;
  void set_has_register_();
  void set_has_availability();
  void set_has_update_worker();
  void set_has_update_job();
  void set_has_ping();
  void set_has_simulate_job();
  void set_has_migrate_job();
  inline bool has_message() const;
  inline void clear_has_message();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 7,
                                   7, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const WorkerMessage& from_msg);
    union MessageUnion {
      constexpr MessageUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE register__;
      ::google::protobuf::Message* PROTOBUF_NULLABLE availability_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE update_worker_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE update_job_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE ping_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE simulate_job_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE migrate_job_;
    } message_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fagent_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull WorkerMessage_class_data_;
// -------------------------------------------------------------------

class JobAssignment final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.JobAssignment) */ {
 public:
  inline JobAssignment() : JobAssignment(nullptr) {}
  ~JobAssignment() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(JobAssignment* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(JobAssignment));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR JobAssignment(::google::protobuf::internal::ConstantInitialized);

  inline JobAssignment(const JobAssignment& from) : JobAssignment(nullptr, from) {}
  inline JobAssignment(JobAssignment&& from) noexcept
      : JobAssignment(nullptr, std::move(from)) {}
  inline JobAssignment& operator=(const JobAssignment& from) {
    CopyFrom(from);
    return *this;
  }
  inline JobAssignment& operator=(JobAssignment&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JobAssignment& default_instance() {
    return *reinterpret_cast<const JobAssignment*>(
        &_JobAssignment_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(JobAssignment& a, JobAssignment& b) { a.Swap(&b); }
  inline void Swap(JobAssignment* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JobAssignment* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JobAssignment* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<JobAssignment>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const JobAssignment& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const JobAssignment& from) { JobAssignment::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(JobAssignment* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.JobAssignment"; }

 protected:
  explicit JobAssignment(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  JobAssignment(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const JobAssignment& from);
  JobAssignment(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, JobAssignment&& from) noexcept
      : JobAssignment(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUrlFieldNumber = 2,
    kTokenFieldNumber = 3,
    kJobFieldNumber = 1,
  };
  // optional string url = 2;
  bool has_url() const;
  void clear_url() ;
  const std::string& url() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_url(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_url();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_url();
  void set_allocated_url(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_url() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_url();

  public:
  // string token = 3;
  void clear_token() ;
  const std::string& token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_token(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_token();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_token();
  void set_allocated_token(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_token() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_token();

  public:
  // .livekit.Job job = 1;
  bool has_job() const;
  void clear_job() ;
  const ::livekit::Job& job() const;
  [[nodiscard]] ::livekit::Job* PROTOBUF_NULLABLE release_job();
  ::livekit::Job* PROTOBUF_NONNULL mutable_job();
  void set_allocated_job(::livekit::Job* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_job(::livekit::Job* PROTOBUF_NULLABLE value);
  ::livekit::Job* PROTOBUF_NULLABLE unsafe_arena_release_job();

  private:
  const ::livekit::Job& _internal_job() const;
  ::livekit::Job* PROTOBUF_NONNULL _internal_mutable_job();

  public:
  // @@protoc_insertion_point(class_scope:livekit.JobAssignment)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   1, 38,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const JobAssignment& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr url_;
    ::google::protobuf::internal::ArenaStringPtr token_;
    ::livekit::Job* PROTOBUF_NULLABLE job_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fagent_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull JobAssignment_class_data_;
// -------------------------------------------------------------------

class AvailabilityRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.AvailabilityRequest) */ {
 public:
  inline AvailabilityRequest() : AvailabilityRequest(nullptr) {}
  ~AvailabilityRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AvailabilityRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AvailabilityRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AvailabilityRequest(::google::protobuf::internal::ConstantInitialized);

  inline AvailabilityRequest(const AvailabilityRequest& from) : AvailabilityRequest(nullptr, from) {}
  inline AvailabilityRequest(AvailabilityRequest&& from) noexcept
      : AvailabilityRequest(nullptr, std::move(from)) {}
  inline AvailabilityRequest& operator=(const AvailabilityRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AvailabilityRequest& operator=(AvailabilityRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AvailabilityRequest& default_instance() {
    return *reinterpret_cast<const AvailabilityRequest*>(
        &_AvailabilityRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(AvailabilityRequest& a, AvailabilityRequest& b) { a.Swap(&b); }
  inline void Swap(AvailabilityRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AvailabilityRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AvailabilityRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AvailabilityRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AvailabilityRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AvailabilityRequest& from) { AvailabilityRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AvailabilityRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.AvailabilityRequest"; }

 protected:
  explicit AvailabilityRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  AvailabilityRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const AvailabilityRequest& from);
  AvailabilityRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, AvailabilityRequest&& from) noexcept
      : AvailabilityRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kJobFieldNumber = 1,
    kResumingFieldNumber = 2,
  };
  // .livekit.Job job = 1;
  bool has_job() const;
  void clear_job() ;
  const ::livekit::Job& job() const;
  [[nodiscard]] ::livekit::Job* PROTOBUF_NULLABLE release_job();
  ::livekit::Job* PROTOBUF_NONNULL mutable_job();
  void set_allocated_job(::livekit::Job* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_job(::livekit::Job* PROTOBUF_NULLABLE value);
  ::livekit::Job* PROTOBUF_NULLABLE unsafe_arena_release_job();

  private:
  const ::livekit::Job& _internal_job() const;
  ::livekit::Job* PROTOBUF_NONNULL _internal_mutable_job();

  public:
  // bool resuming = 2;
  void clear_resuming() ;
  bool resuming() const;
  void set_resuming(bool value);

  private:
  bool _internal_resuming() const;
  void _internal_set_resuming(bool value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.AvailabilityRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const AvailabilityRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::livekit::Job* PROTOBUF_NULLABLE job_;
    bool resuming_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fagent_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull AvailabilityRequest_class_data_;
// -------------------------------------------------------------------

class ServerMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.ServerMessage) */ {
 public:
  inline ServerMessage() : ServerMessage(nullptr) {}
  ~ServerMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ServerMessage* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ServerMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ServerMessage(::google::protobuf::internal::ConstantInitialized);

  inline ServerMessage(const ServerMessage& from) : ServerMessage(nullptr, from) {}
  inline ServerMessage(ServerMessage&& from) noexcept
      : ServerMessage(nullptr, std::move(from)) {}
  inline ServerMessage& operator=(const ServerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerMessage& operator=(ServerMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerMessage& default_instance() {
    return *reinterpret_cast<const ServerMessage*>(
        &_ServerMessage_default_instance_);
  }
  enum MessageCase {
    kRegister = 1,
    kAvailability = 2,
    kAssignment = 3,
    kTermination = 5,
    kPong = 4,
    MESSAGE_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(ServerMessage& a, ServerMessage& b) { a.Swap(&b); }
  inline void Swap(ServerMessage* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerMessage* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerMessage* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ServerMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ServerMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ServerMessage& from) { ServerMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ServerMessage* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.ServerMessage"; }

 protected:
  explicit ServerMessage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ServerMessage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ServerMessage& from);
  ServerMessage(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ServerMessage&& from) noexcept
      : ServerMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRegisterFieldNumber = 1,
    kAvailabilityFieldNumber = 2,
    kAssignmentFieldNumber = 3,
    kTerminationFieldNumber = 5,
    kPongFieldNumber = 4,
  };
  // .livekit.RegisterWorkerResponse register = 1;
  bool has_register_() const;
  private:
  bool _internal_has_register_() const;

  public:
  void clear_register_() ;
  const ::livekit::RegisterWorkerResponse& register_() const;
  [[nodiscard]] ::livekit::RegisterWorkerResponse* PROTOBUF_NULLABLE release_register_();
  ::livekit::RegisterWorkerResponse* PROTOBUF_NONNULL mutable_register_();
  void set_allocated_register_(::livekit::RegisterWorkerResponse* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_register_(::livekit::RegisterWorkerResponse* PROTOBUF_NULLABLE value);
  ::livekit::RegisterWorkerResponse* PROTOBUF_NULLABLE unsafe_arena_release_register_();

  private:
  const ::livekit::RegisterWorkerResponse& _internal_register_() const;
  ::livekit::RegisterWorkerResponse* PROTOBUF_NONNULL _internal_mutable_register_();

  public:
  // .livekit.AvailabilityRequest availability = 2;
  bool has_availability() const;
  private:
  bool _internal_has_availability() const;

  public:
  void clear_availability() ;
  const ::livekit::AvailabilityRequest& availability() const;
  [[nodiscard]] ::livekit::AvailabilityRequest* PROTOBUF_NULLABLE release_availability();
  ::livekit::AvailabilityRequest* PROTOBUF_NONNULL mutable_availability();
  void set_allocated_availability(::livekit::AvailabilityRequest* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_availability(::livekit::AvailabilityRequest* PROTOBUF_NULLABLE value);
  ::livekit::AvailabilityRequest* PROTOBUF_NULLABLE unsafe_arena_release_availability();

  private:
  const ::livekit::AvailabilityRequest& _internal_availability() const;
  ::livekit::AvailabilityRequest* PROTOBUF_NONNULL _internal_mutable_availability();

  public:
  // .livekit.JobAssignment assignment = 3;
  bool has_assignment() const;
  private:
  bool _internal_has_assignment() const;

  public:
  void clear_assignment() ;
  const ::livekit::JobAssignment& assignment() const;
  [[nodiscard]] ::livekit::JobAssignment* PROTOBUF_NULLABLE release_assignment();
  ::livekit::JobAssignment* PROTOBUF_NONNULL mutable_assignment();
  void set_allocated_assignment(::livekit::JobAssignment* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_assignment(::livekit::JobAssignment* PROTOBUF_NULLABLE value);
  ::livekit::JobAssignment* PROTOBUF_NULLABLE unsafe_arena_release_assignment();

  private:
  const ::livekit::JobAssignment& _internal_assignment() const;
  ::livekit::JobAssignment* PROTOBUF_NONNULL _internal_mutable_assignment();

  public:
  // .livekit.JobTermination termination = 5;
  bool has_termination() const;
  private:
  bool _internal_has_termination() const;

  public:
  void clear_termination() ;
  const ::livekit::JobTermination& termination() const;
  [[nodiscard]] ::livekit::JobTermination* PROTOBUF_NULLABLE release_termination();
  ::livekit::JobTermination* PROTOBUF_NONNULL mutable_termination();
  void set_allocated_termination(::livekit::JobTermination* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_termination(::livekit::JobTermination* PROTOBUF_NULLABLE value);
  ::livekit::JobTermination* PROTOBUF_NULLABLE unsafe_arena_release_termination();

  private:
  const ::livekit::JobTermination& _internal_termination() const;
  ::livekit::JobTermination* PROTOBUF_NONNULL _internal_mutable_termination();

  public:
  // .livekit.WorkerPong pong = 4;
  bool has_pong() const;
  private:
  bool _internal_has_pong() const;

  public:
  void clear_pong() ;
  const ::livekit::WorkerPong& pong() const;
  [[nodiscard]] ::livekit::WorkerPong* PROTOBUF_NULLABLE release_pong();
  ::livekit::WorkerPong* PROTOBUF_NONNULL mutable_pong();
  void set_allocated_pong(::livekit::WorkerPong* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_pong(::livekit::WorkerPong* PROTOBUF_NULLABLE value);
  ::livekit::WorkerPong* PROTOBUF_NULLABLE unsafe_arena_release_pong();

  private:
  const ::livekit::WorkerPong& _internal_pong() const;
  ::livekit::WorkerPong* PROTOBUF_NONNULL _internal_mutable_pong();

  public:
  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:livekit.ServerMessage)
 private:
  class _Internal;
  void set_has_register_();
  void set_has_availability();
  void set_has_assignment();
  void set_has_termination();
  void set_has_pong();
  inline bool has_message() const;
  inline void clear_has_message();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 5,
                                   5, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ServerMessage& from_msg);
    union MessageUnion {
      constexpr MessageUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE register__;
      ::google::protobuf::Message* PROTOBUF_NULLABLE availability_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE assignment_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE termination_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE pong_;
    } message_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fagent_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ServerMessage_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Job

// string id = 1;
inline void Job::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Job::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.Job.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Job::set_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.Job.id)
}
inline std::string* PROTOBUF_NONNULL Job::mutable_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:livekit.Job.id)
  return _s;
}
inline const std::string& Job::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void Job::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL Job::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE Job::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.Job.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.id_.Set("", GetArena());
  }
  return released;
}
inline void Job::set_allocated_id(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.Job.id)
}

// string dispatch_id = 9;
inline void Job::clear_dispatch_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dispatch_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& Job::dispatch_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.Job.dispatch_id)
  return _internal_dispatch_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Job::set_dispatch_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.dispatch_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.Job.dispatch_id)
}
inline std::string* PROTOBUF_NONNULL Job::mutable_dispatch_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_dispatch_id();
  // @@protoc_insertion_point(field_mutable:livekit.Job.dispatch_id)
  return _s;
}
inline const std::string& Job::_internal_dispatch_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dispatch_id_.Get();
}
inline void Job::_internal_set_dispatch_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.dispatch_id_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL Job::_internal_mutable_dispatch_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.dispatch_id_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE Job::release_dispatch_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.Job.dispatch_id)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.dispatch_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.dispatch_id_.Set("", GetArena());
  }
  return released;
}
inline void Job::set_allocated_dispatch_id(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.dispatch_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.dispatch_id_.IsDefault()) {
    _impl_.dispatch_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.Job.dispatch_id)
}

// .livekit.JobType type = 2;
inline void Job::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::livekit::JobType Job::type() const {
  // @@protoc_insertion_point(field_get:livekit.Job.type)
  return _internal_type();
}
inline void Job::set_type(::livekit::JobType value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:livekit.Job.type)
}
inline ::livekit::JobType Job::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::livekit::JobType>(_impl_.type_);
}
inline void Job::_internal_set_type(::livekit::JobType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// .livekit.Room room = 3;
inline bool Job::has_room() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.room_ != nullptr);
  return value;
}
inline const ::livekit::Room& Job::_internal_room() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::livekit::Room* p = _impl_.room_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::Room&>(::livekit::_Room_default_instance_);
}
inline const ::livekit::Room& Job::room() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.Job.room)
  return _internal_room();
}
inline void Job::unsafe_arena_set_allocated_room(
    ::livekit::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.room_);
  }
  _impl_.room_ = reinterpret_cast<::livekit::Room*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.Job.room)
}
inline ::livekit::Room* PROTOBUF_NULLABLE Job::release_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::livekit::Room* released = _impl_.room_;
  _impl_.room_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::livekit::Room* PROTOBUF_NULLABLE Job::unsafe_arena_release_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.Job.room)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::livekit::Room* temp = _impl_.room_;
  _impl_.room_ = nullptr;
  return temp;
}
inline ::livekit::Room* PROTOBUF_NONNULL Job::_internal_mutable_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.room_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::livekit::Room>(GetArena());
    _impl_.room_ = reinterpret_cast<::livekit::Room*>(p);
  }
  return _impl_.room_;
}
inline ::livekit::Room* PROTOBUF_NONNULL Job::mutable_room()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::livekit::Room* _msg = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:livekit.Job.room)
  return _msg;
}
inline void Job::set_allocated_room(::livekit::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.room_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.room_ = reinterpret_cast<::livekit::Room*>(value);
  // @@protoc_insertion_point(field_set_allocated:livekit.Job.room)
}

// optional .livekit.ParticipantInfo participant = 4;
inline bool Job::has_participant() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.participant_ != nullptr);
  return value;
}
inline const ::livekit::ParticipantInfo& Job::_internal_participant() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::livekit::ParticipantInfo* p = _impl_.participant_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::ParticipantInfo&>(::livekit::_ParticipantInfo_default_instance_);
}
inline const ::livekit::ParticipantInfo& Job::participant() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.Job.participant)
  return _internal_participant();
}
inline void Job::unsafe_arena_set_allocated_participant(
    ::livekit::ParticipantInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.participant_);
  }
  _impl_.participant_ = reinterpret_cast<::livekit::ParticipantInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.Job.participant)
}
inline ::livekit::ParticipantInfo* PROTOBUF_NULLABLE Job::release_participant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::livekit::ParticipantInfo* released = _impl_.participant_;
  _impl_.participant_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::livekit::ParticipantInfo* PROTOBUF_NULLABLE Job::unsafe_arena_release_participant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.Job.participant)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::livekit::ParticipantInfo* temp = _impl_.participant_;
  _impl_.participant_ = nullptr;
  return temp;
}
inline ::livekit::ParticipantInfo* PROTOBUF_NONNULL Job::_internal_mutable_participant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.participant_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::livekit::ParticipantInfo>(GetArena());
    _impl_.participant_ = reinterpret_cast<::livekit::ParticipantInfo*>(p);
  }
  return _impl_.participant_;
}
inline ::livekit::ParticipantInfo* PROTOBUF_NONNULL Job::mutable_participant()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000040u;
  ::livekit::ParticipantInfo* _msg = _internal_mutable_participant();
  // @@protoc_insertion_point(field_mutable:livekit.Job.participant)
  return _msg;
}
inline void Job::set_allocated_participant(::livekit::ParticipantInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.participant_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.participant_ = reinterpret_cast<::livekit::ParticipantInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:livekit.Job.participant)
}

// string namespace = 5 [deprecated = true];
inline void Job::clear_namespace_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.namespace__.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Job::namespace_() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.Job.namespace)
  return _internal_namespace_();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Job::set_namespace_(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.namespace__.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.Job.namespace)
}
inline std::string* PROTOBUF_NONNULL Job::mutable_namespace_()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:livekit.Job.namespace)
  return _s;
}
inline const std::string& Job::_internal_namespace_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.namespace__.Get();
}
inline void Job::_internal_set_namespace_(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.namespace__.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL Job::_internal_mutable_namespace_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.namespace__.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE Job::release_namespace_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.Job.namespace)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.namespace__.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.namespace__.Set("", GetArena());
  }
  return released;
}
inline void Job::set_allocated_namespace_(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.namespace__.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.namespace__.IsDefault()) {
    _impl_.namespace__.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.Job.namespace)
}

// string metadata = 6;
inline void Job::clear_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.metadata_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Job::metadata() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.Job.metadata)
  return _internal_metadata();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Job::set_metadata(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.metadata_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.Job.metadata)
}
inline std::string* PROTOBUF_NONNULL Job::mutable_metadata()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:livekit.Job.metadata)
  return _s;
}
inline const std::string& Job::_internal_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.metadata_.Get();
}
inline void Job::_internal_set_metadata(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.metadata_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL Job::_internal_mutable_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.metadata_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE Job::release_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.Job.metadata)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.metadata_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.metadata_.Set("", GetArena());
  }
  return released;
}
inline void Job::set_allocated_metadata(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.metadata_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.metadata_.IsDefault()) {
    _impl_.metadata_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.Job.metadata)
}

// string agent_name = 7;
inline void Job::clear_agent_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agent_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Job::agent_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.Job.agent_name)
  return _internal_agent_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Job::set_agent_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.agent_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.Job.agent_name)
}
inline std::string* PROTOBUF_NONNULL Job::mutable_agent_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_agent_name();
  // @@protoc_insertion_point(field_mutable:livekit.Job.agent_name)
  return _s;
}
inline const std::string& Job::_internal_agent_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.agent_name_.Get();
}
inline void Job::_internal_set_agent_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.agent_name_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL Job::_internal_mutable_agent_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.agent_name_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE Job::release_agent_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.Job.agent_name)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.agent_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.agent_name_.Set("", GetArena());
  }
  return released;
}
inline void Job::set_allocated_agent_name(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.agent_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.agent_name_.IsDefault()) {
    _impl_.agent_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.Job.agent_name)
}

// .livekit.JobState state = 8;
inline bool Job::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.state_ != nullptr);
  return value;
}
inline void Job::clear_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.state_ != nullptr) _impl_.state_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::livekit::JobState& Job::_internal_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::livekit::JobState* p = _impl_.state_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::JobState&>(::livekit::_JobState_default_instance_);
}
inline const ::livekit::JobState& Job::state() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.Job.state)
  return _internal_state();
}
inline void Job::unsafe_arena_set_allocated_state(
    ::livekit::JobState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.state_);
  }
  _impl_.state_ = reinterpret_cast<::livekit::JobState*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.Job.state)
}
inline ::livekit::JobState* PROTOBUF_NULLABLE Job::release_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::livekit::JobState* released = _impl_.state_;
  _impl_.state_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::livekit::JobState* PROTOBUF_NULLABLE Job::unsafe_arena_release_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.Job.state)

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::livekit::JobState* temp = _impl_.state_;
  _impl_.state_ = nullptr;
  return temp;
}
inline ::livekit::JobState* PROTOBUF_NONNULL Job::_internal_mutable_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.state_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::livekit::JobState>(GetArena());
    _impl_.state_ = reinterpret_cast<::livekit::JobState*>(p);
  }
  return _impl_.state_;
}
inline ::livekit::JobState* PROTOBUF_NONNULL Job::mutable_state()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000080u;
  ::livekit::JobState* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:livekit.Job.state)
  return _msg;
}
inline void Job::set_allocated_state(::livekit::JobState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.state_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }

  _impl_.state_ = reinterpret_cast<::livekit::JobState*>(value);
  // @@protoc_insertion_point(field_set_allocated:livekit.Job.state)
}

// -------------------------------------------------------------------

// JobState

// .livekit.JobStatus status = 1;
inline void JobState::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::livekit::JobStatus JobState::status() const {
  // @@protoc_insertion_point(field_get:livekit.JobState.status)
  return _internal_status();
}
inline void JobState::set_status(::livekit::JobStatus value) {
  _internal_set_status(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:livekit.JobState.status)
}
inline ::livekit::JobStatus JobState::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::livekit::JobStatus>(_impl_.status_);
}
inline void JobState::_internal_set_status(::livekit::JobStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// string error = 2;
inline void JobState::clear_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& JobState::error() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.JobState.error)
  return _internal_error();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void JobState::set_error(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.JobState.error)
}
inline std::string* PROTOBUF_NONNULL JobState::mutable_error()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:livekit.JobState.error)
  return _s;
}
inline const std::string& JobState::_internal_error() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_.Get();
}
inline void JobState::_internal_set_error(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL JobState::_internal_mutable_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE JobState::release_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.JobState.error)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.error_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.error_.Set("", GetArena());
  }
  return released;
}
inline void JobState::set_allocated_error(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.JobState.error)
}

// int64 started_at = 3;
inline void JobState::clear_started_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.started_at_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t JobState::started_at() const {
  // @@protoc_insertion_point(field_get:livekit.JobState.started_at)
  return _internal_started_at();
}
inline void JobState::set_started_at(::int64_t value) {
  _internal_set_started_at(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:livekit.JobState.started_at)
}
inline ::int64_t JobState::_internal_started_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.started_at_;
}
inline void JobState::_internal_set_started_at(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.started_at_ = value;
}

// int64 ended_at = 4;
inline void JobState::clear_ended_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ended_at_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int64_t JobState::ended_at() const {
  // @@protoc_insertion_point(field_get:livekit.JobState.ended_at)
  return _internal_ended_at();
}
inline void JobState::set_ended_at(::int64_t value) {
  _internal_set_ended_at(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:livekit.JobState.ended_at)
}
inline ::int64_t JobState::_internal_ended_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ended_at_;
}
inline void JobState::_internal_set_ended_at(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ended_at_ = value;
}

// int64 updated_at = 5;
inline void JobState::clear_updated_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.updated_at_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int64_t JobState::updated_at() const {
  // @@protoc_insertion_point(field_get:livekit.JobState.updated_at)
  return _internal_updated_at();
}
inline void JobState::set_updated_at(::int64_t value) {
  _internal_set_updated_at(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:livekit.JobState.updated_at)
}
inline ::int64_t JobState::_internal_updated_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.updated_at_;
}
inline void JobState::_internal_set_updated_at(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.updated_at_ = value;
}

// string participant_identity = 6;
inline void JobState::clear_participant_identity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.participant_identity_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& JobState::participant_identity() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.JobState.participant_identity)
  return _internal_participant_identity();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void JobState::set_participant_identity(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.participant_identity_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.JobState.participant_identity)
}
inline std::string* PROTOBUF_NONNULL JobState::mutable_participant_identity()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_participant_identity();
  // @@protoc_insertion_point(field_mutable:livekit.JobState.participant_identity)
  return _s;
}
inline const std::string& JobState::_internal_participant_identity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.participant_identity_.Get();
}
inline void JobState::_internal_set_participant_identity(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.participant_identity_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL JobState::_internal_mutable_participant_identity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.participant_identity_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE JobState::release_participant_identity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.JobState.participant_identity)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.participant_identity_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.participant_identity_.Set("", GetArena());
  }
  return released;
}
inline void JobState::set_allocated_participant_identity(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.participant_identity_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.JobState.participant_identity)
}

// -------------------------------------------------------------------

// WorkerMessage

// .livekit.RegisterWorkerRequest register = 1;
inline bool WorkerMessage::has_register_() const {
  return message_case() == kRegister;
}
inline bool WorkerMessage::_internal_has_register_() const {
  return message_case() == kRegister;
}
inline void WorkerMessage::set_has_register_() {
  _impl_._oneof_case_[0] = kRegister;
}
inline void WorkerMessage::clear_register_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kRegister) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.register__;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.register__);
    }
    clear_has_message();
  }
}
inline ::livekit::RegisterWorkerRequest* PROTOBUF_NULLABLE WorkerMessage::release_register_() {
  // @@protoc_insertion_point(field_release:livekit.WorkerMessage.register)
  if (message_case() == kRegister) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::RegisterWorkerRequest*>(_impl_.message_.register__);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.register__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::RegisterWorkerRequest& WorkerMessage::_internal_register_() const {
  return message_case() == kRegister ? *reinterpret_cast<::livekit::RegisterWorkerRequest*>(_impl_.message_.register__) : reinterpret_cast<::livekit::RegisterWorkerRequest&>(::livekit::_RegisterWorkerRequest_default_instance_);
}
inline const ::livekit::RegisterWorkerRequest& WorkerMessage::register_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.WorkerMessage.register)
  return _internal_register_();
}
inline ::livekit::RegisterWorkerRequest* PROTOBUF_NULLABLE WorkerMessage::unsafe_arena_release_register_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.WorkerMessage.register)
  if (message_case() == kRegister) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::RegisterWorkerRequest*>(_impl_.message_.register__);
    _impl_.message_.register__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WorkerMessage::unsafe_arena_set_allocated_register_(
    ::livekit::RegisterWorkerRequest* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_register_();
    _impl_.message_.register__ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.WorkerMessage.register)
}
inline ::livekit::RegisterWorkerRequest* PROTOBUF_NONNULL WorkerMessage::_internal_mutable_register_() {
  if (message_case() != kRegister) {
    clear_message();
    set_has_register_();
    _impl_.message_.register__ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::RegisterWorkerRequest>(GetArena()));
  }
  return reinterpret_cast<::livekit::RegisterWorkerRequest*>(_impl_.message_.register__);
}
inline ::livekit::RegisterWorkerRequest* PROTOBUF_NONNULL WorkerMessage::mutable_register_()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::RegisterWorkerRequest* _msg = _internal_mutable_register_();
  // @@protoc_insertion_point(field_mutable:livekit.WorkerMessage.register)
  return _msg;
}

// .livekit.AvailabilityResponse availability = 2;
inline bool WorkerMessage::has_availability() const {
  return message_case() == kAvailability;
}
inline bool WorkerMessage::_internal_has_availability() const {
  return message_case() == kAvailability;
}
inline void WorkerMessage::set_has_availability() {
  _impl_._oneof_case_[0] = kAvailability;
}
inline void WorkerMessage::clear_availability() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kAvailability) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.availability_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.availability_);
    }
    clear_has_message();
  }
}
inline ::livekit::AvailabilityResponse* PROTOBUF_NULLABLE WorkerMessage::release_availability() {
  // @@protoc_insertion_point(field_release:livekit.WorkerMessage.availability)
  if (message_case() == kAvailability) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::AvailabilityResponse*>(_impl_.message_.availability_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.availability_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::AvailabilityResponse& WorkerMessage::_internal_availability() const {
  return message_case() == kAvailability ? *reinterpret_cast<::livekit::AvailabilityResponse*>(_impl_.message_.availability_) : reinterpret_cast<::livekit::AvailabilityResponse&>(::livekit::_AvailabilityResponse_default_instance_);
}
inline const ::livekit::AvailabilityResponse& WorkerMessage::availability() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.WorkerMessage.availability)
  return _internal_availability();
}
inline ::livekit::AvailabilityResponse* PROTOBUF_NULLABLE WorkerMessage::unsafe_arena_release_availability() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.WorkerMessage.availability)
  if (message_case() == kAvailability) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::AvailabilityResponse*>(_impl_.message_.availability_);
    _impl_.message_.availability_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WorkerMessage::unsafe_arena_set_allocated_availability(
    ::livekit::AvailabilityResponse* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_availability();
    _impl_.message_.availability_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.WorkerMessage.availability)
}
inline ::livekit::AvailabilityResponse* PROTOBUF_NONNULL WorkerMessage::_internal_mutable_availability() {
  if (message_case() != kAvailability) {
    clear_message();
    set_has_availability();
    _impl_.message_.availability_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::AvailabilityResponse>(GetArena()));
  }
  return reinterpret_cast<::livekit::AvailabilityResponse*>(_impl_.message_.availability_);
}
inline ::livekit::AvailabilityResponse* PROTOBUF_NONNULL WorkerMessage::mutable_availability()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::AvailabilityResponse* _msg = _internal_mutable_availability();
  // @@protoc_insertion_point(field_mutable:livekit.WorkerMessage.availability)
  return _msg;
}

// .livekit.UpdateWorkerStatus update_worker = 3;
inline bool WorkerMessage::has_update_worker() const {
  return message_case() == kUpdateWorker;
}
inline bool WorkerMessage::_internal_has_update_worker() const {
  return message_case() == kUpdateWorker;
}
inline void WorkerMessage::set_has_update_worker() {
  _impl_._oneof_case_[0] = kUpdateWorker;
}
inline void WorkerMessage::clear_update_worker() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kUpdateWorker) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.update_worker_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.update_worker_);
    }
    clear_has_message();
  }
}
inline ::livekit::UpdateWorkerStatus* PROTOBUF_NULLABLE WorkerMessage::release_update_worker() {
  // @@protoc_insertion_point(field_release:livekit.WorkerMessage.update_worker)
  if (message_case() == kUpdateWorker) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::UpdateWorkerStatus*>(_impl_.message_.update_worker_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.update_worker_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::UpdateWorkerStatus& WorkerMessage::_internal_update_worker() const {
  return message_case() == kUpdateWorker ? *reinterpret_cast<::livekit::UpdateWorkerStatus*>(_impl_.message_.update_worker_) : reinterpret_cast<::livekit::UpdateWorkerStatus&>(::livekit::_UpdateWorkerStatus_default_instance_);
}
inline const ::livekit::UpdateWorkerStatus& WorkerMessage::update_worker() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.WorkerMessage.update_worker)
  return _internal_update_worker();
}
inline ::livekit::UpdateWorkerStatus* PROTOBUF_NULLABLE WorkerMessage::unsafe_arena_release_update_worker() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.WorkerMessage.update_worker)
  if (message_case() == kUpdateWorker) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::UpdateWorkerStatus*>(_impl_.message_.update_worker_);
    _impl_.message_.update_worker_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WorkerMessage::unsafe_arena_set_allocated_update_worker(
    ::livekit::UpdateWorkerStatus* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_update_worker();
    _impl_.message_.update_worker_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.WorkerMessage.update_worker)
}
inline ::livekit::UpdateWorkerStatus* PROTOBUF_NONNULL WorkerMessage::_internal_mutable_update_worker() {
  if (message_case() != kUpdateWorker) {
    clear_message();
    set_has_update_worker();
    _impl_.message_.update_worker_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::UpdateWorkerStatus>(GetArena()));
  }
  return reinterpret_cast<::livekit::UpdateWorkerStatus*>(_impl_.message_.update_worker_);
}
inline ::livekit::UpdateWorkerStatus* PROTOBUF_NONNULL WorkerMessage::mutable_update_worker()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::UpdateWorkerStatus* _msg = _internal_mutable_update_worker();
  // @@protoc_insertion_point(field_mutable:livekit.WorkerMessage.update_worker)
  return _msg;
}

// .livekit.UpdateJobStatus update_job = 4;
inline bool WorkerMessage::has_update_job() const {
  return message_case() == kUpdateJob;
}
inline bool WorkerMessage::_internal_has_update_job() const {
  return message_case() == kUpdateJob;
}
inline void WorkerMessage::set_has_update_job() {
  _impl_._oneof_case_[0] = kUpdateJob;
}
inline void WorkerMessage::clear_update_job() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kUpdateJob) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.update_job_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.update_job_);
    }
    clear_has_message();
  }
}
inline ::livekit::UpdateJobStatus* PROTOBUF_NULLABLE WorkerMessage::release_update_job() {
  // @@protoc_insertion_point(field_release:livekit.WorkerMessage.update_job)
  if (message_case() == kUpdateJob) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::UpdateJobStatus*>(_impl_.message_.update_job_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.update_job_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::UpdateJobStatus& WorkerMessage::_internal_update_job() const {
  return message_case() == kUpdateJob ? *reinterpret_cast<::livekit::UpdateJobStatus*>(_impl_.message_.update_job_) : reinterpret_cast<::livekit::UpdateJobStatus&>(::livekit::_UpdateJobStatus_default_instance_);
}
inline const ::livekit::UpdateJobStatus& WorkerMessage::update_job() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.WorkerMessage.update_job)
  return _internal_update_job();
}
inline ::livekit::UpdateJobStatus* PROTOBUF_NULLABLE WorkerMessage::unsafe_arena_release_update_job() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.WorkerMessage.update_job)
  if (message_case() == kUpdateJob) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::UpdateJobStatus*>(_impl_.message_.update_job_);
    _impl_.message_.update_job_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WorkerMessage::unsafe_arena_set_allocated_update_job(
    ::livekit::UpdateJobStatus* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_update_job();
    _impl_.message_.update_job_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.WorkerMessage.update_job)
}
inline ::livekit::UpdateJobStatus* PROTOBUF_NONNULL WorkerMessage::_internal_mutable_update_job() {
  if (message_case() != kUpdateJob) {
    clear_message();
    set_has_update_job();
    _impl_.message_.update_job_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::UpdateJobStatus>(GetArena()));
  }
  return reinterpret_cast<::livekit::UpdateJobStatus*>(_impl_.message_.update_job_);
}
inline ::livekit::UpdateJobStatus* PROTOBUF_NONNULL WorkerMessage::mutable_update_job()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::UpdateJobStatus* _msg = _internal_mutable_update_job();
  // @@protoc_insertion_point(field_mutable:livekit.WorkerMessage.update_job)
  return _msg;
}

// .livekit.WorkerPing ping = 5;
inline bool WorkerMessage::has_ping() const {
  return message_case() == kPing;
}
inline bool WorkerMessage::_internal_has_ping() const {
  return message_case() == kPing;
}
inline void WorkerMessage::set_has_ping() {
  _impl_._oneof_case_[0] = kPing;
}
inline void WorkerMessage::clear_ping() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kPing) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.ping_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.ping_);
    }
    clear_has_message();
  }
}
inline ::livekit::WorkerPing* PROTOBUF_NULLABLE WorkerMessage::release_ping() {
  // @@protoc_insertion_point(field_release:livekit.WorkerMessage.ping)
  if (message_case() == kPing) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::WorkerPing*>(_impl_.message_.ping_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.ping_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::WorkerPing& WorkerMessage::_internal_ping() const {
  return message_case() == kPing ? *reinterpret_cast<::livekit::WorkerPing*>(_impl_.message_.ping_) : reinterpret_cast<::livekit::WorkerPing&>(::livekit::_WorkerPing_default_instance_);
}
inline const ::livekit::WorkerPing& WorkerMessage::ping() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.WorkerMessage.ping)
  return _internal_ping();
}
inline ::livekit::WorkerPing* PROTOBUF_NULLABLE WorkerMessage::unsafe_arena_release_ping() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.WorkerMessage.ping)
  if (message_case() == kPing) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::WorkerPing*>(_impl_.message_.ping_);
    _impl_.message_.ping_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WorkerMessage::unsafe_arena_set_allocated_ping(
    ::livekit::WorkerPing* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_ping();
    _impl_.message_.ping_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.WorkerMessage.ping)
}
inline ::livekit::WorkerPing* PROTOBUF_NONNULL WorkerMessage::_internal_mutable_ping() {
  if (message_case() != kPing) {
    clear_message();
    set_has_ping();
    _impl_.message_.ping_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::WorkerPing>(GetArena()));
  }
  return reinterpret_cast<::livekit::WorkerPing*>(_impl_.message_.ping_);
}
inline ::livekit::WorkerPing* PROTOBUF_NONNULL WorkerMessage::mutable_ping()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::WorkerPing* _msg = _internal_mutable_ping();
  // @@protoc_insertion_point(field_mutable:livekit.WorkerMessage.ping)
  return _msg;
}

// .livekit.SimulateJobRequest simulate_job = 6;
inline bool WorkerMessage::has_simulate_job() const {
  return message_case() == kSimulateJob;
}
inline bool WorkerMessage::_internal_has_simulate_job() const {
  return message_case() == kSimulateJob;
}
inline void WorkerMessage::set_has_simulate_job() {
  _impl_._oneof_case_[0] = kSimulateJob;
}
inline void WorkerMessage::clear_simulate_job() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kSimulateJob) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.simulate_job_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.simulate_job_);
    }
    clear_has_message();
  }
}
inline ::livekit::SimulateJobRequest* PROTOBUF_NULLABLE WorkerMessage::release_simulate_job() {
  // @@protoc_insertion_point(field_release:livekit.WorkerMessage.simulate_job)
  if (message_case() == kSimulateJob) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::SimulateJobRequest*>(_impl_.message_.simulate_job_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.simulate_job_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::SimulateJobRequest& WorkerMessage::_internal_simulate_job() const {
  return message_case() == kSimulateJob ? *reinterpret_cast<::livekit::SimulateJobRequest*>(_impl_.message_.simulate_job_) : reinterpret_cast<::livekit::SimulateJobRequest&>(::livekit::_SimulateJobRequest_default_instance_);
}
inline const ::livekit::SimulateJobRequest& WorkerMessage::simulate_job() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.WorkerMessage.simulate_job)
  return _internal_simulate_job();
}
inline ::livekit::SimulateJobRequest* PROTOBUF_NULLABLE WorkerMessage::unsafe_arena_release_simulate_job() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.WorkerMessage.simulate_job)
  if (message_case() == kSimulateJob) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::SimulateJobRequest*>(_impl_.message_.simulate_job_);
    _impl_.message_.simulate_job_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WorkerMessage::unsafe_arena_set_allocated_simulate_job(
    ::livekit::SimulateJobRequest* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_simulate_job();
    _impl_.message_.simulate_job_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.WorkerMessage.simulate_job)
}
inline ::livekit::SimulateJobRequest* PROTOBUF_NONNULL WorkerMessage::_internal_mutable_simulate_job() {
  if (message_case() != kSimulateJob) {
    clear_message();
    set_has_simulate_job();
    _impl_.message_.simulate_job_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::SimulateJobRequest>(GetArena()));
  }
  return reinterpret_cast<::livekit::SimulateJobRequest*>(_impl_.message_.simulate_job_);
}
inline ::livekit::SimulateJobRequest* PROTOBUF_NONNULL WorkerMessage::mutable_simulate_job()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::SimulateJobRequest* _msg = _internal_mutable_simulate_job();
  // @@protoc_insertion_point(field_mutable:livekit.WorkerMessage.simulate_job)
  return _msg;
}

// .livekit.MigrateJobRequest migrate_job = 7;
inline bool WorkerMessage::has_migrate_job() const {
  return message_case() == kMigrateJob;
}
inline bool WorkerMessage::_internal_has_migrate_job() const {
  return message_case() == kMigrateJob;
}
inline void WorkerMessage::set_has_migrate_job() {
  _impl_._oneof_case_[0] = kMigrateJob;
}
inline void WorkerMessage::clear_migrate_job() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kMigrateJob) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.migrate_job_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.migrate_job_);
    }
    clear_has_message();
  }
}
inline ::livekit::MigrateJobRequest* PROTOBUF_NULLABLE WorkerMessage::release_migrate_job() {
  // @@protoc_insertion_point(field_release:livekit.WorkerMessage.migrate_job)
  if (message_case() == kMigrateJob) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::MigrateJobRequest*>(_impl_.message_.migrate_job_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.migrate_job_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::MigrateJobRequest& WorkerMessage::_internal_migrate_job() const {
  return message_case() == kMigrateJob ? *reinterpret_cast<::livekit::MigrateJobRequest*>(_impl_.message_.migrate_job_) : reinterpret_cast<::livekit::MigrateJobRequest&>(::livekit::_MigrateJobRequest_default_instance_);
}
inline const ::livekit::MigrateJobRequest& WorkerMessage::migrate_job() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.WorkerMessage.migrate_job)
  return _internal_migrate_job();
}
inline ::livekit::MigrateJobRequest* PROTOBUF_NULLABLE WorkerMessage::unsafe_arena_release_migrate_job() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.WorkerMessage.migrate_job)
  if (message_case() == kMigrateJob) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::MigrateJobRequest*>(_impl_.message_.migrate_job_);
    _impl_.message_.migrate_job_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WorkerMessage::unsafe_arena_set_allocated_migrate_job(
    ::livekit::MigrateJobRequest* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_migrate_job();
    _impl_.message_.migrate_job_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.WorkerMessage.migrate_job)
}
inline ::livekit::MigrateJobRequest* PROTOBUF_NONNULL WorkerMessage::_internal_mutable_migrate_job() {
  if (message_case() != kMigrateJob) {
    clear_message();
    set_has_migrate_job();
    _impl_.message_.migrate_job_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::MigrateJobRequest>(GetArena()));
  }
  return reinterpret_cast<::livekit::MigrateJobRequest*>(_impl_.message_.migrate_job_);
}
inline ::livekit::MigrateJobRequest* PROTOBUF_NONNULL WorkerMessage::mutable_migrate_job()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::MigrateJobRequest* _msg = _internal_mutable_migrate_job();
  // @@protoc_insertion_point(field_mutable:livekit.WorkerMessage.migrate_job)
  return _msg;
}

inline bool WorkerMessage::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void WorkerMessage::clear_has_message() {
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}
inline WorkerMessage::MessageCase WorkerMessage::message_case() const {
  return WorkerMessage::MessageCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ServerMessage

// .livekit.RegisterWorkerResponse register = 1;
inline bool ServerMessage::has_register_() const {
  return message_case() == kRegister;
}
inline bool ServerMessage::_internal_has_register_() const {
  return message_case() == kRegister;
}
inline void ServerMessage::set_has_register_() {
  _impl_._oneof_case_[0] = kRegister;
}
inline void ServerMessage::clear_register_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kRegister) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.register__;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.register__);
    }
    clear_has_message();
  }
}
inline ::livekit::RegisterWorkerResponse* PROTOBUF_NULLABLE ServerMessage::release_register_() {
  // @@protoc_insertion_point(field_release:livekit.ServerMessage.register)
  if (message_case() == kRegister) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::RegisterWorkerResponse*>(_impl_.message_.register__);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.register__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::RegisterWorkerResponse& ServerMessage::_internal_register_() const {
  return message_case() == kRegister ? *reinterpret_cast<::livekit::RegisterWorkerResponse*>(_impl_.message_.register__) : reinterpret_cast<::livekit::RegisterWorkerResponse&>(::livekit::_RegisterWorkerResponse_default_instance_);
}
inline const ::livekit::RegisterWorkerResponse& ServerMessage::register_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.ServerMessage.register)
  return _internal_register_();
}
inline ::livekit::RegisterWorkerResponse* PROTOBUF_NULLABLE ServerMessage::unsafe_arena_release_register_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.ServerMessage.register)
  if (message_case() == kRegister) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::RegisterWorkerResponse*>(_impl_.message_.register__);
    _impl_.message_.register__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_register_(
    ::livekit::RegisterWorkerResponse* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_register_();
    _impl_.message_.register__ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.ServerMessage.register)
}
inline ::livekit::RegisterWorkerResponse* PROTOBUF_NONNULL ServerMessage::_internal_mutable_register_() {
  if (message_case() != kRegister) {
    clear_message();
    set_has_register_();
    _impl_.message_.register__ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::RegisterWorkerResponse>(GetArena()));
  }
  return reinterpret_cast<::livekit::RegisterWorkerResponse*>(_impl_.message_.register__);
}
inline ::livekit::RegisterWorkerResponse* PROTOBUF_NONNULL ServerMessage::mutable_register_()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::RegisterWorkerResponse* _msg = _internal_mutable_register_();
  // @@protoc_insertion_point(field_mutable:livekit.ServerMessage.register)
  return _msg;
}

// .livekit.AvailabilityRequest availability = 2;
inline bool ServerMessage::has_availability() const {
  return message_case() == kAvailability;
}
inline bool ServerMessage::_internal_has_availability() const {
  return message_case() == kAvailability;
}
inline void ServerMessage::set_has_availability() {
  _impl_._oneof_case_[0] = kAvailability;
}
inline void ServerMessage::clear_availability() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kAvailability) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.availability_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.availability_);
    }
    clear_has_message();
  }
}
inline ::livekit::AvailabilityRequest* PROTOBUF_NULLABLE ServerMessage::release_availability() {
  // @@protoc_insertion_point(field_release:livekit.ServerMessage.availability)
  if (message_case() == kAvailability) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::AvailabilityRequest*>(_impl_.message_.availability_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.availability_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::AvailabilityRequest& ServerMessage::_internal_availability() const {
  return message_case() == kAvailability ? *reinterpret_cast<::livekit::AvailabilityRequest*>(_impl_.message_.availability_) : reinterpret_cast<::livekit::AvailabilityRequest&>(::livekit::_AvailabilityRequest_default_instance_);
}
inline const ::livekit::AvailabilityRequest& ServerMessage::availability() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.ServerMessage.availability)
  return _internal_availability();
}
inline ::livekit::AvailabilityRequest* PROTOBUF_NULLABLE ServerMessage::unsafe_arena_release_availability() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.ServerMessage.availability)
  if (message_case() == kAvailability) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::AvailabilityRequest*>(_impl_.message_.availability_);
    _impl_.message_.availability_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_availability(
    ::livekit::AvailabilityRequest* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_availability();
    _impl_.message_.availability_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.ServerMessage.availability)
}
inline ::livekit::AvailabilityRequest* PROTOBUF_NONNULL ServerMessage::_internal_mutable_availability() {
  if (message_case() != kAvailability) {
    clear_message();
    set_has_availability();
    _impl_.message_.availability_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::AvailabilityRequest>(GetArena()));
  }
  return reinterpret_cast<::livekit::AvailabilityRequest*>(_impl_.message_.availability_);
}
inline ::livekit::AvailabilityRequest* PROTOBUF_NONNULL ServerMessage::mutable_availability()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::AvailabilityRequest* _msg = _internal_mutable_availability();
  // @@protoc_insertion_point(field_mutable:livekit.ServerMessage.availability)
  return _msg;
}

// .livekit.JobAssignment assignment = 3;
inline bool ServerMessage::has_assignment() const {
  return message_case() == kAssignment;
}
inline bool ServerMessage::_internal_has_assignment() const {
  return message_case() == kAssignment;
}
inline void ServerMessage::set_has_assignment() {
  _impl_._oneof_case_[0] = kAssignment;
}
inline void ServerMessage::clear_assignment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kAssignment) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.assignment_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.assignment_);
    }
    clear_has_message();
  }
}
inline ::livekit::JobAssignment* PROTOBUF_NULLABLE ServerMessage::release_assignment() {
  // @@protoc_insertion_point(field_release:livekit.ServerMessage.assignment)
  if (message_case() == kAssignment) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::JobAssignment*>(_impl_.message_.assignment_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.assignment_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::JobAssignment& ServerMessage::_internal_assignment() const {
  return message_case() == kAssignment ? *reinterpret_cast<::livekit::JobAssignment*>(_impl_.message_.assignment_) : reinterpret_cast<::livekit::JobAssignment&>(::livekit::_JobAssignment_default_instance_);
}
inline const ::livekit::JobAssignment& ServerMessage::assignment() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.ServerMessage.assignment)
  return _internal_assignment();
}
inline ::livekit::JobAssignment* PROTOBUF_NULLABLE ServerMessage::unsafe_arena_release_assignment() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.ServerMessage.assignment)
  if (message_case() == kAssignment) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::JobAssignment*>(_impl_.message_.assignment_);
    _impl_.message_.assignment_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_assignment(
    ::livekit::JobAssignment* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_assignment();
    _impl_.message_.assignment_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.ServerMessage.assignment)
}
inline ::livekit::JobAssignment* PROTOBUF_NONNULL ServerMessage::_internal_mutable_assignment() {
  if (message_case() != kAssignment) {
    clear_message();
    set_has_assignment();
    _impl_.message_.assignment_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::JobAssignment>(GetArena()));
  }
  return reinterpret_cast<::livekit::JobAssignment*>(_impl_.message_.assignment_);
}
inline ::livekit::JobAssignment* PROTOBUF_NONNULL ServerMessage::mutable_assignment()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::JobAssignment* _msg = _internal_mutable_assignment();
  // @@protoc_insertion_point(field_mutable:livekit.ServerMessage.assignment)
  return _msg;
}

// .livekit.JobTermination termination = 5;
inline bool ServerMessage::has_termination() const {
  return message_case() == kTermination;
}
inline bool ServerMessage::_internal_has_termination() const {
  return message_case() == kTermination;
}
inline void ServerMessage::set_has_termination() {
  _impl_._oneof_case_[0] = kTermination;
}
inline void ServerMessage::clear_termination() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kTermination) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.termination_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.termination_);
    }
    clear_has_message();
  }
}
inline ::livekit::JobTermination* PROTOBUF_NULLABLE ServerMessage::release_termination() {
  // @@protoc_insertion_point(field_release:livekit.ServerMessage.termination)
  if (message_case() == kTermination) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::JobTermination*>(_impl_.message_.termination_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.termination_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::JobTermination& ServerMessage::_internal_termination() const {
  return message_case() == kTermination ? *reinterpret_cast<::livekit::JobTermination*>(_impl_.message_.termination_) : reinterpret_cast<::livekit::JobTermination&>(::livekit::_JobTermination_default_instance_);
}
inline const ::livekit::JobTermination& ServerMessage::termination() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.ServerMessage.termination)
  return _internal_termination();
}
inline ::livekit::JobTermination* PROTOBUF_NULLABLE ServerMessage::unsafe_arena_release_termination() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.ServerMessage.termination)
  if (message_case() == kTermination) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::JobTermination*>(_impl_.message_.termination_);
    _impl_.message_.termination_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_termination(
    ::livekit::JobTermination* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_termination();
    _impl_.message_.termination_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.ServerMessage.termination)
}
inline ::livekit::JobTermination* PROTOBUF_NONNULL ServerMessage::_internal_mutable_termination() {
  if (message_case() != kTermination) {
    clear_message();
    set_has_termination();
    _impl_.message_.termination_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::JobTermination>(GetArena()));
  }
  return reinterpret_cast<::livekit::JobTermination*>(_impl_.message_.termination_);
}
inline ::livekit::JobTermination* PROTOBUF_NONNULL ServerMessage::mutable_termination()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::JobTermination* _msg = _internal_mutable_termination();
  // @@protoc_insertion_point(field_mutable:livekit.ServerMessage.termination)
  return _msg;
}

// .livekit.WorkerPong pong = 4;
inline bool ServerMessage::has_pong() const {
  return message_case() == kPong;
}
inline bool ServerMessage::_internal_has_pong() const {
  return message_case() == kPong;
}
inline void ServerMessage::set_has_pong() {
  _impl_._oneof_case_[0] = kPong;
}
inline void ServerMessage::clear_pong() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kPong) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.pong_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.pong_);
    }
    clear_has_message();
  }
}
inline ::livekit::WorkerPong* PROTOBUF_NULLABLE ServerMessage::release_pong() {
  // @@protoc_insertion_point(field_release:livekit.ServerMessage.pong)
  if (message_case() == kPong) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::WorkerPong*>(_impl_.message_.pong_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.pong_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::WorkerPong& ServerMessage::_internal_pong() const {
  return message_case() == kPong ? *reinterpret_cast<::livekit::WorkerPong*>(_impl_.message_.pong_) : reinterpret_cast<::livekit::WorkerPong&>(::livekit::_WorkerPong_default_instance_);
}
inline const ::livekit::WorkerPong& ServerMessage::pong() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.ServerMessage.pong)
  return _internal_pong();
}
inline ::livekit::WorkerPong* PROTOBUF_NULLABLE ServerMessage::unsafe_arena_release_pong() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.ServerMessage.pong)
  if (message_case() == kPong) {
    clear_has_message();
    auto* temp = reinterpret_cast<::livekit::WorkerPong*>(_impl_.message_.pong_);
    _impl_.message_.pong_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_pong(
    ::livekit::WorkerPong* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_pong();
    _impl_.message_.pong_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.ServerMessage.pong)
}
inline ::livekit::WorkerPong* PROTOBUF_NONNULL ServerMessage::_internal_mutable_pong() {
  if (message_case() != kPong) {
    clear_message();
    set_has_pong();
    _impl_.message_.pong_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::WorkerPong>(GetArena()));
  }
  return reinterpret_cast<::livekit::WorkerPong*>(_impl_.message_.pong_);
}
inline ::livekit::WorkerPong* PROTOBUF_NONNULL ServerMessage::mutable_pong()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::WorkerPong* _msg = _internal_mutable_pong();
  // @@protoc_insertion_point(field_mutable:livekit.ServerMessage.pong)
  return _msg;
}

inline bool ServerMessage::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void ServerMessage::clear_has_message() {
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}
inline ServerMessage::MessageCase ServerMessage::message_case() const {
  return ServerMessage::MessageCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SimulateJobRequest

// .livekit.JobType type = 1;
inline void SimulateJobRequest::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::livekit::JobType SimulateJobRequest::type() const {
  // @@protoc_insertion_point(field_get:livekit.SimulateJobRequest.type)
  return _internal_type();
}
inline void SimulateJobRequest::set_type(::livekit::JobType value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:livekit.SimulateJobRequest.type)
}
inline ::livekit::JobType SimulateJobRequest::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::livekit::JobType>(_impl_.type_);
}
inline void SimulateJobRequest::_internal_set_type(::livekit::JobType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// .livekit.Room room = 2;
inline bool SimulateJobRequest::has_room() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.room_ != nullptr);
  return value;
}
inline const ::livekit::Room& SimulateJobRequest::_internal_room() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::livekit::Room* p = _impl_.room_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::Room&>(::livekit::_Room_default_instance_);
}
inline const ::livekit::Room& SimulateJobRequest::room() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SimulateJobRequest.room)
  return _internal_room();
}
inline void SimulateJobRequest::unsafe_arena_set_allocated_room(
    ::livekit::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.room_);
  }
  _impl_.room_ = reinterpret_cast<::livekit::Room*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SimulateJobRequest.room)
}
inline ::livekit::Room* PROTOBUF_NULLABLE SimulateJobRequest::release_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::Room* released = _impl_.room_;
  _impl_.room_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::livekit::Room* PROTOBUF_NULLABLE SimulateJobRequest::unsafe_arena_release_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.SimulateJobRequest.room)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::Room* temp = _impl_.room_;
  _impl_.room_ = nullptr;
  return temp;
}
inline ::livekit::Room* PROTOBUF_NONNULL SimulateJobRequest::_internal_mutable_room() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.room_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::livekit::Room>(GetArena());
    _impl_.room_ = reinterpret_cast<::livekit::Room*>(p);
  }
  return _impl_.room_;
}
inline ::livekit::Room* PROTOBUF_NONNULL SimulateJobRequest::mutable_room()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::livekit::Room* _msg = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:livekit.SimulateJobRequest.room)
  return _msg;
}
inline void SimulateJobRequest::set_allocated_room(::livekit::Room* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.room_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.room_ = reinterpret_cast<::livekit::Room*>(value);
  // @@protoc_insertion_point(field_set_allocated:livekit.SimulateJobRequest.room)
}

// .livekit.ParticipantInfo participant = 3;
inline bool SimulateJobRequest::has_participant() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.participant_ != nullptr);
  return value;
}
inline const ::livekit::ParticipantInfo& SimulateJobRequest::_internal_participant() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::livekit::ParticipantInfo* p = _impl_.participant_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::ParticipantInfo&>(::livekit::_ParticipantInfo_default_instance_);
}
inline const ::livekit::ParticipantInfo& SimulateJobRequest::participant() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SimulateJobRequest.participant)
  return _internal_participant();
}
inline void SimulateJobRequest::unsafe_arena_set_allocated_participant(
    ::livekit::ParticipantInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.participant_);
  }
  _impl_.participant_ = reinterpret_cast<::livekit::ParticipantInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SimulateJobRequest.participant)
}
inline ::livekit::ParticipantInfo* PROTOBUF_NULLABLE SimulateJobRequest::release_participant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::ParticipantInfo* released = _impl_.participant_;
  _impl_.participant_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::livekit::ParticipantInfo* PROTOBUF_NULLABLE SimulateJobRequest::unsafe_arena_release_participant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.SimulateJobRequest.participant)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::ParticipantInfo* temp = _impl_.participant_;
  _impl_.participant_ = nullptr;
  return temp;
}
inline ::livekit::ParticipantInfo* PROTOBUF_NONNULL SimulateJobRequest::_internal_mutable_participant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.participant_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::livekit::ParticipantInfo>(GetArena());
    _impl_.participant_ = reinterpret_cast<::livekit::ParticipantInfo*>(p);
  }
  return _impl_.participant_;
}
inline ::livekit::ParticipantInfo* PROTOBUF_NONNULL SimulateJobRequest::mutable_participant()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::livekit::ParticipantInfo* _msg = _internal_mutable_participant();
  // @@protoc_insertion_point(field_mutable:livekit.SimulateJobRequest.participant)
  return _msg;
}
inline void SimulateJobRequest::set_allocated_participant(::livekit::ParticipantInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.participant_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.participant_ = reinterpret_cast<::livekit::ParticipantInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:livekit.SimulateJobRequest.participant)
}

// -------------------------------------------------------------------

// WorkerPing

// int64 timestamp = 1;
inline void WorkerPing::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t WorkerPing::timestamp() const {
  // @@protoc_insertion_point(field_get:livekit.WorkerPing.timestamp)
  return _internal_timestamp();
}
inline void WorkerPing::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:livekit.WorkerPing.timestamp)
}
inline ::int64_t WorkerPing::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_;
}
inline void WorkerPing::_internal_set_timestamp(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = value;
}

// -------------------------------------------------------------------

// WorkerPong

// int64 last_timestamp = 1;
inline void WorkerPong::clear_last_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_timestamp_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t WorkerPong::last_timestamp() const {
  // @@protoc_insertion_point(field_get:livekit.WorkerPong.last_timestamp)
  return _internal_last_timestamp();
}
inline void WorkerPong::set_last_timestamp(::int64_t value) {
  _internal_set_last_timestamp(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:livekit.WorkerPong.last_timestamp)
}
inline ::int64_t WorkerPong::_internal_last_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.last_timestamp_;
}
inline void WorkerPong::_internal_set_last_timestamp(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_timestamp_ = value;
}

// int64 timestamp = 2;
inline void WorkerPong::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t WorkerPong::timestamp() const {
  // @@protoc_insertion_point(field_get:livekit.WorkerPong.timestamp)
  return _internal_timestamp();
}
inline void WorkerPong::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:livekit.WorkerPong.timestamp)
}
inline ::int64_t WorkerPong::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_;
}
inline void WorkerPong::_internal_set_timestamp(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = value;
}

// -------------------------------------------------------------------

// RegisterWorkerRequest

// .livekit.JobType type = 1;
inline void RegisterWorkerRequest::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::livekit::JobType RegisterWorkerRequest::type() const {
  // @@protoc_insertion_point(field_get:livekit.RegisterWorkerRequest.type)
  return _internal_type();
}
inline void RegisterWorkerRequest::set_type(::livekit::JobType value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:livekit.RegisterWorkerRequest.type)
}
inline ::livekit::JobType RegisterWorkerRequest::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::livekit::JobType>(_impl_.type_);
}
inline void RegisterWorkerRequest::_internal_set_type(::livekit::JobType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// string agent_name = 8;
inline void RegisterWorkerRequest::clear_agent_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agent_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& RegisterWorkerRequest::agent_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.RegisterWorkerRequest.agent_name)
  return _internal_agent_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RegisterWorkerRequest::set_agent_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.agent_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.RegisterWorkerRequest.agent_name)
}
inline std::string* PROTOBUF_NONNULL RegisterWorkerRequest::mutable_agent_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_agent_name();
  // @@protoc_insertion_point(field_mutable:livekit.RegisterWorkerRequest.agent_name)
  return _s;
}
inline const std::string& RegisterWorkerRequest::_internal_agent_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.agent_name_.Get();
}
inline void RegisterWorkerRequest::_internal_set_agent_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.agent_name_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL RegisterWorkerRequest::_internal_mutable_agent_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.agent_name_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE RegisterWorkerRequest::release_agent_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.RegisterWorkerRequest.agent_name)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.agent_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.agent_name_.Set("", GetArena());
  }
  return released;
}
inline void RegisterWorkerRequest::set_allocated_agent_name(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.agent_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.agent_name_.IsDefault()) {
    _impl_.agent_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.RegisterWorkerRequest.agent_name)
}

// string version = 3;
inline void RegisterWorkerRequest::clear_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RegisterWorkerRequest::version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.RegisterWorkerRequest.version)
  return _internal_version();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RegisterWorkerRequest::set_version(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.RegisterWorkerRequest.version)
}
inline std::string* PROTOBUF_NONNULL RegisterWorkerRequest::mutable_version()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:livekit.RegisterWorkerRequest.version)
  return _s;
}
inline const std::string& RegisterWorkerRequest::_internal_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.version_.Get();
}
inline void RegisterWorkerRequest::_internal_set_version(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.version_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL RegisterWorkerRequest::_internal_mutable_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.version_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE RegisterWorkerRequest::release_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.RegisterWorkerRequest.version)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.version_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.version_.Set("", GetArena());
  }
  return released;
}
inline void RegisterWorkerRequest::set_allocated_version(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.version_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.RegisterWorkerRequest.version)
}

// uint32 ping_interval = 5;
inline void RegisterWorkerRequest::clear_ping_interval() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ping_interval_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint32_t RegisterWorkerRequest::ping_interval() const {
  // @@protoc_insertion_point(field_get:livekit.RegisterWorkerRequest.ping_interval)
  return _internal_ping_interval();
}
inline void RegisterWorkerRequest::set_ping_interval(::uint32_t value) {
  _internal_set_ping_interval(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:livekit.RegisterWorkerRequest.ping_interval)
}
inline ::uint32_t RegisterWorkerRequest::_internal_ping_interval() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ping_interval_;
}
inline void RegisterWorkerRequest::_internal_set_ping_interval(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ping_interval_ = value;
}

// optional string namespace = 6;
inline bool RegisterWorkerRequest::has_namespace_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RegisterWorkerRequest::clear_namespace_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.namespace__.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RegisterWorkerRequest::namespace_() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.RegisterWorkerRequest.namespace)
  return _internal_namespace_();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RegisterWorkerRequest::set_namespace_(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.namespace__.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.RegisterWorkerRequest.namespace)
}
inline std::string* PROTOBUF_NONNULL RegisterWorkerRequest::mutable_namespace_()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:livekit.RegisterWorkerRequest.namespace)
  return _s;
}
inline const std::string& RegisterWorkerRequest::_internal_namespace_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.namespace__.Get();
}
inline void RegisterWorkerRequest::_internal_set_namespace_(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.namespace__.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL RegisterWorkerRequest::_internal_mutable_namespace_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.namespace__.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE RegisterWorkerRequest::release_namespace_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.RegisterWorkerRequest.namespace)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.namespace__.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.namespace__.Set("", GetArena());
  }
  return released;
}
inline void RegisterWorkerRequest::set_allocated_namespace_(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.namespace__.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.namespace__.IsDefault()) {
    _impl_.namespace__.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.RegisterWorkerRequest.namespace)
}

// .livekit.ParticipantPermission allowed_permissions = 7;
inline bool RegisterWorkerRequest::has_allowed_permissions() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.allowed_permissions_ != nullptr);
  return value;
}
inline const ::livekit::ParticipantPermission& RegisterWorkerRequest::_internal_allowed_permissions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::livekit::ParticipantPermission* p = _impl_.allowed_permissions_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::ParticipantPermission&>(::livekit::_ParticipantPermission_default_instance_);
}
inline const ::livekit::ParticipantPermission& RegisterWorkerRequest::allowed_permissions() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.RegisterWorkerRequest.allowed_permissions)
  return _internal_allowed_permissions();
}
inline void RegisterWorkerRequest::unsafe_arena_set_allocated_allowed_permissions(
    ::livekit::ParticipantPermission* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.allowed_permissions_);
  }
  _impl_.allowed_permissions_ = reinterpret_cast<::livekit::ParticipantPermission*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.RegisterWorkerRequest.allowed_permissions)
}
inline ::livekit::ParticipantPermission* PROTOBUF_NULLABLE RegisterWorkerRequest::release_allowed_permissions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::livekit::ParticipantPermission* released = _impl_.allowed_permissions_;
  _impl_.allowed_permissions_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::livekit::ParticipantPermission* PROTOBUF_NULLABLE RegisterWorkerRequest::unsafe_arena_release_allowed_permissions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.RegisterWorkerRequest.allowed_permissions)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::livekit::ParticipantPermission* temp = _impl_.allowed_permissions_;
  _impl_.allowed_permissions_ = nullptr;
  return temp;
}
inline ::livekit::ParticipantPermission* PROTOBUF_NONNULL RegisterWorkerRequest::_internal_mutable_allowed_permissions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.allowed_permissions_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::livekit::ParticipantPermission>(GetArena());
    _impl_.allowed_permissions_ = reinterpret_cast<::livekit::ParticipantPermission*>(p);
  }
  return _impl_.allowed_permissions_;
}
inline ::livekit::ParticipantPermission* PROTOBUF_NONNULL RegisterWorkerRequest::mutable_allowed_permissions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::livekit::ParticipantPermission* _msg = _internal_mutable_allowed_permissions();
  // @@protoc_insertion_point(field_mutable:livekit.RegisterWorkerRequest.allowed_permissions)
  return _msg;
}
inline void RegisterWorkerRequest::set_allocated_allowed_permissions(::livekit::ParticipantPermission* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.allowed_permissions_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.allowed_permissions_ = reinterpret_cast<::livekit::ParticipantPermission*>(value);
  // @@protoc_insertion_point(field_set_allocated:livekit.RegisterWorkerRequest.allowed_permissions)
}

// -------------------------------------------------------------------

// RegisterWorkerResponse

// string worker_id = 1;
inline void RegisterWorkerResponse::clear_worker_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.worker_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RegisterWorkerResponse::worker_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.RegisterWorkerResponse.worker_id)
  return _internal_worker_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RegisterWorkerResponse::set_worker_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.worker_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.RegisterWorkerResponse.worker_id)
}
inline std::string* PROTOBUF_NONNULL RegisterWorkerResponse::mutable_worker_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_worker_id();
  // @@protoc_insertion_point(field_mutable:livekit.RegisterWorkerResponse.worker_id)
  return _s;
}
inline const std::string& RegisterWorkerResponse::_internal_worker_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.worker_id_.Get();
}
inline void RegisterWorkerResponse::_internal_set_worker_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.worker_id_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL RegisterWorkerResponse::_internal_mutable_worker_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.worker_id_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE RegisterWorkerResponse::release_worker_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.RegisterWorkerResponse.worker_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.worker_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.worker_id_.Set("", GetArena());
  }
  return released;
}
inline void RegisterWorkerResponse::set_allocated_worker_id(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.worker_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.worker_id_.IsDefault()) {
    _impl_.worker_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.RegisterWorkerResponse.worker_id)
}

// .livekit.ServerInfo server_info = 3;
inline bool RegisterWorkerResponse::has_server_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.server_info_ != nullptr);
  return value;
}
inline const ::livekit::ServerInfo& RegisterWorkerResponse::_internal_server_info() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::livekit::ServerInfo* p = _impl_.server_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::ServerInfo&>(::livekit::_ServerInfo_default_instance_);
}
inline const ::livekit::ServerInfo& RegisterWorkerResponse::server_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.RegisterWorkerResponse.server_info)
  return _internal_server_info();
}
inline void RegisterWorkerResponse::unsafe_arena_set_allocated_server_info(
    ::livekit::ServerInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.server_info_);
  }
  _impl_.server_info_ = reinterpret_cast<::livekit::ServerInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.RegisterWorkerResponse.server_info)
}
inline ::livekit::ServerInfo* PROTOBUF_NULLABLE RegisterWorkerResponse::release_server_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::ServerInfo* released = _impl_.server_info_;
  _impl_.server_info_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::livekit::ServerInfo* PROTOBUF_NULLABLE RegisterWorkerResponse::unsafe_arena_release_server_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.RegisterWorkerResponse.server_info)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::ServerInfo* temp = _impl_.server_info_;
  _impl_.server_info_ = nullptr;
  return temp;
}
inline ::livekit::ServerInfo* PROTOBUF_NONNULL RegisterWorkerResponse::_internal_mutable_server_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.server_info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::livekit::ServerInfo>(GetArena());
    _impl_.server_info_ = reinterpret_cast<::livekit::ServerInfo*>(p);
  }
  return _impl_.server_info_;
}
inline ::livekit::ServerInfo* PROTOBUF_NONNULL RegisterWorkerResponse::mutable_server_info()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::livekit::ServerInfo* _msg = _internal_mutable_server_info();
  // @@protoc_insertion_point(field_mutable:livekit.RegisterWorkerResponse.server_info)
  return _msg;
}
inline void RegisterWorkerResponse::set_allocated_server_info(::livekit::ServerInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.server_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.server_info_ = reinterpret_cast<::livekit::ServerInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:livekit.RegisterWorkerResponse.server_info)
}

// -------------------------------------------------------------------

// MigrateJobRequest

// repeated string job_ids = 2;
inline int MigrateJobRequest::_internal_job_ids_size() const {
  return _internal_job_ids().size();
}
inline int MigrateJobRequest::job_ids_size() const {
  return _internal_job_ids_size();
}
inline void MigrateJobRequest::clear_job_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.job_ids_.Clear();
}
inline std::string* PROTOBUF_NONNULL MigrateJobRequest::add_job_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_job_ids()->Add();
  // @@protoc_insertion_point(field_add_mutable:livekit.MigrateJobRequest.job_ids)
  return _s;
}
inline const std::string& MigrateJobRequest::job_ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.MigrateJobRequest.job_ids)
  return _internal_job_ids().Get(index);
}
inline std::string* PROTOBUF_NONNULL MigrateJobRequest::mutable_job_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.MigrateJobRequest.job_ids)
  return _internal_mutable_job_ids()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void MigrateJobRequest::set_job_ids(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_job_ids()->Mutable(index), std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:livekit.MigrateJobRequest.job_ids)
}
template <typename Arg_, typename... Args_>
inline void MigrateJobRequest::add_job_ids(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_job_ids(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:livekit.MigrateJobRequest.job_ids)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>& MigrateJobRequest::job_ids() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.MigrateJobRequest.job_ids)
  return _internal_job_ids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* PROTOBUF_NONNULL
MigrateJobRequest::mutable_job_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.MigrateJobRequest.job_ids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_job_ids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
MigrateJobRequest::_internal_job_ids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.job_ids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>* PROTOBUF_NONNULL
MigrateJobRequest::_internal_mutable_job_ids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.job_ids_;
}

// -------------------------------------------------------------------

// AvailabilityRequest

// .livekit.Job job = 1;
inline bool AvailabilityRequest::has_job() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.job_ != nullptr);
  return value;
}
inline void AvailabilityRequest::clear_job() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.job_ != nullptr) _impl_.job_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::livekit::Job& AvailabilityRequest::_internal_job() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::livekit::Job* p = _impl_.job_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::Job&>(::livekit::_Job_default_instance_);
}
inline const ::livekit::Job& AvailabilityRequest::job() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.AvailabilityRequest.job)
  return _internal_job();
}
inline void AvailabilityRequest::unsafe_arena_set_allocated_job(
    ::livekit::Job* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.job_);
  }
  _impl_.job_ = reinterpret_cast<::livekit::Job*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.AvailabilityRequest.job)
}
inline ::livekit::Job* PROTOBUF_NULLABLE AvailabilityRequest::release_job() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::Job* released = _impl_.job_;
  _impl_.job_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::livekit::Job* PROTOBUF_NULLABLE AvailabilityRequest::unsafe_arena_release_job() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.AvailabilityRequest.job)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::Job* temp = _impl_.job_;
  _impl_.job_ = nullptr;
  return temp;
}
inline ::livekit::Job* PROTOBUF_NONNULL AvailabilityRequest::_internal_mutable_job() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.job_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::livekit::Job>(GetArena());
    _impl_.job_ = reinterpret_cast<::livekit::Job*>(p);
  }
  return _impl_.job_;
}
inline ::livekit::Job* PROTOBUF_NONNULL AvailabilityRequest::mutable_job()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::livekit::Job* _msg = _internal_mutable_job();
  // @@protoc_insertion_point(field_mutable:livekit.AvailabilityRequest.job)
  return _msg;
}
inline void AvailabilityRequest::set_allocated_job(::livekit::Job* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.job_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.job_ = reinterpret_cast<::livekit::Job*>(value);
  // @@protoc_insertion_point(field_set_allocated:livekit.AvailabilityRequest.job)
}

// bool resuming = 2;
inline void AvailabilityRequest::clear_resuming() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resuming_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool AvailabilityRequest::resuming() const {
  // @@protoc_insertion_point(field_get:livekit.AvailabilityRequest.resuming)
  return _internal_resuming();
}
inline void AvailabilityRequest::set_resuming(bool value) {
  _internal_set_resuming(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:livekit.AvailabilityRequest.resuming)
}
inline bool AvailabilityRequest::_internal_resuming() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.resuming_;
}
inline void AvailabilityRequest::_internal_set_resuming(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resuming_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// AvailabilityResponse

// string job_id = 1;
inline void AvailabilityResponse::clear_job_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.job_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AvailabilityResponse::job_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.AvailabilityResponse.job_id)
  return _internal_job_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AvailabilityResponse::set_job_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.job_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.AvailabilityResponse.job_id)
}
inline std::string* PROTOBUF_NONNULL AvailabilityResponse::mutable_job_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:livekit.AvailabilityResponse.job_id)
  return _s;
}
inline const std::string& AvailabilityResponse::_internal_job_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.job_id_.Get();
}
inline void AvailabilityResponse::_internal_set_job_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.job_id_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL AvailabilityResponse::_internal_mutable_job_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.job_id_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE AvailabilityResponse::release_job_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.AvailabilityResponse.job_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.job_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.job_id_.Set("", GetArena());
  }
  return released;
}
inline void AvailabilityResponse::set_allocated_job_id(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.job_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.job_id_.IsDefault()) {
    _impl_.job_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.AvailabilityResponse.job_id)
}

// bool available = 2;
inline void AvailabilityResponse::clear_available() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.available_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool AvailabilityResponse::available() const {
  // @@protoc_insertion_point(field_get:livekit.AvailabilityResponse.available)
  return _internal_available();
}
inline void AvailabilityResponse::set_available(bool value) {
  _internal_set_available(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:livekit.AvailabilityResponse.available)
}
inline bool AvailabilityResponse::_internal_available() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.available_;
}
inline void AvailabilityResponse::_internal_set_available(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.available_ = value;
}

// bool supports_resume = 3;
inline void AvailabilityResponse::clear_supports_resume() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.supports_resume_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool AvailabilityResponse::supports_resume() const {
  // @@protoc_insertion_point(field_get:livekit.AvailabilityResponse.supports_resume)
  return _internal_supports_resume();
}
inline void AvailabilityResponse::set_supports_resume(bool value) {
  _internal_set_supports_resume(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:livekit.AvailabilityResponse.supports_resume)
}
inline bool AvailabilityResponse::_internal_supports_resume() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.supports_resume_;
}
inline void AvailabilityResponse::_internal_set_supports_resume(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.supports_resume_ = value;
}

// string participant_name = 4;
inline void AvailabilityResponse::clear_participant_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.participant_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AvailabilityResponse::participant_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.AvailabilityResponse.participant_name)
  return _internal_participant_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AvailabilityResponse::set_participant_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.participant_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.AvailabilityResponse.participant_name)
}
inline std::string* PROTOBUF_NONNULL AvailabilityResponse::mutable_participant_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_participant_name();
  // @@protoc_insertion_point(field_mutable:livekit.AvailabilityResponse.participant_name)
  return _s;
}
inline const std::string& AvailabilityResponse::_internal_participant_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.participant_name_.Get();
}
inline void AvailabilityResponse::_internal_set_participant_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.participant_name_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL AvailabilityResponse::_internal_mutable_participant_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.participant_name_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE AvailabilityResponse::release_participant_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.AvailabilityResponse.participant_name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.participant_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.participant_name_.Set("", GetArena());
  }
  return released;
}
inline void AvailabilityResponse::set_allocated_participant_name(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.participant_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.participant_name_.IsDefault()) {
    _impl_.participant_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.AvailabilityResponse.participant_name)
}

// string participant_identity = 5;
inline void AvailabilityResponse::clear_participant_identity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.participant_identity_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AvailabilityResponse::participant_identity() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.AvailabilityResponse.participant_identity)
  return _internal_participant_identity();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AvailabilityResponse::set_participant_identity(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.participant_identity_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.AvailabilityResponse.participant_identity)
}
inline std::string* PROTOBUF_NONNULL AvailabilityResponse::mutable_participant_identity()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_participant_identity();
  // @@protoc_insertion_point(field_mutable:livekit.AvailabilityResponse.participant_identity)
  return _s;
}
inline const std::string& AvailabilityResponse::_internal_participant_identity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.participant_identity_.Get();
}
inline void AvailabilityResponse::_internal_set_participant_identity(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.participant_identity_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL AvailabilityResponse::_internal_mutable_participant_identity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.participant_identity_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE AvailabilityResponse::release_participant_identity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.AvailabilityResponse.participant_identity)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.participant_identity_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.participant_identity_.Set("", GetArena());
  }
  return released;
}
inline void AvailabilityResponse::set_allocated_participant_identity(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.participant_identity_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.AvailabilityResponse.participant_identity)
}

// string participant_metadata = 6;
inline void AvailabilityResponse::clear_participant_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.participant_metadata_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& AvailabilityResponse::participant_metadata() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.AvailabilityResponse.participant_metadata)
  return _internal_participant_metadata();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AvailabilityResponse::set_participant_metadata(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.participant_metadata_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.AvailabilityResponse.participant_metadata)
}
inline std::string* PROTOBUF_NONNULL AvailabilityResponse::mutable_participant_metadata()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_participant_metadata();
  // @@protoc_insertion_point(field_mutable:livekit.AvailabilityResponse.participant_metadata)
  return _s;
}
inline const std::string& AvailabilityResponse::_internal_participant_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.participant_metadata_.Get();
}
inline void AvailabilityResponse::_internal_set_participant_metadata(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.participant_metadata_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL AvailabilityResponse::_internal_mutable_participant_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.participant_metadata_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE AvailabilityResponse::release_participant_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.AvailabilityResponse.participant_metadata)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.participant_metadata_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.participant_metadata_.Set("", GetArena());
  }
  return released;
}
inline void AvailabilityResponse::set_allocated_participant_metadata(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.participant_metadata_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.participant_metadata_.IsDefault()) {
    _impl_.participant_metadata_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.AvailabilityResponse.participant_metadata)
}

// map<string, string> participant_attributes = 7;
inline int AvailabilityResponse::_internal_participant_attributes_size() const {
  return _internal_participant_attributes().size();
}
inline int AvailabilityResponse::participant_attributes_size() const {
  return _internal_participant_attributes_size();
}
inline void AvailabilityResponse::clear_participant_attributes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.participant_attributes_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& AvailabilityResponse::_internal_participant_attributes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.participant_attributes_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& AvailabilityResponse::participant_attributes() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:livekit.AvailabilityResponse.participant_attributes)
  return _internal_participant_attributes();
}
inline ::google::protobuf::Map<std::string, std::string>* PROTOBUF_NONNULL AvailabilityResponse::_internal_mutable_participant_attributes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.participant_attributes_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* PROTOBUF_NONNULL AvailabilityResponse::mutable_participant_attributes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:livekit.AvailabilityResponse.participant_attributes)
  return _internal_mutable_participant_attributes();
}

// -------------------------------------------------------------------

// UpdateJobStatus

// string job_id = 1;
inline void UpdateJobStatus::clear_job_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.job_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UpdateJobStatus::job_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.UpdateJobStatus.job_id)
  return _internal_job_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UpdateJobStatus::set_job_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.job_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.UpdateJobStatus.job_id)
}
inline std::string* PROTOBUF_NONNULL UpdateJobStatus::mutable_job_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateJobStatus.job_id)
  return _s;
}
inline const std::string& UpdateJobStatus::_internal_job_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.job_id_.Get();
}
inline void UpdateJobStatus::_internal_set_job_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.job_id_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL UpdateJobStatus::_internal_mutable_job_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.job_id_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE UpdateJobStatus::release_job_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.UpdateJobStatus.job_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.job_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.job_id_.Set("", GetArena());
  }
  return released;
}
inline void UpdateJobStatus::set_allocated_job_id(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.job_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.job_id_.IsDefault()) {
    _impl_.job_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateJobStatus.job_id)
}

// .livekit.JobStatus status = 2;
inline void UpdateJobStatus::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::livekit::JobStatus UpdateJobStatus::status() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateJobStatus.status)
  return _internal_status();
}
inline void UpdateJobStatus::set_status(::livekit::JobStatus value) {
  _internal_set_status(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:livekit.UpdateJobStatus.status)
}
inline ::livekit::JobStatus UpdateJobStatus::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::livekit::JobStatus>(_impl_.status_);
}
inline void UpdateJobStatus::_internal_set_status(::livekit::JobStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// string error = 3;
inline void UpdateJobStatus::clear_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UpdateJobStatus::error() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.UpdateJobStatus.error)
  return _internal_error();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UpdateJobStatus::set_error(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.error_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.UpdateJobStatus.error)
}
inline std::string* PROTOBUF_NONNULL UpdateJobStatus::mutable_error()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateJobStatus.error)
  return _s;
}
inline const std::string& UpdateJobStatus::_internal_error() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_.Get();
}
inline void UpdateJobStatus::_internal_set_error(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.error_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL UpdateJobStatus::_internal_mutable_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.error_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE UpdateJobStatus::release_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.UpdateJobStatus.error)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.error_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.error_.Set("", GetArena());
  }
  return released;
}
inline void UpdateJobStatus::set_allocated_error(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.error_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateJobStatus.error)
}

// -------------------------------------------------------------------

// UpdateWorkerStatus

// optional .livekit.WorkerStatus status = 1;
inline bool UpdateWorkerStatus::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UpdateWorkerStatus::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::livekit::WorkerStatus UpdateWorkerStatus::status() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateWorkerStatus.status)
  return _internal_status();
}
inline void UpdateWorkerStatus::set_status(::livekit::WorkerStatus value) {
  _internal_set_status(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:livekit.UpdateWorkerStatus.status)
}
inline ::livekit::WorkerStatus UpdateWorkerStatus::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::livekit::WorkerStatus>(_impl_.status_);
}
inline void UpdateWorkerStatus::_internal_set_status(::livekit::WorkerStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// float load = 3;
inline void UpdateWorkerStatus::clear_load() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.load_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float UpdateWorkerStatus::load() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateWorkerStatus.load)
  return _internal_load();
}
inline void UpdateWorkerStatus::set_load(float value) {
  _internal_set_load(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:livekit.UpdateWorkerStatus.load)
}
inline float UpdateWorkerStatus::_internal_load() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.load_;
}
inline void UpdateWorkerStatus::_internal_set_load(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.load_ = value;
}

// uint32 job_count = 4;
inline void UpdateWorkerStatus::clear_job_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.job_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t UpdateWorkerStatus::job_count() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateWorkerStatus.job_count)
  return _internal_job_count();
}
inline void UpdateWorkerStatus::set_job_count(::uint32_t value) {
  _internal_set_job_count(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:livekit.UpdateWorkerStatus.job_count)
}
inline ::uint32_t UpdateWorkerStatus::_internal_job_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.job_count_;
}
inline void UpdateWorkerStatus::_internal_set_job_count(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.job_count_ = value;
}

// -------------------------------------------------------------------

// JobAssignment

// .livekit.Job job = 1;
inline bool JobAssignment::has_job() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.job_ != nullptr);
  return value;
}
inline void JobAssignment::clear_job() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.job_ != nullptr) _impl_.job_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::livekit::Job& JobAssignment::_internal_job() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::livekit::Job* p = _impl_.job_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::Job&>(::livekit::_Job_default_instance_);
}
inline const ::livekit::Job& JobAssignment::job() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.JobAssignment.job)
  return _internal_job();
}
inline void JobAssignment::unsafe_arena_set_allocated_job(
    ::livekit::Job* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.job_);
  }
  _impl_.job_ = reinterpret_cast<::livekit::Job*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.JobAssignment.job)
}
inline ::livekit::Job* PROTOBUF_NULLABLE JobAssignment::release_job() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::livekit::Job* released = _impl_.job_;
  _impl_.job_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::livekit::Job* PROTOBUF_NULLABLE JobAssignment::unsafe_arena_release_job() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.JobAssignment.job)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::livekit::Job* temp = _impl_.job_;
  _impl_.job_ = nullptr;
  return temp;
}
inline ::livekit::Job* PROTOBUF_NONNULL JobAssignment::_internal_mutable_job() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.job_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::livekit::Job>(GetArena());
    _impl_.job_ = reinterpret_cast<::livekit::Job*>(p);
  }
  return _impl_.job_;
}
inline ::livekit::Job* PROTOBUF_NONNULL JobAssignment::mutable_job()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::livekit::Job* _msg = _internal_mutable_job();
  // @@protoc_insertion_point(field_mutable:livekit.JobAssignment.job)
  return _msg;
}
inline void JobAssignment::set_allocated_job(::livekit::Job* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.job_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.job_ = reinterpret_cast<::livekit::Job*>(value);
  // @@protoc_insertion_point(field_set_allocated:livekit.JobAssignment.job)
}

// optional string url = 2;
inline bool JobAssignment::has_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void JobAssignment::clear_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& JobAssignment::url() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.JobAssignment.url)
  return _internal_url();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void JobAssignment::set_url(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.url_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.JobAssignment.url)
}
inline std::string* PROTOBUF_NONNULL JobAssignment::mutable_url()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:livekit.JobAssignment.url)
  return _s;
}
inline const std::string& JobAssignment::_internal_url() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.url_.Get();
}
inline void JobAssignment::_internal_set_url(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.url_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL JobAssignment::_internal_mutable_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.url_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE JobAssignment::release_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.JobAssignment.url)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.url_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.url_.Set("", GetArena());
  }
  return released;
}
inline void JobAssignment::set_allocated_url(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.url_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.JobAssignment.url)
}

// string token = 3;
inline void JobAssignment::clear_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& JobAssignment::token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.JobAssignment.token)
  return _internal_token();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void JobAssignment::set_token(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.JobAssignment.token)
}
inline std::string* PROTOBUF_NONNULL JobAssignment::mutable_token()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:livekit.JobAssignment.token)
  return _s;
}
inline const std::string& JobAssignment::_internal_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.token_.Get();
}
inline void JobAssignment::_internal_set_token(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.token_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL JobAssignment::_internal_mutable_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.token_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE JobAssignment::release_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.JobAssignment.token)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.token_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.token_.Set("", GetArena());
  }
  return released;
}
inline void JobAssignment::set_allocated_token(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.token_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.JobAssignment.token)
}

// -------------------------------------------------------------------

// JobTermination

// string job_id = 1;
inline void JobTermination::clear_job_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.job_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& JobTermination::job_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.JobTermination.job_id)
  return _internal_job_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void JobTermination::set_job_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.job_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.JobTermination.job_id)
}
inline std::string* PROTOBUF_NONNULL JobTermination::mutable_job_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:livekit.JobTermination.job_id)
  return _s;
}
inline const std::string& JobTermination::_internal_job_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.job_id_.Get();
}
inline void JobTermination::_internal_set_job_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.job_id_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL JobTermination::_internal_mutable_job_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.job_id_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE JobTermination::release_job_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.JobTermination.job_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.job_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.job_id_.Set("", GetArena());
  }
  return released;
}
inline void JobTermination::set_allocated_job_id(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.job_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.job_id_.IsDefault()) {
    _impl_.job_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.JobTermination.job_id)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace livekit


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::livekit::JobType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::livekit::JobType>() {
  return ::livekit::JobType_descriptor();
}
template <>
struct is_proto_enum<::livekit::WorkerStatus> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::livekit::WorkerStatus>() {
  return ::livekit::WorkerStatus_descriptor();
}
template <>
struct is_proto_enum<::livekit::JobStatus> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::livekit::JobStatus>() {
  return ::livekit::JobStatus_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // livekit_5fagent_2eproto_2epb_2eh
