// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: livekit_egress.proto
// Protobuf C++ Version: 6.30.1

#ifndef livekit_5fegress_2eproto_2epb_2eh
#define livekit_5fegress_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6030001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_type_handler.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "livekit_models.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_livekit_5fegress_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_livekit_5fegress_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_livekit_5fegress_2eproto;
}  // extern "C"
namespace livekit {
enum AudioMixing : int;
extern const uint32_t AudioMixing_internal_data_[];
enum EgressSourceType : int;
extern const uint32_t EgressSourceType_internal_data_[];
enum EgressStatus : int;
extern const uint32_t EgressStatus_internal_data_[];
enum EncodedFileType : int;
extern const uint32_t EncodedFileType_internal_data_[];
enum EncodingOptionsPreset : int;
extern const uint32_t EncodingOptionsPreset_internal_data_[];
enum ImageFileSuffix : int;
extern const uint32_t ImageFileSuffix_internal_data_[];
enum SegmentedFileProtocol : int;
extern const uint32_t SegmentedFileProtocol_internal_data_[];
enum SegmentedFileSuffix : int;
extern const uint32_t SegmentedFileSuffix_internal_data_[];
enum StreamInfo_Status : int;
extern const uint32_t StreamInfo_Status_internal_data_[];
enum StreamProtocol : int;
extern const uint32_t StreamProtocol_internal_data_[];
class AliOSSUpload;
struct AliOSSUploadDefaultTypeInternal;
extern AliOSSUploadDefaultTypeInternal _AliOSSUpload_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull AliOSSUpload_class_data_;
class AutoParticipantEgress;
struct AutoParticipantEgressDefaultTypeInternal;
extern AutoParticipantEgressDefaultTypeInternal _AutoParticipantEgress_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull AutoParticipantEgress_class_data_;
class AutoTrackEgress;
struct AutoTrackEgressDefaultTypeInternal;
extern AutoTrackEgressDefaultTypeInternal _AutoTrackEgress_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull AutoTrackEgress_class_data_;
class AzureBlobUpload;
struct AzureBlobUploadDefaultTypeInternal;
extern AzureBlobUploadDefaultTypeInternal _AzureBlobUpload_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull AzureBlobUpload_class_data_;
class DirectFileOutput;
struct DirectFileOutputDefaultTypeInternal;
extern DirectFileOutputDefaultTypeInternal _DirectFileOutput_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DirectFileOutput_class_data_;
class EgressInfo;
struct EgressInfoDefaultTypeInternal;
extern EgressInfoDefaultTypeInternal _EgressInfo_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EgressInfo_class_data_;
class EncodedFileOutput;
struct EncodedFileOutputDefaultTypeInternal;
extern EncodedFileOutputDefaultTypeInternal _EncodedFileOutput_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EncodedFileOutput_class_data_;
class EncodingOptions;
struct EncodingOptionsDefaultTypeInternal;
extern EncodingOptionsDefaultTypeInternal _EncodingOptions_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EncodingOptions_class_data_;
class FileInfo;
struct FileInfoDefaultTypeInternal;
extern FileInfoDefaultTypeInternal _FileInfo_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull FileInfo_class_data_;
class GCPUpload;
struct GCPUploadDefaultTypeInternal;
extern GCPUploadDefaultTypeInternal _GCPUpload_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GCPUpload_class_data_;
class ImageOutput;
struct ImageOutputDefaultTypeInternal;
extern ImageOutputDefaultTypeInternal _ImageOutput_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ImageOutput_class_data_;
class ImagesInfo;
struct ImagesInfoDefaultTypeInternal;
extern ImagesInfoDefaultTypeInternal _ImagesInfo_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ImagesInfo_class_data_;
class ListEgressRequest;
struct ListEgressRequestDefaultTypeInternal;
extern ListEgressRequestDefaultTypeInternal _ListEgressRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ListEgressRequest_class_data_;
class ListEgressResponse;
struct ListEgressResponseDefaultTypeInternal;
extern ListEgressResponseDefaultTypeInternal _ListEgressResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ListEgressResponse_class_data_;
class ParticipantEgressRequest;
struct ParticipantEgressRequestDefaultTypeInternal;
extern ParticipantEgressRequestDefaultTypeInternal _ParticipantEgressRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ParticipantEgressRequest_class_data_;
class ProxyConfig;
struct ProxyConfigDefaultTypeInternal;
extern ProxyConfigDefaultTypeInternal _ProxyConfig_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ProxyConfig_class_data_;
class RoomCompositeEgressRequest;
struct RoomCompositeEgressRequestDefaultTypeInternal;
extern RoomCompositeEgressRequestDefaultTypeInternal _RoomCompositeEgressRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RoomCompositeEgressRequest_class_data_;
class S3Upload;
struct S3UploadDefaultTypeInternal;
extern S3UploadDefaultTypeInternal _S3Upload_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull S3Upload_class_data_;
class S3Upload_MetadataEntry_DoNotUse;
struct S3Upload_MetadataEntry_DoNotUseDefaultTypeInternal;
extern S3Upload_MetadataEntry_DoNotUseDefaultTypeInternal _S3Upload_MetadataEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull S3Upload_MetadataEntry_DoNotUse_class_data_;
class SegmentedFileOutput;
struct SegmentedFileOutputDefaultTypeInternal;
extern SegmentedFileOutputDefaultTypeInternal _SegmentedFileOutput_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SegmentedFileOutput_class_data_;
class SegmentsInfo;
struct SegmentsInfoDefaultTypeInternal;
extern SegmentsInfoDefaultTypeInternal _SegmentsInfo_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SegmentsInfo_class_data_;
class StopEgressRequest;
struct StopEgressRequestDefaultTypeInternal;
extern StopEgressRequestDefaultTypeInternal _StopEgressRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull StopEgressRequest_class_data_;
class StreamInfo;
struct StreamInfoDefaultTypeInternal;
extern StreamInfoDefaultTypeInternal _StreamInfo_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull StreamInfo_class_data_;
class StreamInfoList;
struct StreamInfoListDefaultTypeInternal;
extern StreamInfoListDefaultTypeInternal _StreamInfoList_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull StreamInfoList_class_data_;
class StreamOutput;
struct StreamOutputDefaultTypeInternal;
extern StreamOutputDefaultTypeInternal _StreamOutput_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull StreamOutput_class_data_;
class TrackCompositeEgressRequest;
struct TrackCompositeEgressRequestDefaultTypeInternal;
extern TrackCompositeEgressRequestDefaultTypeInternal _TrackCompositeEgressRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TrackCompositeEgressRequest_class_data_;
class TrackEgressRequest;
struct TrackEgressRequestDefaultTypeInternal;
extern TrackEgressRequestDefaultTypeInternal _TrackEgressRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TrackEgressRequest_class_data_;
class UpdateLayoutRequest;
struct UpdateLayoutRequestDefaultTypeInternal;
extern UpdateLayoutRequestDefaultTypeInternal _UpdateLayoutRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UpdateLayoutRequest_class_data_;
class UpdateStreamRequest;
struct UpdateStreamRequestDefaultTypeInternal;
extern UpdateStreamRequestDefaultTypeInternal _UpdateStreamRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UpdateStreamRequest_class_data_;
class WebEgressRequest;
struct WebEgressRequestDefaultTypeInternal;
extern WebEgressRequestDefaultTypeInternal _WebEgressRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull WebEgressRequest_class_data_;
}  // namespace livekit
namespace google {
namespace protobuf {
template <>
internal::EnumTraitsT<::livekit::AudioMixing_internal_data_>
    internal::EnumTraitsImpl::value<::livekit::AudioMixing>;
template <>
internal::EnumTraitsT<::livekit::EgressSourceType_internal_data_>
    internal::EnumTraitsImpl::value<::livekit::EgressSourceType>;
template <>
internal::EnumTraitsT<::livekit::EgressStatus_internal_data_>
    internal::EnumTraitsImpl::value<::livekit::EgressStatus>;
template <>
internal::EnumTraitsT<::livekit::EncodedFileType_internal_data_>
    internal::EnumTraitsImpl::value<::livekit::EncodedFileType>;
template <>
internal::EnumTraitsT<::livekit::EncodingOptionsPreset_internal_data_>
    internal::EnumTraitsImpl::value<::livekit::EncodingOptionsPreset>;
template <>
internal::EnumTraitsT<::livekit::ImageFileSuffix_internal_data_>
    internal::EnumTraitsImpl::value<::livekit::ImageFileSuffix>;
template <>
internal::EnumTraitsT<::livekit::SegmentedFileProtocol_internal_data_>
    internal::EnumTraitsImpl::value<::livekit::SegmentedFileProtocol>;
template <>
internal::EnumTraitsT<::livekit::SegmentedFileSuffix_internal_data_>
    internal::EnumTraitsImpl::value<::livekit::SegmentedFileSuffix>;
template <>
internal::EnumTraitsT<::livekit::StreamInfo_Status_internal_data_>
    internal::EnumTraitsImpl::value<::livekit::StreamInfo_Status>;
template <>
internal::EnumTraitsT<::livekit::StreamProtocol_internal_data_>
    internal::EnumTraitsImpl::value<::livekit::StreamProtocol>;
}  // namespace protobuf
}  // namespace google

namespace livekit {
enum StreamInfo_Status : int {
  StreamInfo_Status_ACTIVE = 0,
  StreamInfo_Status_FINISHED = 1,
  StreamInfo_Status_FAILED = 2,
  StreamInfo_Status_StreamInfo_Status_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  StreamInfo_Status_StreamInfo_Status_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t StreamInfo_Status_internal_data_[];
inline constexpr StreamInfo_Status StreamInfo_Status_Status_MIN =
    static_cast<StreamInfo_Status>(0);
inline constexpr StreamInfo_Status StreamInfo_Status_Status_MAX =
    static_cast<StreamInfo_Status>(2);
inline bool StreamInfo_Status_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int StreamInfo_Status_Status_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL StreamInfo_Status_descriptor();
template <typename T>
const std::string& StreamInfo_Status_Name(T value) {
  static_assert(std::is_same<T, StreamInfo_Status>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Status_Name().");
  return StreamInfo_Status_Name(static_cast<StreamInfo_Status>(value));
}
template <>
inline const std::string& StreamInfo_Status_Name(StreamInfo_Status value) {
  return ::google::protobuf::internal::NameOfDenseEnum<StreamInfo_Status_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool StreamInfo_Status_Parse(
    absl::string_view name, StreamInfo_Status* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<StreamInfo_Status>(StreamInfo_Status_descriptor(), name,
                                           value);
}
enum EncodedFileType : int {
  DEFAULT_FILETYPE = 0,
  MP4 = 1,
  OGG = 2,
  EncodedFileType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  EncodedFileType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t EncodedFileType_internal_data_[];
inline constexpr EncodedFileType EncodedFileType_MIN =
    static_cast<EncodedFileType>(0);
inline constexpr EncodedFileType EncodedFileType_MAX =
    static_cast<EncodedFileType>(2);
inline bool EncodedFileType_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int EncodedFileType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL EncodedFileType_descriptor();
template <typename T>
const std::string& EncodedFileType_Name(T value) {
  static_assert(std::is_same<T, EncodedFileType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EncodedFileType_Name().");
  return EncodedFileType_Name(static_cast<EncodedFileType>(value));
}
template <>
inline const std::string& EncodedFileType_Name(EncodedFileType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EncodedFileType_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool EncodedFileType_Parse(
    absl::string_view name, EncodedFileType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<EncodedFileType>(EncodedFileType_descriptor(), name,
                                           value);
}
enum SegmentedFileProtocol : int {
  DEFAULT_SEGMENTED_FILE_PROTOCOL = 0,
  HLS_PROTOCOL = 1,
  SegmentedFileProtocol_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SegmentedFileProtocol_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t SegmentedFileProtocol_internal_data_[];
inline constexpr SegmentedFileProtocol SegmentedFileProtocol_MIN =
    static_cast<SegmentedFileProtocol>(0);
inline constexpr SegmentedFileProtocol SegmentedFileProtocol_MAX =
    static_cast<SegmentedFileProtocol>(1);
inline bool SegmentedFileProtocol_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int SegmentedFileProtocol_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL SegmentedFileProtocol_descriptor();
template <typename T>
const std::string& SegmentedFileProtocol_Name(T value) {
  static_assert(std::is_same<T, SegmentedFileProtocol>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SegmentedFileProtocol_Name().");
  return SegmentedFileProtocol_Name(static_cast<SegmentedFileProtocol>(value));
}
template <>
inline const std::string& SegmentedFileProtocol_Name(SegmentedFileProtocol value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SegmentedFileProtocol_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool SegmentedFileProtocol_Parse(
    absl::string_view name, SegmentedFileProtocol* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<SegmentedFileProtocol>(SegmentedFileProtocol_descriptor(), name,
                                           value);
}
enum SegmentedFileSuffix : int {
  INDEX = 0,
  TIMESTAMP = 1,
  SegmentedFileSuffix_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SegmentedFileSuffix_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t SegmentedFileSuffix_internal_data_[];
inline constexpr SegmentedFileSuffix SegmentedFileSuffix_MIN =
    static_cast<SegmentedFileSuffix>(0);
inline constexpr SegmentedFileSuffix SegmentedFileSuffix_MAX =
    static_cast<SegmentedFileSuffix>(1);
inline bool SegmentedFileSuffix_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int SegmentedFileSuffix_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL SegmentedFileSuffix_descriptor();
template <typename T>
const std::string& SegmentedFileSuffix_Name(T value) {
  static_assert(std::is_same<T, SegmentedFileSuffix>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SegmentedFileSuffix_Name().");
  return SegmentedFileSuffix_Name(static_cast<SegmentedFileSuffix>(value));
}
template <>
inline const std::string& SegmentedFileSuffix_Name(SegmentedFileSuffix value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SegmentedFileSuffix_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool SegmentedFileSuffix_Parse(
    absl::string_view name, SegmentedFileSuffix* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<SegmentedFileSuffix>(SegmentedFileSuffix_descriptor(), name,
                                           value);
}
enum ImageFileSuffix : int {
  IMAGE_SUFFIX_INDEX = 0,
  IMAGE_SUFFIX_TIMESTAMP = 1,
  ImageFileSuffix_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ImageFileSuffix_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ImageFileSuffix_internal_data_[];
inline constexpr ImageFileSuffix ImageFileSuffix_MIN =
    static_cast<ImageFileSuffix>(0);
inline constexpr ImageFileSuffix ImageFileSuffix_MAX =
    static_cast<ImageFileSuffix>(1);
inline bool ImageFileSuffix_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int ImageFileSuffix_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ImageFileSuffix_descriptor();
template <typename T>
const std::string& ImageFileSuffix_Name(T value) {
  static_assert(std::is_same<T, ImageFileSuffix>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ImageFileSuffix_Name().");
  return ImageFileSuffix_Name(static_cast<ImageFileSuffix>(value));
}
template <>
inline const std::string& ImageFileSuffix_Name(ImageFileSuffix value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ImageFileSuffix_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool ImageFileSuffix_Parse(
    absl::string_view name, ImageFileSuffix* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ImageFileSuffix>(ImageFileSuffix_descriptor(), name,
                                           value);
}
enum StreamProtocol : int {
  DEFAULT_PROTOCOL = 0,
  RTMP = 1,
  SRT = 2,
  StreamProtocol_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  StreamProtocol_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t StreamProtocol_internal_data_[];
inline constexpr StreamProtocol StreamProtocol_MIN =
    static_cast<StreamProtocol>(0);
inline constexpr StreamProtocol StreamProtocol_MAX =
    static_cast<StreamProtocol>(2);
inline bool StreamProtocol_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int StreamProtocol_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL StreamProtocol_descriptor();
template <typename T>
const std::string& StreamProtocol_Name(T value) {
  static_assert(std::is_same<T, StreamProtocol>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to StreamProtocol_Name().");
  return StreamProtocol_Name(static_cast<StreamProtocol>(value));
}
template <>
inline const std::string& StreamProtocol_Name(StreamProtocol value) {
  return ::google::protobuf::internal::NameOfDenseEnum<StreamProtocol_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool StreamProtocol_Parse(
    absl::string_view name, StreamProtocol* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<StreamProtocol>(StreamProtocol_descriptor(), name,
                                           value);
}
enum AudioMixing : int {
  DEFAULT_MIXING = 0,
  DUAL_CHANNEL_AGENT = 1,
  DUAL_CHANNEL_ALTERNATE = 2,
  AudioMixing_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AudioMixing_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t AudioMixing_internal_data_[];
inline constexpr AudioMixing AudioMixing_MIN =
    static_cast<AudioMixing>(0);
inline constexpr AudioMixing AudioMixing_MAX =
    static_cast<AudioMixing>(2);
inline bool AudioMixing_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int AudioMixing_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL AudioMixing_descriptor();
template <typename T>
const std::string& AudioMixing_Name(T value) {
  static_assert(std::is_same<T, AudioMixing>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AudioMixing_Name().");
  return AudioMixing_Name(static_cast<AudioMixing>(value));
}
template <>
inline const std::string& AudioMixing_Name(AudioMixing value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AudioMixing_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool AudioMixing_Parse(
    absl::string_view name, AudioMixing* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<AudioMixing>(AudioMixing_descriptor(), name,
                                           value);
}
enum EncodingOptionsPreset : int {
  H264_720P_30 = 0,
  H264_720P_60 = 1,
  H264_1080P_30 = 2,
  H264_1080P_60 = 3,
  PORTRAIT_H264_720P_30 = 4,
  PORTRAIT_H264_720P_60 = 5,
  PORTRAIT_H264_1080P_30 = 6,
  PORTRAIT_H264_1080P_60 = 7,
  EncodingOptionsPreset_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  EncodingOptionsPreset_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t EncodingOptionsPreset_internal_data_[];
inline constexpr EncodingOptionsPreset EncodingOptionsPreset_MIN =
    static_cast<EncodingOptionsPreset>(0);
inline constexpr EncodingOptionsPreset EncodingOptionsPreset_MAX =
    static_cast<EncodingOptionsPreset>(7);
inline bool EncodingOptionsPreset_IsValid(int value) {
  return 0 <= value && value <= 7;
}
inline constexpr int EncodingOptionsPreset_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL EncodingOptionsPreset_descriptor();
template <typename T>
const std::string& EncodingOptionsPreset_Name(T value) {
  static_assert(std::is_same<T, EncodingOptionsPreset>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EncodingOptionsPreset_Name().");
  return EncodingOptionsPreset_Name(static_cast<EncodingOptionsPreset>(value));
}
template <>
inline const std::string& EncodingOptionsPreset_Name(EncodingOptionsPreset value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EncodingOptionsPreset_descriptor, 0, 7>(
      static_cast<int>(value));
}
inline bool EncodingOptionsPreset_Parse(
    absl::string_view name, EncodingOptionsPreset* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<EncodingOptionsPreset>(EncodingOptionsPreset_descriptor(), name,
                                           value);
}
enum EgressStatus : int {
  EGRESS_STARTING = 0,
  EGRESS_ACTIVE = 1,
  EGRESS_ENDING = 2,
  EGRESS_COMPLETE = 3,
  EGRESS_FAILED = 4,
  EGRESS_ABORTED = 5,
  EGRESS_LIMIT_REACHED = 6,
  EgressStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  EgressStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t EgressStatus_internal_data_[];
inline constexpr EgressStatus EgressStatus_MIN =
    static_cast<EgressStatus>(0);
inline constexpr EgressStatus EgressStatus_MAX =
    static_cast<EgressStatus>(6);
inline bool EgressStatus_IsValid(int value) {
  return 0 <= value && value <= 6;
}
inline constexpr int EgressStatus_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL EgressStatus_descriptor();
template <typename T>
const std::string& EgressStatus_Name(T value) {
  static_assert(std::is_same<T, EgressStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EgressStatus_Name().");
  return EgressStatus_Name(static_cast<EgressStatus>(value));
}
template <>
inline const std::string& EgressStatus_Name(EgressStatus value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EgressStatus_descriptor, 0, 6>(
      static_cast<int>(value));
}
inline bool EgressStatus_Parse(
    absl::string_view name, EgressStatus* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<EgressStatus>(EgressStatus_descriptor(), name,
                                           value);
}
enum EgressSourceType : int {
  EGRESS_SOURCE_TYPE_WEB = 0,
  EGRESS_SOURCE_TYPE_SDK = 1,
  EgressSourceType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  EgressSourceType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t EgressSourceType_internal_data_[];
inline constexpr EgressSourceType EgressSourceType_MIN =
    static_cast<EgressSourceType>(0);
inline constexpr EgressSourceType EgressSourceType_MAX =
    static_cast<EgressSourceType>(1);
inline bool EgressSourceType_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int EgressSourceType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL EgressSourceType_descriptor();
template <typename T>
const std::string& EgressSourceType_Name(T value) {
  static_assert(std::is_same<T, EgressSourceType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EgressSourceType_Name().");
  return EgressSourceType_Name(static_cast<EgressSourceType>(value));
}
template <>
inline const std::string& EgressSourceType_Name(EgressSourceType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EgressSourceType_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool EgressSourceType_Parse(
    absl::string_view name, EgressSourceType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<EgressSourceType>(EgressSourceType_descriptor(), name,
                                           value);
}

// ===================================================================


// -------------------------------------------------------------------

class UpdateStreamRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.UpdateStreamRequest) */ {
 public:
  inline UpdateStreamRequest() : UpdateStreamRequest(nullptr) {}
  ~UpdateStreamRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateStreamRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateStreamRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateStreamRequest(::google::protobuf::internal::ConstantInitialized);

  inline UpdateStreamRequest(const UpdateStreamRequest& from) : UpdateStreamRequest(nullptr, from) {}
  inline UpdateStreamRequest(UpdateStreamRequest&& from) noexcept
      : UpdateStreamRequest(nullptr, std::move(from)) {}
  inline UpdateStreamRequest& operator=(const UpdateStreamRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateStreamRequest& operator=(UpdateStreamRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateStreamRequest& default_instance() {
    return *reinterpret_cast<const UpdateStreamRequest*>(
        &_UpdateStreamRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(UpdateStreamRequest& a, UpdateStreamRequest& b) { a.Swap(&b); }
  inline void Swap(UpdateStreamRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateStreamRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateStreamRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateStreamRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateStreamRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateStreamRequest& from) { UpdateStreamRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateStreamRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.UpdateStreamRequest"; }

 protected:
  explicit UpdateStreamRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UpdateStreamRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UpdateStreamRequest& from);
  UpdateStreamRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UpdateStreamRequest&& from) noexcept
      : UpdateStreamRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAddOutputUrlsFieldNumber = 2,
    kRemoveOutputUrlsFieldNumber = 3,
    kEgressIdFieldNumber = 1,
  };
  // repeated string add_output_urls = 2;
  int add_output_urls_size() const;
  private:
  int _internal_add_output_urls_size() const;

  public:
  void clear_add_output_urls() ;
  const std::string& add_output_urls(int index) const;
  std::string* PROTOBUF_NONNULL mutable_add_output_urls(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_add_output_urls(int index, Arg_&& value, Args_... args);
  std::string* PROTOBUF_NONNULL add_add_output_urls();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_add_output_urls(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& add_output_urls() const;
  ::google::protobuf::RepeatedPtrField<std::string>* PROTOBUF_NONNULL mutable_add_output_urls();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_add_output_urls() const;
  ::google::protobuf::RepeatedPtrField<std::string>* PROTOBUF_NONNULL _internal_mutable_add_output_urls();

  public:
  // repeated string remove_output_urls = 3;
  int remove_output_urls_size() const;
  private:
  int _internal_remove_output_urls_size() const;

  public:
  void clear_remove_output_urls() ;
  const std::string& remove_output_urls(int index) const;
  std::string* PROTOBUF_NONNULL mutable_remove_output_urls(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_remove_output_urls(int index, Arg_&& value, Args_... args);
  std::string* PROTOBUF_NONNULL add_remove_output_urls();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_remove_output_urls(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& remove_output_urls() const;
  ::google::protobuf::RepeatedPtrField<std::string>* PROTOBUF_NONNULL mutable_remove_output_urls();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_remove_output_urls() const;
  ::google::protobuf::RepeatedPtrField<std::string>* PROTOBUF_NONNULL _internal_mutable_remove_output_urls();

  public:
  // string egress_id = 1;
  void clear_egress_id() ;
  const std::string& egress_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_egress_id(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_egress_id();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_egress_id();
  void set_allocated_egress_id(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_egress_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_egress_id(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_egress_id();

  public:
  // @@protoc_insertion_point(class_scope:livekit.UpdateStreamRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 78,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UpdateStreamRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> add_output_urls_;
    ::google::protobuf::RepeatedPtrField<std::string> remove_output_urls_;
    ::google::protobuf::internal::ArenaStringPtr egress_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UpdateStreamRequest_class_data_;
// -------------------------------------------------------------------

class UpdateLayoutRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.UpdateLayoutRequest) */ {
 public:
  inline UpdateLayoutRequest() : UpdateLayoutRequest(nullptr) {}
  ~UpdateLayoutRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateLayoutRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateLayoutRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateLayoutRequest(::google::protobuf::internal::ConstantInitialized);

  inline UpdateLayoutRequest(const UpdateLayoutRequest& from) : UpdateLayoutRequest(nullptr, from) {}
  inline UpdateLayoutRequest(UpdateLayoutRequest&& from) noexcept
      : UpdateLayoutRequest(nullptr, std::move(from)) {}
  inline UpdateLayoutRequest& operator=(const UpdateLayoutRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateLayoutRequest& operator=(UpdateLayoutRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateLayoutRequest& default_instance() {
    return *reinterpret_cast<const UpdateLayoutRequest*>(
        &_UpdateLayoutRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(UpdateLayoutRequest& a, UpdateLayoutRequest& b) { a.Swap(&b); }
  inline void Swap(UpdateLayoutRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateLayoutRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateLayoutRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateLayoutRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateLayoutRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateLayoutRequest& from) { UpdateLayoutRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateLayoutRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.UpdateLayoutRequest"; }

 protected:
  explicit UpdateLayoutRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UpdateLayoutRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UpdateLayoutRequest& from);
  UpdateLayoutRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UpdateLayoutRequest&& from) noexcept
      : UpdateLayoutRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEgressIdFieldNumber = 1,
    kLayoutFieldNumber = 2,
  };
  // string egress_id = 1;
  void clear_egress_id() ;
  const std::string& egress_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_egress_id(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_egress_id();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_egress_id();
  void set_allocated_egress_id(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_egress_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_egress_id(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_egress_id();

  public:
  // string layout = 2;
  void clear_layout() ;
  const std::string& layout() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_layout(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_layout();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_layout();
  void set_allocated_layout(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_layout() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_layout(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_layout();

  public:
  // @@protoc_insertion_point(class_scope:livekit.UpdateLayoutRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 51,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UpdateLayoutRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr egress_id_;
    ::google::protobuf::internal::ArenaStringPtr layout_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UpdateLayoutRequest_class_data_;
// -------------------------------------------------------------------

class StreamOutput final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.StreamOutput) */ {
 public:
  inline StreamOutput() : StreamOutput(nullptr) {}
  ~StreamOutput() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(StreamOutput* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(StreamOutput));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StreamOutput(::google::protobuf::internal::ConstantInitialized);

  inline StreamOutput(const StreamOutput& from) : StreamOutput(nullptr, from) {}
  inline StreamOutput(StreamOutput&& from) noexcept
      : StreamOutput(nullptr, std::move(from)) {}
  inline StreamOutput& operator=(const StreamOutput& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamOutput& operator=(StreamOutput&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamOutput& default_instance() {
    return *reinterpret_cast<const StreamOutput*>(
        &_StreamOutput_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(StreamOutput& a, StreamOutput& b) { a.Swap(&b); }
  inline void Swap(StreamOutput* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamOutput* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamOutput* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<StreamOutput>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StreamOutput& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StreamOutput& from) { StreamOutput::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(StreamOutput* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.StreamOutput"; }

 protected:
  explicit StreamOutput(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  StreamOutput(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const StreamOutput& from);
  StreamOutput(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, StreamOutput&& from) noexcept
      : StreamOutput(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUrlsFieldNumber = 2,
    kProtocolFieldNumber = 1,
  };
  // repeated string urls = 2;
  int urls_size() const;
  private:
  int _internal_urls_size() const;

  public:
  void clear_urls() ;
  const std::string& urls(int index) const;
  std::string* PROTOBUF_NONNULL mutable_urls(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_urls(int index, Arg_&& value, Args_... args);
  std::string* PROTOBUF_NONNULL add_urls();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_urls(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& urls() const;
  ::google::protobuf::RepeatedPtrField<std::string>* PROTOBUF_NONNULL mutable_urls();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_urls() const;
  ::google::protobuf::RepeatedPtrField<std::string>* PROTOBUF_NONNULL _internal_mutable_urls();

  public:
  // .livekit.StreamProtocol protocol = 1;
  void clear_protocol() ;
  ::livekit::StreamProtocol protocol() const;
  void set_protocol(::livekit::StreamProtocol value);

  private:
  ::livekit::StreamProtocol _internal_protocol() const;
  void _internal_set_protocol(::livekit::StreamProtocol value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.StreamOutput)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 33,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const StreamOutput& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> urls_;
    int protocol_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull StreamOutput_class_data_;
// -------------------------------------------------------------------

class StreamInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.StreamInfo) */ {
 public:
  inline StreamInfo() : StreamInfo(nullptr) {}
  ~StreamInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(StreamInfo* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(StreamInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StreamInfo(::google::protobuf::internal::ConstantInitialized);

  inline StreamInfo(const StreamInfo& from) : StreamInfo(nullptr, from) {}
  inline StreamInfo(StreamInfo&& from) noexcept
      : StreamInfo(nullptr, std::move(from)) {}
  inline StreamInfo& operator=(const StreamInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamInfo& operator=(StreamInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamInfo& default_instance() {
    return *reinterpret_cast<const StreamInfo*>(
        &_StreamInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(StreamInfo& a, StreamInfo& b) { a.Swap(&b); }
  inline void Swap(StreamInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamInfo* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<StreamInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StreamInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StreamInfo& from) { StreamInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(StreamInfo* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.StreamInfo"; }

 protected:
  explicit StreamInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  StreamInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const StreamInfo& from);
  StreamInfo(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, StreamInfo&& from) noexcept
      : StreamInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Status = StreamInfo_Status;
  static constexpr Status ACTIVE = StreamInfo_Status_ACTIVE;
  static constexpr Status FINISHED = StreamInfo_Status_FINISHED;
  static constexpr Status FAILED = StreamInfo_Status_FAILED;
  static inline bool Status_IsValid(int value) {
    return StreamInfo_Status_IsValid(value);
  }
  static constexpr Status Status_MIN = StreamInfo_Status_Status_MIN;
  static constexpr Status Status_MAX = StreamInfo_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE = StreamInfo_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Status_descriptor() {
    return StreamInfo_Status_descriptor();
  }
  template <typename T>
  static inline const std::string& Status_Name(T value) {
    return StreamInfo_Status_Name(value);
  }
  static inline bool Status_Parse(
      absl::string_view name, Status* PROTOBUF_NONNULL value) {
    return StreamInfo_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kUrlFieldNumber = 1,
    kErrorFieldNumber = 6,
    kStartedAtFieldNumber = 2,
    kEndedAtFieldNumber = 3,
    kDurationFieldNumber = 4,
    kStatusFieldNumber = 5,
  };
  // string url = 1;
  void clear_url() ;
  const std::string& url() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_url(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_url();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_url();
  void set_allocated_url(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_url() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_url();

  public:
  // string error = 6;
  void clear_error() ;
  const std::string& error() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_error();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_error();
  void set_allocated_error(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_error() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_error();

  public:
  // int64 started_at = 2;
  void clear_started_at() ;
  ::int64_t started_at() const;
  void set_started_at(::int64_t value);

  private:
  ::int64_t _internal_started_at() const;
  void _internal_set_started_at(::int64_t value);

  public:
  // int64 ended_at = 3;
  void clear_ended_at() ;
  ::int64_t ended_at() const;
  void set_ended_at(::int64_t value);

  private:
  ::int64_t _internal_ended_at() const;
  void _internal_set_ended_at(::int64_t value);

  public:
  // int64 duration = 4;
  void clear_duration() ;
  ::int64_t duration() const;
  void set_duration(::int64_t value);

  private:
  ::int64_t _internal_duration() const;
  void _internal_set_duration(::int64_t value);

  public:
  // .livekit.StreamInfo.Status status = 5;
  void clear_status() ;
  ::livekit::StreamInfo_Status status() const;
  void set_status(::livekit::StreamInfo_Status value);

  private:
  ::livekit::StreamInfo_Status _internal_status() const;
  void _internal_set_status(::livekit::StreamInfo_Status value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.StreamInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   0, 35,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const StreamInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr url_;
    ::google::protobuf::internal::ArenaStringPtr error_;
    ::int64_t started_at_;
    ::int64_t ended_at_;
    ::int64_t duration_;
    int status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull StreamInfo_class_data_;
// -------------------------------------------------------------------

class StopEgressRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.StopEgressRequest) */ {
 public:
  inline StopEgressRequest() : StopEgressRequest(nullptr) {}
  ~StopEgressRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(StopEgressRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(StopEgressRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StopEgressRequest(::google::protobuf::internal::ConstantInitialized);

  inline StopEgressRequest(const StopEgressRequest& from) : StopEgressRequest(nullptr, from) {}
  inline StopEgressRequest(StopEgressRequest&& from) noexcept
      : StopEgressRequest(nullptr, std::move(from)) {}
  inline StopEgressRequest& operator=(const StopEgressRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopEgressRequest& operator=(StopEgressRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopEgressRequest& default_instance() {
    return *reinterpret_cast<const StopEgressRequest*>(
        &_StopEgressRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(StopEgressRequest& a, StopEgressRequest& b) { a.Swap(&b); }
  inline void Swap(StopEgressRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopEgressRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopEgressRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<StopEgressRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StopEgressRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StopEgressRequest& from) { StopEgressRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(StopEgressRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.StopEgressRequest"; }

 protected:
  explicit StopEgressRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  StopEgressRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const StopEgressRequest& from);
  StopEgressRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, StopEgressRequest&& from) noexcept
      : StopEgressRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEgressIdFieldNumber = 1,
  };
  // string egress_id = 1;
  void clear_egress_id() ;
  const std::string& egress_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_egress_id(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_egress_id();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_egress_id();
  void set_allocated_egress_id(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_egress_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_egress_id(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_egress_id();

  public:
  // @@protoc_insertion_point(class_scope:livekit.StopEgressRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 43,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const StopEgressRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr egress_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull StopEgressRequest_class_data_;
// -------------------------------------------------------------------

class SegmentsInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.SegmentsInfo) */ {
 public:
  inline SegmentsInfo() : SegmentsInfo(nullptr) {}
  ~SegmentsInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SegmentsInfo* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SegmentsInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SegmentsInfo(::google::protobuf::internal::ConstantInitialized);

  inline SegmentsInfo(const SegmentsInfo& from) : SegmentsInfo(nullptr, from) {}
  inline SegmentsInfo(SegmentsInfo&& from) noexcept
      : SegmentsInfo(nullptr, std::move(from)) {}
  inline SegmentsInfo& operator=(const SegmentsInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SegmentsInfo& operator=(SegmentsInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SegmentsInfo& default_instance() {
    return *reinterpret_cast<const SegmentsInfo*>(
        &_SegmentsInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(SegmentsInfo& a, SegmentsInfo& b) { a.Swap(&b); }
  inline void Swap(SegmentsInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SegmentsInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SegmentsInfo* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SegmentsInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SegmentsInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SegmentsInfo& from) { SegmentsInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SegmentsInfo* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.SegmentsInfo"; }

 protected:
  explicit SegmentsInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SegmentsInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SegmentsInfo& from);
  SegmentsInfo(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SegmentsInfo&& from) noexcept
      : SegmentsInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPlaylistNameFieldNumber = 1,
    kPlaylistLocationFieldNumber = 4,
    kLivePlaylistNameFieldNumber = 8,
    kLivePlaylistLocationFieldNumber = 9,
    kDurationFieldNumber = 2,
    kSizeFieldNumber = 3,
    kSegmentCountFieldNumber = 5,
    kStartedAtFieldNumber = 6,
    kEndedAtFieldNumber = 7,
  };
  // string playlist_name = 1;
  void clear_playlist_name() ;
  const std::string& playlist_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_playlist_name(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_playlist_name();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_playlist_name();
  void set_allocated_playlist_name(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_playlist_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_playlist_name(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_playlist_name();

  public:
  // string playlist_location = 4;
  void clear_playlist_location() ;
  const std::string& playlist_location() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_playlist_location(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_playlist_location();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_playlist_location();
  void set_allocated_playlist_location(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_playlist_location() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_playlist_location(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_playlist_location();

  public:
  // string live_playlist_name = 8;
  void clear_live_playlist_name() ;
  const std::string& live_playlist_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_live_playlist_name(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_live_playlist_name();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_live_playlist_name();
  void set_allocated_live_playlist_name(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_live_playlist_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_live_playlist_name(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_live_playlist_name();

  public:
  // string live_playlist_location = 9;
  void clear_live_playlist_location() ;
  const std::string& live_playlist_location() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_live_playlist_location(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_live_playlist_location();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_live_playlist_location();
  void set_allocated_live_playlist_location(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_live_playlist_location() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_live_playlist_location(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_live_playlist_location();

  public:
  // int64 duration = 2;
  void clear_duration() ;
  ::int64_t duration() const;
  void set_duration(::int64_t value);

  private:
  ::int64_t _internal_duration() const;
  void _internal_set_duration(::int64_t value);

  public:
  // int64 size = 3;
  void clear_size() ;
  ::int64_t size() const;
  void set_size(::int64_t value);

  private:
  ::int64_t _internal_size() const;
  void _internal_set_size(::int64_t value);

  public:
  // int64 segment_count = 5;
  void clear_segment_count() ;
  ::int64_t segment_count() const;
  void set_segment_count(::int64_t value);

  private:
  ::int64_t _internal_segment_count() const;
  void _internal_set_segment_count(::int64_t value);

  public:
  // int64 started_at = 6;
  void clear_started_at() ;
  ::int64_t started_at() const;
  void set_started_at(::int64_t value);

  private:
  ::int64_t _internal_started_at() const;
  void _internal_set_started_at(::int64_t value);

  public:
  // int64 ended_at = 7;
  void clear_ended_at() ;
  ::int64_t ended_at() const;
  void set_ended_at(::int64_t value);

  private:
  ::int64_t _internal_ended_at() const;
  void _internal_set_ended_at(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.SegmentsInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 9,
                                   0, 107,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SegmentsInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr playlist_name_;
    ::google::protobuf::internal::ArenaStringPtr playlist_location_;
    ::google::protobuf::internal::ArenaStringPtr live_playlist_name_;
    ::google::protobuf::internal::ArenaStringPtr live_playlist_location_;
    ::int64_t duration_;
    ::int64_t size_;
    ::int64_t segment_count_;
    ::int64_t started_at_;
    ::int64_t ended_at_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SegmentsInfo_class_data_;
// -------------------------------------------------------------------

class S3Upload_MetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<std::string, std::string,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  S3Upload_MetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR S3Upload_MetadataEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit S3Upload_MetadataEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_S3Upload_MetadataEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_livekit_5fegress_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 47,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull S3Upload_MetadataEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class ProxyConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.ProxyConfig) */ {
 public:
  inline ProxyConfig() : ProxyConfig(nullptr) {}
  ~ProxyConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ProxyConfig* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ProxyConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ProxyConfig(::google::protobuf::internal::ConstantInitialized);

  inline ProxyConfig(const ProxyConfig& from) : ProxyConfig(nullptr, from) {}
  inline ProxyConfig(ProxyConfig&& from) noexcept
      : ProxyConfig(nullptr, std::move(from)) {}
  inline ProxyConfig& operator=(const ProxyConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProxyConfig& operator=(ProxyConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProxyConfig& default_instance() {
    return *reinterpret_cast<const ProxyConfig*>(
        &_ProxyConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(ProxyConfig& a, ProxyConfig& b) { a.Swap(&b); }
  inline void Swap(ProxyConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProxyConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProxyConfig* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ProxyConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ProxyConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ProxyConfig& from) { ProxyConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ProxyConfig* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.ProxyConfig"; }

 protected:
  explicit ProxyConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ProxyConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ProxyConfig& from);
  ProxyConfig(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ProxyConfig&& from) noexcept
      : ProxyConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUrlFieldNumber = 1,
    kUsernameFieldNumber = 2,
    kPasswordFieldNumber = 3,
  };
  // string url = 1;
  void clear_url() ;
  const std::string& url() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_url(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_url();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_url();
  void set_allocated_url(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_url() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_url();

  public:
  // string username = 2;
  void clear_username() ;
  const std::string& username() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_username(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_username();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_username();
  void set_allocated_username(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_username() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_username();

  public:
  // string password = 3;
  void clear_password() ;
  const std::string& password() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_password(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_password();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_password();
  void set_allocated_password(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_password() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_password();

  public:
  // @@protoc_insertion_point(class_scope:livekit.ProxyConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 47,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ProxyConfig& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr url_;
    ::google::protobuf::internal::ArenaStringPtr username_;
    ::google::protobuf::internal::ArenaStringPtr password_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ProxyConfig_class_data_;
// -------------------------------------------------------------------

class ListEgressRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.ListEgressRequest) */ {
 public:
  inline ListEgressRequest() : ListEgressRequest(nullptr) {}
  ~ListEgressRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ListEgressRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ListEgressRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListEgressRequest(::google::protobuf::internal::ConstantInitialized);

  inline ListEgressRequest(const ListEgressRequest& from) : ListEgressRequest(nullptr, from) {}
  inline ListEgressRequest(ListEgressRequest&& from) noexcept
      : ListEgressRequest(nullptr, std::move(from)) {}
  inline ListEgressRequest& operator=(const ListEgressRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListEgressRequest& operator=(ListEgressRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListEgressRequest& default_instance() {
    return *reinterpret_cast<const ListEgressRequest*>(
        &_ListEgressRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(ListEgressRequest& a, ListEgressRequest& b) { a.Swap(&b); }
  inline void Swap(ListEgressRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListEgressRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListEgressRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ListEgressRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListEgressRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListEgressRequest& from) { ListEgressRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ListEgressRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.ListEgressRequest"; }

 protected:
  explicit ListEgressRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ListEgressRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ListEgressRequest& from);
  ListEgressRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ListEgressRequest&& from) noexcept
      : ListEgressRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRoomNameFieldNumber = 1,
    kEgressIdFieldNumber = 2,
    kActiveFieldNumber = 3,
  };
  // string room_name = 1;
  void clear_room_name() ;
  const std::string& room_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_room_name(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_room_name();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_room_name();
  void set_allocated_room_name(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_room_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_room_name(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_room_name();

  public:
  // string egress_id = 2;
  void clear_egress_id() ;
  const std::string& egress_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_egress_id(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_egress_id();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_egress_id();
  void set_allocated_egress_id(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_egress_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_egress_id(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_egress_id();

  public:
  // bool active = 3;
  void clear_active() ;
  bool active() const;
  void set_active(bool value);

  private:
  bool _internal_active() const;
  void _internal_set_active(bool value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.ListEgressRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 52,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ListEgressRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr room_name_;
    ::google::protobuf::internal::ArenaStringPtr egress_id_;
    bool active_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ListEgressRequest_class_data_;
// -------------------------------------------------------------------

class ImagesInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.ImagesInfo) */ {
 public:
  inline ImagesInfo() : ImagesInfo(nullptr) {}
  ~ImagesInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ImagesInfo* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ImagesInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ImagesInfo(::google::protobuf::internal::ConstantInitialized);

  inline ImagesInfo(const ImagesInfo& from) : ImagesInfo(nullptr, from) {}
  inline ImagesInfo(ImagesInfo&& from) noexcept
      : ImagesInfo(nullptr, std::move(from)) {}
  inline ImagesInfo& operator=(const ImagesInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImagesInfo& operator=(ImagesInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImagesInfo& default_instance() {
    return *reinterpret_cast<const ImagesInfo*>(
        &_ImagesInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 27;
  friend void swap(ImagesInfo& a, ImagesInfo& b) { a.Swap(&b); }
  inline void Swap(ImagesInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImagesInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImagesInfo* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ImagesInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ImagesInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ImagesInfo& from) { ImagesInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ImagesInfo* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.ImagesInfo"; }

 protected:
  explicit ImagesInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ImagesInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ImagesInfo& from);
  ImagesInfo(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ImagesInfo&& from) noexcept
      : ImagesInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFilenamePrefixFieldNumber = 4,
    kImageCountFieldNumber = 1,
    kStartedAtFieldNumber = 2,
    kEndedAtFieldNumber = 3,
  };
  // string filename_prefix = 4;
  void clear_filename_prefix() ;
  const std::string& filename_prefix() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_filename_prefix(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_filename_prefix();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_filename_prefix();
  void set_allocated_filename_prefix(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_filename_prefix() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_filename_prefix(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_filename_prefix();

  public:
  // int64 image_count = 1;
  void clear_image_count() ;
  ::int64_t image_count() const;
  void set_image_count(::int64_t value);

  private:
  ::int64_t _internal_image_count() const;
  void _internal_set_image_count(::int64_t value);

  public:
  // int64 started_at = 2;
  void clear_started_at() ;
  ::int64_t started_at() const;
  void set_started_at(::int64_t value);

  private:
  ::int64_t _internal_started_at() const;
  void _internal_set_started_at(::int64_t value);

  public:
  // int64 ended_at = 3;
  void clear_ended_at() ;
  ::int64_t ended_at() const;
  void set_ended_at(::int64_t value);

  private:
  ::int64_t _internal_ended_at() const;
  void _internal_set_ended_at(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.ImagesInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 42,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ImagesInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr filename_prefix_;
    ::int64_t image_count_;
    ::int64_t started_at_;
    ::int64_t ended_at_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ImagesInfo_class_data_;
// -------------------------------------------------------------------

class FileInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.FileInfo) */ {
 public:
  inline FileInfo() : FileInfo(nullptr) {}
  ~FileInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FileInfo* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FileInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FileInfo(::google::protobuf::internal::ConstantInitialized);

  inline FileInfo(const FileInfo& from) : FileInfo(nullptr, from) {}
  inline FileInfo(FileInfo&& from) noexcept
      : FileInfo(nullptr, std::move(from)) {}
  inline FileInfo& operator=(const FileInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileInfo& operator=(FileInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileInfo& default_instance() {
    return *reinterpret_cast<const FileInfo*>(
        &_FileInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(FileInfo& a, FileInfo& b) { a.Swap(&b); }
  inline void Swap(FileInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileInfo* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FileInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FileInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FileInfo& from) { FileInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FileInfo* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.FileInfo"; }

 protected:
  explicit FileInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  FileInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const FileInfo& from);
  FileInfo(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, FileInfo&& from) noexcept
      : FileInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFilenameFieldNumber = 1,
    kLocationFieldNumber = 5,
    kStartedAtFieldNumber = 2,
    kEndedAtFieldNumber = 3,
    kSizeFieldNumber = 4,
    kDurationFieldNumber = 6,
  };
  // string filename = 1;
  void clear_filename() ;
  const std::string& filename() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_filename(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_filename();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_filename();
  void set_allocated_filename(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_filename() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_filename();

  public:
  // string location = 5;
  void clear_location() ;
  const std::string& location() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_location(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_location();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_location();
  void set_allocated_location(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_location() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_location(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_location();

  public:
  // int64 started_at = 2;
  void clear_started_at() ;
  ::int64_t started_at() const;
  void set_started_at(::int64_t value);

  private:
  ::int64_t _internal_started_at() const;
  void _internal_set_started_at(::int64_t value);

  public:
  // int64 ended_at = 3;
  void clear_ended_at() ;
  ::int64_t ended_at() const;
  void set_ended_at(::int64_t value);

  private:
  ::int64_t _internal_ended_at() const;
  void _internal_set_ended_at(::int64_t value);

  public:
  // int64 size = 4;
  void clear_size() ;
  ::int64_t size() const;
  void set_size(::int64_t value);

  private:
  ::int64_t _internal_size() const;
  void _internal_set_size(::int64_t value);

  public:
  // int64 duration = 6;
  void clear_duration() ;
  ::int64_t duration() const;
  void set_duration(::int64_t value);

  private:
  ::int64_t _internal_duration() const;
  void _internal_set_duration(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.FileInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   0, 41,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const FileInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr filename_;
    ::google::protobuf::internal::ArenaStringPtr location_;
    ::int64_t started_at_;
    ::int64_t ended_at_;
    ::int64_t size_;
    ::int64_t duration_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull FileInfo_class_data_;
// -------------------------------------------------------------------

class EncodingOptions final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.EncodingOptions) */ {
 public:
  inline EncodingOptions() : EncodingOptions(nullptr) {}
  ~EncodingOptions() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EncodingOptions* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EncodingOptions));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EncodingOptions(::google::protobuf::internal::ConstantInitialized);

  inline EncodingOptions(const EncodingOptions& from) : EncodingOptions(nullptr, from) {}
  inline EncodingOptions(EncodingOptions&& from) noexcept
      : EncodingOptions(nullptr, std::move(from)) {}
  inline EncodingOptions& operator=(const EncodingOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline EncodingOptions& operator=(EncodingOptions&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EncodingOptions& default_instance() {
    return *reinterpret_cast<const EncodingOptions*>(
        &_EncodingOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(EncodingOptions& a, EncodingOptions& b) { a.Swap(&b); }
  inline void Swap(EncodingOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EncodingOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EncodingOptions* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EncodingOptions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EncodingOptions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EncodingOptions& from) { EncodingOptions::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EncodingOptions* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.EncodingOptions"; }

 protected:
  explicit EncodingOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EncodingOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EncodingOptions& from);
  EncodingOptions(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EncodingOptions&& from) noexcept
      : EncodingOptions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
    kDepthFieldNumber = 3,
    kFramerateFieldNumber = 4,
    kAudioCodecFieldNumber = 5,
    kAudioBitrateFieldNumber = 6,
    kAudioFrequencyFieldNumber = 7,
    kVideoCodecFieldNumber = 8,
    kKeyFrameIntervalFieldNumber = 10,
    kVideoBitrateFieldNumber = 9,
    kAudioQualityFieldNumber = 11,
    kVideoQualityFieldNumber = 12,
  };
  // int32 width = 1;
  void clear_width() ;
  ::int32_t width() const;
  void set_width(::int32_t value);

  private:
  ::int32_t _internal_width() const;
  void _internal_set_width(::int32_t value);

  public:
  // int32 height = 2;
  void clear_height() ;
  ::int32_t height() const;
  void set_height(::int32_t value);

  private:
  ::int32_t _internal_height() const;
  void _internal_set_height(::int32_t value);

  public:
  // int32 depth = 3;
  void clear_depth() ;
  ::int32_t depth() const;
  void set_depth(::int32_t value);

  private:
  ::int32_t _internal_depth() const;
  void _internal_set_depth(::int32_t value);

  public:
  // int32 framerate = 4;
  void clear_framerate() ;
  ::int32_t framerate() const;
  void set_framerate(::int32_t value);

  private:
  ::int32_t _internal_framerate() const;
  void _internal_set_framerate(::int32_t value);

  public:
  // .livekit.AudioCodec audio_codec = 5;
  void clear_audio_codec() ;
  ::livekit::AudioCodec audio_codec() const;
  void set_audio_codec(::livekit::AudioCodec value);

  private:
  ::livekit::AudioCodec _internal_audio_codec() const;
  void _internal_set_audio_codec(::livekit::AudioCodec value);

  public:
  // int32 audio_bitrate = 6;
  void clear_audio_bitrate() ;
  ::int32_t audio_bitrate() const;
  void set_audio_bitrate(::int32_t value);

  private:
  ::int32_t _internal_audio_bitrate() const;
  void _internal_set_audio_bitrate(::int32_t value);

  public:
  // int32 audio_frequency = 7;
  void clear_audio_frequency() ;
  ::int32_t audio_frequency() const;
  void set_audio_frequency(::int32_t value);

  private:
  ::int32_t _internal_audio_frequency() const;
  void _internal_set_audio_frequency(::int32_t value);

  public:
  // .livekit.VideoCodec video_codec = 8;
  void clear_video_codec() ;
  ::livekit::VideoCodec video_codec() const;
  void set_video_codec(::livekit::VideoCodec value);

  private:
  ::livekit::VideoCodec _internal_video_codec() const;
  void _internal_set_video_codec(::livekit::VideoCodec value);

  public:
  // double key_frame_interval = 10;
  void clear_key_frame_interval() ;
  double key_frame_interval() const;
  void set_key_frame_interval(double value);

  private:
  double _internal_key_frame_interval() const;
  void _internal_set_key_frame_interval(double value);

  public:
  // int32 video_bitrate = 9;
  void clear_video_bitrate() ;
  ::int32_t video_bitrate() const;
  void set_video_bitrate(::int32_t value);

  private:
  ::int32_t _internal_video_bitrate() const;
  void _internal_set_video_bitrate(::int32_t value);

  public:
  // int32 audio_quality = 11;
  void clear_audio_quality() ;
  ::int32_t audio_quality() const;
  void set_audio_quality(::int32_t value);

  private:
  ::int32_t _internal_audio_quality() const;
  void _internal_set_audio_quality(::int32_t value);

  public:
  // int32 video_quality = 12;
  void clear_video_quality() ;
  ::int32_t video_quality() const;
  void set_video_quality(::int32_t value);

  private:
  ::int32_t _internal_video_quality() const;
  void _internal_set_video_quality(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.EncodingOptions)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 12,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EncodingOptions& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t width_;
    ::int32_t height_;
    ::int32_t depth_;
    ::int32_t framerate_;
    int audio_codec_;
    ::int32_t audio_bitrate_;
    ::int32_t audio_frequency_;
    int video_codec_;
    double key_frame_interval_;
    ::int32_t video_bitrate_;
    ::int32_t audio_quality_;
    ::int32_t video_quality_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EncodingOptions_class_data_;
// -------------------------------------------------------------------

class AzureBlobUpload final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.AzureBlobUpload) */ {
 public:
  inline AzureBlobUpload() : AzureBlobUpload(nullptr) {}
  ~AzureBlobUpload() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AzureBlobUpload* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AzureBlobUpload));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AzureBlobUpload(::google::protobuf::internal::ConstantInitialized);

  inline AzureBlobUpload(const AzureBlobUpload& from) : AzureBlobUpload(nullptr, from) {}
  inline AzureBlobUpload(AzureBlobUpload&& from) noexcept
      : AzureBlobUpload(nullptr, std::move(from)) {}
  inline AzureBlobUpload& operator=(const AzureBlobUpload& from) {
    CopyFrom(from);
    return *this;
  }
  inline AzureBlobUpload& operator=(AzureBlobUpload&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AzureBlobUpload& default_instance() {
    return *reinterpret_cast<const AzureBlobUpload*>(
        &_AzureBlobUpload_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(AzureBlobUpload& a, AzureBlobUpload& b) { a.Swap(&b); }
  inline void Swap(AzureBlobUpload* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AzureBlobUpload* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AzureBlobUpload* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AzureBlobUpload>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AzureBlobUpload& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AzureBlobUpload& from) { AzureBlobUpload::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AzureBlobUpload* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.AzureBlobUpload"; }

 protected:
  explicit AzureBlobUpload(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  AzureBlobUpload(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const AzureBlobUpload& from);
  AzureBlobUpload(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, AzureBlobUpload&& from) noexcept
      : AzureBlobUpload(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAccountNameFieldNumber = 1,
    kAccountKeyFieldNumber = 2,
    kContainerNameFieldNumber = 3,
  };
  // string account_name = 1;
  void clear_account_name() ;
  const std::string& account_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_account_name(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_account_name();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_account_name();
  void set_allocated_account_name(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_account_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_account_name(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_account_name();

  public:
  // string account_key = 2;
  void clear_account_key() ;
  const std::string& account_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_account_key(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_account_key();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_account_key();
  void set_allocated_account_key(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_account_key() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_account_key(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_account_key();

  public:
  // string container_name = 3;
  void clear_container_name() ;
  const std::string& container_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_container_name(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_container_name();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_container_name();
  void set_allocated_container_name(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_container_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_container_name(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_container_name();

  public:
  // @@protoc_insertion_point(class_scope:livekit.AzureBlobUpload)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 69,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const AzureBlobUpload& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr account_name_;
    ::google::protobuf::internal::ArenaStringPtr account_key_;
    ::google::protobuf::internal::ArenaStringPtr container_name_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull AzureBlobUpload_class_data_;
// -------------------------------------------------------------------

class AliOSSUpload final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.AliOSSUpload) */ {
 public:
  inline AliOSSUpload() : AliOSSUpload(nullptr) {}
  ~AliOSSUpload() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AliOSSUpload* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AliOSSUpload));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AliOSSUpload(::google::protobuf::internal::ConstantInitialized);

  inline AliOSSUpload(const AliOSSUpload& from) : AliOSSUpload(nullptr, from) {}
  inline AliOSSUpload(AliOSSUpload&& from) noexcept
      : AliOSSUpload(nullptr, std::move(from)) {}
  inline AliOSSUpload& operator=(const AliOSSUpload& from) {
    CopyFrom(from);
    return *this;
  }
  inline AliOSSUpload& operator=(AliOSSUpload&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AliOSSUpload& default_instance() {
    return *reinterpret_cast<const AliOSSUpload*>(
        &_AliOSSUpload_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(AliOSSUpload& a, AliOSSUpload& b) { a.Swap(&b); }
  inline void Swap(AliOSSUpload* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AliOSSUpload* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AliOSSUpload* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AliOSSUpload>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AliOSSUpload& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AliOSSUpload& from) { AliOSSUpload::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AliOSSUpload* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.AliOSSUpload"; }

 protected:
  explicit AliOSSUpload(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  AliOSSUpload(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const AliOSSUpload& from);
  AliOSSUpload(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, AliOSSUpload&& from) noexcept
      : AliOSSUpload(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAccessKeyFieldNumber = 1,
    kSecretFieldNumber = 2,
    kRegionFieldNumber = 3,
    kEndpointFieldNumber = 4,
    kBucketFieldNumber = 5,
  };
  // string access_key = 1;
  void clear_access_key() ;
  const std::string& access_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_access_key(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_access_key();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_access_key();
  void set_allocated_access_key(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_access_key() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_access_key(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_access_key();

  public:
  // string secret = 2;
  void clear_secret() ;
  const std::string& secret() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_secret(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_secret();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_secret();
  void set_allocated_secret(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_secret() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_secret(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_secret();

  public:
  // string region = 3;
  void clear_region() ;
  const std::string& region() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_region(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_region();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_region();
  void set_allocated_region(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_region() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_region(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_region();

  public:
  // string endpoint = 4;
  void clear_endpoint() ;
  const std::string& endpoint() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_endpoint(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_endpoint();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_endpoint();
  void set_allocated_endpoint(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_endpoint() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_endpoint(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_endpoint();

  public:
  // string bucket = 5;
  void clear_bucket() ;
  const std::string& bucket() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_bucket(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_bucket();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_bucket();
  void set_allocated_bucket(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_bucket() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_bucket(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_bucket();

  public:
  // @@protoc_insertion_point(class_scope:livekit.AliOSSUpload)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   0, 65,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const AliOSSUpload& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr access_key_;
    ::google::protobuf::internal::ArenaStringPtr secret_;
    ::google::protobuf::internal::ArenaStringPtr region_;
    ::google::protobuf::internal::ArenaStringPtr endpoint_;
    ::google::protobuf::internal::ArenaStringPtr bucket_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull AliOSSUpload_class_data_;
// -------------------------------------------------------------------

class StreamInfoList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.StreamInfoList) */ {
 public:
  inline StreamInfoList() : StreamInfoList(nullptr) {}
  ~StreamInfoList() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(StreamInfoList* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(StreamInfoList));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StreamInfoList(::google::protobuf::internal::ConstantInitialized);

  inline StreamInfoList(const StreamInfoList& from) : StreamInfoList(nullptr, from) {}
  inline StreamInfoList(StreamInfoList&& from) noexcept
      : StreamInfoList(nullptr, std::move(from)) {}
  inline StreamInfoList& operator=(const StreamInfoList& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamInfoList& operator=(StreamInfoList&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamInfoList& default_instance() {
    return *reinterpret_cast<const StreamInfoList*>(
        &_StreamInfoList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(StreamInfoList& a, StreamInfoList& b) { a.Swap(&b); }
  inline void Swap(StreamInfoList* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamInfoList* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamInfoList* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<StreamInfoList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StreamInfoList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StreamInfoList& from) { StreamInfoList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(StreamInfoList* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.StreamInfoList"; }

 protected:
  explicit StreamInfoList(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  StreamInfoList(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const StreamInfoList& from);
  StreamInfoList(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, StreamInfoList&& from) noexcept
      : StreamInfoList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInfoFieldNumber = 1,
  };
  // repeated .livekit.StreamInfo info = 1;
  int info_size() const;
  private:
  int _internal_info_size() const;

  public:
  void clear_info() ;
  ::livekit::StreamInfo* PROTOBUF_NONNULL mutable_info(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::StreamInfo>* PROTOBUF_NONNULL mutable_info();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::StreamInfo>& _internal_info() const;
  ::google::protobuf::RepeatedPtrField<::livekit::StreamInfo>* PROTOBUF_NONNULL _internal_mutable_info();
  public:
  const ::livekit::StreamInfo& info(int index) const;
  ::livekit::StreamInfo* PROTOBUF_NONNULL add_info();
  const ::google::protobuf::RepeatedPtrField<::livekit::StreamInfo>& info() const;
  // @@protoc_insertion_point(class_scope:livekit.StreamInfoList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const StreamInfoList& from_msg);
    ::google::protobuf::RepeatedPtrField< ::livekit::StreamInfo > info_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull StreamInfoList_class_data_;
// -------------------------------------------------------------------

class S3Upload final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.S3Upload) */ {
 public:
  inline S3Upload() : S3Upload(nullptr) {}
  ~S3Upload() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(S3Upload* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(S3Upload));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR S3Upload(::google::protobuf::internal::ConstantInitialized);

  inline S3Upload(const S3Upload& from) : S3Upload(nullptr, from) {}
  inline S3Upload(S3Upload&& from) noexcept
      : S3Upload(nullptr, std::move(from)) {}
  inline S3Upload& operator=(const S3Upload& from) {
    CopyFrom(from);
    return *this;
  }
  inline S3Upload& operator=(S3Upload&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S3Upload& default_instance() {
    return *reinterpret_cast<const S3Upload*>(
        &_S3Upload_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(S3Upload& a, S3Upload& b) { a.Swap(&b); }
  inline void Swap(S3Upload* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S3Upload* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S3Upload* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<S3Upload>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const S3Upload& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const S3Upload& from) { S3Upload::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(S3Upload* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.S3Upload"; }

 protected:
  explicit S3Upload(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  S3Upload(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const S3Upload& from);
  S3Upload(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, S3Upload&& from) noexcept
      : S3Upload(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMetadataFieldNumber = 7,
    kAccessKeyFieldNumber = 1,
    kSecretFieldNumber = 2,
    kRegionFieldNumber = 3,
    kEndpointFieldNumber = 4,
    kBucketFieldNumber = 5,
    kTaggingFieldNumber = 8,
    kContentDispositionFieldNumber = 9,
    kSessionTokenFieldNumber = 11,
    kProxyFieldNumber = 10,
    kForcePathStyleFieldNumber = 6,
  };
  // map<string, string> metadata = 7;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;

  public:
  void clear_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& metadata() const;
  ::google::protobuf::Map<std::string, std::string>* PROTOBUF_NONNULL mutable_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* PROTOBUF_NONNULL _internal_mutable_metadata();

  public:
  // string access_key = 1;
  void clear_access_key() ;
  const std::string& access_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_access_key(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_access_key();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_access_key();
  void set_allocated_access_key(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_access_key() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_access_key(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_access_key();

  public:
  // string secret = 2;
  void clear_secret() ;
  const std::string& secret() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_secret(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_secret();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_secret();
  void set_allocated_secret(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_secret() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_secret(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_secret();

  public:
  // string region = 3;
  void clear_region() ;
  const std::string& region() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_region(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_region();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_region();
  void set_allocated_region(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_region() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_region(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_region();

  public:
  // string endpoint = 4;
  void clear_endpoint() ;
  const std::string& endpoint() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_endpoint(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_endpoint();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_endpoint();
  void set_allocated_endpoint(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_endpoint() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_endpoint(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_endpoint();

  public:
  // string bucket = 5;
  void clear_bucket() ;
  const std::string& bucket() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_bucket(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_bucket();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_bucket();
  void set_allocated_bucket(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_bucket() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_bucket(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_bucket();

  public:
  // string tagging = 8;
  void clear_tagging() ;
  const std::string& tagging() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tagging(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_tagging();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_tagging();
  void set_allocated_tagging(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_tagging() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_tagging(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_tagging();

  public:
  // string content_disposition = 9;
  void clear_content_disposition() ;
  const std::string& content_disposition() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_content_disposition(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_content_disposition();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_content_disposition();
  void set_allocated_content_disposition(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_content_disposition() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_content_disposition(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_content_disposition();

  public:
  // string session_token = 11;
  void clear_session_token() ;
  const std::string& session_token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_session_token(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_session_token();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_session_token();
  void set_allocated_session_token(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_session_token() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_session_token(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_session_token();

  public:
  // .livekit.ProxyConfig proxy = 10;
  bool has_proxy() const;
  void clear_proxy() ;
  const ::livekit::ProxyConfig& proxy() const;
  [[nodiscard]] ::livekit::ProxyConfig* PROTOBUF_NULLABLE release_proxy();
  ::livekit::ProxyConfig* PROTOBUF_NONNULL mutable_proxy();
  void set_allocated_proxy(::livekit::ProxyConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_proxy(::livekit::ProxyConfig* PROTOBUF_NULLABLE value);
  ::livekit::ProxyConfig* PROTOBUF_NULLABLE unsafe_arena_release_proxy();

  private:
  const ::livekit::ProxyConfig& _internal_proxy() const;
  ::livekit::ProxyConfig* PROTOBUF_NONNULL _internal_mutable_proxy();

  public:
  // bool force_path_style = 6;
  void clear_force_path_style() ;
  bool force_path_style() const;
  void set_force_path_style(bool value);

  private:
  bool _internal_force_path_style() const;
  void _internal_set_force_path_style(bool value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.S3Upload)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 11,
                                   2, 116,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const S3Upload& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::MapField<S3Upload_MetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        metadata_;
    ::google::protobuf::internal::ArenaStringPtr access_key_;
    ::google::protobuf::internal::ArenaStringPtr secret_;
    ::google::protobuf::internal::ArenaStringPtr region_;
    ::google::protobuf::internal::ArenaStringPtr endpoint_;
    ::google::protobuf::internal::ArenaStringPtr bucket_;
    ::google::protobuf::internal::ArenaStringPtr tagging_;
    ::google::protobuf::internal::ArenaStringPtr content_disposition_;
    ::google::protobuf::internal::ArenaStringPtr session_token_;
    ::livekit::ProxyConfig* PROTOBUF_NULLABLE proxy_;
    bool force_path_style_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull S3Upload_class_data_;
// -------------------------------------------------------------------

class GCPUpload final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.GCPUpload) */ {
 public:
  inline GCPUpload() : GCPUpload(nullptr) {}
  ~GCPUpload() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GCPUpload* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GCPUpload));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GCPUpload(::google::protobuf::internal::ConstantInitialized);

  inline GCPUpload(const GCPUpload& from) : GCPUpload(nullptr, from) {}
  inline GCPUpload(GCPUpload&& from) noexcept
      : GCPUpload(nullptr, std::move(from)) {}
  inline GCPUpload& operator=(const GCPUpload& from) {
    CopyFrom(from);
    return *this;
  }
  inline GCPUpload& operator=(GCPUpload&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GCPUpload& default_instance() {
    return *reinterpret_cast<const GCPUpload*>(
        &_GCPUpload_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(GCPUpload& a, GCPUpload& b) { a.Swap(&b); }
  inline void Swap(GCPUpload* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GCPUpload* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GCPUpload* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GCPUpload>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GCPUpload& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GCPUpload& from) { GCPUpload::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GCPUpload* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.GCPUpload"; }

 protected:
  explicit GCPUpload(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GCPUpload(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GCPUpload& from);
  GCPUpload(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GCPUpload&& from) noexcept
      : GCPUpload(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCredentialsFieldNumber = 1,
    kBucketFieldNumber = 2,
    kProxyFieldNumber = 3,
  };
  // string credentials = 1;
  void clear_credentials() ;
  const std::string& credentials() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_credentials(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_credentials();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_credentials();
  void set_allocated_credentials(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_credentials() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_credentials(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_credentials();

  public:
  // string bucket = 2;
  void clear_bucket() ;
  const std::string& bucket() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_bucket(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_bucket();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_bucket();
  void set_allocated_bucket(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_bucket() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_bucket(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_bucket();

  public:
  // .livekit.ProxyConfig proxy = 3;
  bool has_proxy() const;
  void clear_proxy() ;
  const ::livekit::ProxyConfig& proxy() const;
  [[nodiscard]] ::livekit::ProxyConfig* PROTOBUF_NULLABLE release_proxy();
  ::livekit::ProxyConfig* PROTOBUF_NONNULL mutable_proxy();
  void set_allocated_proxy(::livekit::ProxyConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_proxy(::livekit::ProxyConfig* PROTOBUF_NULLABLE value);
  ::livekit::ProxyConfig* PROTOBUF_NULLABLE unsafe_arena_release_proxy();

  private:
  const ::livekit::ProxyConfig& _internal_proxy() const;
  ::livekit::ProxyConfig* PROTOBUF_NONNULL _internal_mutable_proxy();

  public:
  // @@protoc_insertion_point(class_scope:livekit.GCPUpload)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   1, 43,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GCPUpload& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr credentials_;
    ::google::protobuf::internal::ArenaStringPtr bucket_;
    ::livekit::ProxyConfig* PROTOBUF_NULLABLE proxy_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GCPUpload_class_data_;
// -------------------------------------------------------------------

class SegmentedFileOutput final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.SegmentedFileOutput) */ {
 public:
  inline SegmentedFileOutput() : SegmentedFileOutput(nullptr) {}
  ~SegmentedFileOutput() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SegmentedFileOutput* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SegmentedFileOutput));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SegmentedFileOutput(::google::protobuf::internal::ConstantInitialized);

  inline SegmentedFileOutput(const SegmentedFileOutput& from) : SegmentedFileOutput(nullptr, from) {}
  inline SegmentedFileOutput(SegmentedFileOutput&& from) noexcept
      : SegmentedFileOutput(nullptr, std::move(from)) {}
  inline SegmentedFileOutput& operator=(const SegmentedFileOutput& from) {
    CopyFrom(from);
    return *this;
  }
  inline SegmentedFileOutput& operator=(SegmentedFileOutput&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SegmentedFileOutput& default_instance() {
    return *reinterpret_cast<const SegmentedFileOutput*>(
        &_SegmentedFileOutput_default_instance_);
  }
  enum OutputCase {
    kS3 = 5,
    kGcp = 6,
    kAzure = 7,
    kAliOSS = 9,
    OUTPUT_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(SegmentedFileOutput& a, SegmentedFileOutput& b) { a.Swap(&b); }
  inline void Swap(SegmentedFileOutput* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SegmentedFileOutput* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SegmentedFileOutput* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SegmentedFileOutput>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SegmentedFileOutput& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SegmentedFileOutput& from) { SegmentedFileOutput::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SegmentedFileOutput* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.SegmentedFileOutput"; }

 protected:
  explicit SegmentedFileOutput(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SegmentedFileOutput(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SegmentedFileOutput& from);
  SegmentedFileOutput(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SegmentedFileOutput&& from) noexcept
      : SegmentedFileOutput(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFilenamePrefixFieldNumber = 2,
    kPlaylistNameFieldNumber = 3,
    kLivePlaylistNameFieldNumber = 11,
    kProtocolFieldNumber = 1,
    kSegmentDurationFieldNumber = 4,
    kDisableManifestFieldNumber = 8,
    kFilenameSuffixFieldNumber = 10,
    kS3FieldNumber = 5,
    kGcpFieldNumber = 6,
    kAzureFieldNumber = 7,
    kAliOSSFieldNumber = 9,
  };
  // string filename_prefix = 2;
  void clear_filename_prefix() ;
  const std::string& filename_prefix() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_filename_prefix(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_filename_prefix();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_filename_prefix();
  void set_allocated_filename_prefix(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_filename_prefix() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_filename_prefix(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_filename_prefix();

  public:
  // string playlist_name = 3;
  void clear_playlist_name() ;
  const std::string& playlist_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_playlist_name(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_playlist_name();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_playlist_name();
  void set_allocated_playlist_name(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_playlist_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_playlist_name(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_playlist_name();

  public:
  // string live_playlist_name = 11;
  void clear_live_playlist_name() ;
  const std::string& live_playlist_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_live_playlist_name(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_live_playlist_name();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_live_playlist_name();
  void set_allocated_live_playlist_name(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_live_playlist_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_live_playlist_name(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_live_playlist_name();

  public:
  // .livekit.SegmentedFileProtocol protocol = 1;
  void clear_protocol() ;
  ::livekit::SegmentedFileProtocol protocol() const;
  void set_protocol(::livekit::SegmentedFileProtocol value);

  private:
  ::livekit::SegmentedFileProtocol _internal_protocol() const;
  void _internal_set_protocol(::livekit::SegmentedFileProtocol value);

  public:
  // uint32 segment_duration = 4;
  void clear_segment_duration() ;
  ::uint32_t segment_duration() const;
  void set_segment_duration(::uint32_t value);

  private:
  ::uint32_t _internal_segment_duration() const;
  void _internal_set_segment_duration(::uint32_t value);

  public:
  // bool disable_manifest = 8;
  void clear_disable_manifest() ;
  bool disable_manifest() const;
  void set_disable_manifest(bool value);

  private:
  bool _internal_disable_manifest() const;
  void _internal_set_disable_manifest(bool value);

  public:
  // .livekit.SegmentedFileSuffix filename_suffix = 10;
  void clear_filename_suffix() ;
  ::livekit::SegmentedFileSuffix filename_suffix() const;
  void set_filename_suffix(::livekit::SegmentedFileSuffix value);

  private:
  ::livekit::SegmentedFileSuffix _internal_filename_suffix() const;
  void _internal_set_filename_suffix(::livekit::SegmentedFileSuffix value);

  public:
  // .livekit.S3Upload s3 = 5;
  bool has_s3() const;
  private:
  bool _internal_has_s3() const;

  public:
  void clear_s3() ;
  const ::livekit::S3Upload& s3() const;
  [[nodiscard]] ::livekit::S3Upload* PROTOBUF_NULLABLE release_s3();
  ::livekit::S3Upload* PROTOBUF_NONNULL mutable_s3();
  void set_allocated_s3(::livekit::S3Upload* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_s3(::livekit::S3Upload* PROTOBUF_NULLABLE value);
  ::livekit::S3Upload* PROTOBUF_NULLABLE unsafe_arena_release_s3();

  private:
  const ::livekit::S3Upload& _internal_s3() const;
  ::livekit::S3Upload* PROTOBUF_NONNULL _internal_mutable_s3();

  public:
  // .livekit.GCPUpload gcp = 6;
  bool has_gcp() const;
  private:
  bool _internal_has_gcp() const;

  public:
  void clear_gcp() ;
  const ::livekit::GCPUpload& gcp() const;
  [[nodiscard]] ::livekit::GCPUpload* PROTOBUF_NULLABLE release_gcp();
  ::livekit::GCPUpload* PROTOBUF_NONNULL mutable_gcp();
  void set_allocated_gcp(::livekit::GCPUpload* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_gcp(::livekit::GCPUpload* PROTOBUF_NULLABLE value);
  ::livekit::GCPUpload* PROTOBUF_NULLABLE unsafe_arena_release_gcp();

  private:
  const ::livekit::GCPUpload& _internal_gcp() const;
  ::livekit::GCPUpload* PROTOBUF_NONNULL _internal_mutable_gcp();

  public:
  // .livekit.AzureBlobUpload azure = 7;
  bool has_azure() const;
  private:
  bool _internal_has_azure() const;

  public:
  void clear_azure() ;
  const ::livekit::AzureBlobUpload& azure() const;
  [[nodiscard]] ::livekit::AzureBlobUpload* PROTOBUF_NULLABLE release_azure();
  ::livekit::AzureBlobUpload* PROTOBUF_NONNULL mutable_azure();
  void set_allocated_azure(::livekit::AzureBlobUpload* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_azure(::livekit::AzureBlobUpload* PROTOBUF_NULLABLE value);
  ::livekit::AzureBlobUpload* PROTOBUF_NULLABLE unsafe_arena_release_azure();

  private:
  const ::livekit::AzureBlobUpload& _internal_azure() const;
  ::livekit::AzureBlobUpload* PROTOBUF_NONNULL _internal_mutable_azure();

  public:
  // .livekit.AliOSSUpload aliOSS = 9;
  bool has_alioss() const;
  private:
  bool _internal_has_alioss() const;

  public:
  void clear_alioss() ;
  const ::livekit::AliOSSUpload& alioss() const;
  [[nodiscard]] ::livekit::AliOSSUpload* PROTOBUF_NULLABLE release_alioss();
  ::livekit::AliOSSUpload* PROTOBUF_NONNULL mutable_alioss();
  void set_allocated_alioss(::livekit::AliOSSUpload* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_alioss(::livekit::AliOSSUpload* PROTOBUF_NULLABLE value);
  ::livekit::AliOSSUpload* PROTOBUF_NULLABLE unsafe_arena_release_alioss();

  private:
  const ::livekit::AliOSSUpload& _internal_alioss() const;
  ::livekit::AliOSSUpload* PROTOBUF_NONNULL _internal_mutable_alioss();

  public:
  void clear_output();
  OutputCase output_case() const;
  // @@protoc_insertion_point(class_scope:livekit.SegmentedFileOutput)
 private:
  class _Internal;
  void set_has_s3();
  void set_has_gcp();
  void set_has_azure();
  void set_has_alioss();
  inline bool has_output() const;
  inline void clear_has_output();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 11,
                                   4, 90,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SegmentedFileOutput& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr filename_prefix_;
    ::google::protobuf::internal::ArenaStringPtr playlist_name_;
    ::google::protobuf::internal::ArenaStringPtr live_playlist_name_;
    int protocol_;
    ::uint32_t segment_duration_;
    bool disable_manifest_;
    int filename_suffix_;
    union OutputUnion {
      constexpr OutputUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE s3_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE gcp_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE azure_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE alioss_;
    } output_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SegmentedFileOutput_class_data_;
// -------------------------------------------------------------------

class ImageOutput final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.ImageOutput) */ {
 public:
  inline ImageOutput() : ImageOutput(nullptr) {}
  ~ImageOutput() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ImageOutput* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ImageOutput));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ImageOutput(::google::protobuf::internal::ConstantInitialized);

  inline ImageOutput(const ImageOutput& from) : ImageOutput(nullptr, from) {}
  inline ImageOutput(ImageOutput&& from) noexcept
      : ImageOutput(nullptr, std::move(from)) {}
  inline ImageOutput& operator=(const ImageOutput& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageOutput& operator=(ImageOutput&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImageOutput& default_instance() {
    return *reinterpret_cast<const ImageOutput*>(
        &_ImageOutput_default_instance_);
  }
  enum OutputCase {
    kS3 = 8,
    kGcp = 9,
    kAzure = 10,
    kAliOSS = 11,
    OUTPUT_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(ImageOutput& a, ImageOutput& b) { a.Swap(&b); }
  inline void Swap(ImageOutput* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageOutput* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImageOutput* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ImageOutput>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ImageOutput& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ImageOutput& from) { ImageOutput::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ImageOutput* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.ImageOutput"; }

 protected:
  explicit ImageOutput(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ImageOutput(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ImageOutput& from);
  ImageOutput(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ImageOutput&& from) noexcept
      : ImageOutput(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFilenamePrefixFieldNumber = 4,
    kCaptureIntervalFieldNumber = 1,
    kWidthFieldNumber = 2,
    kHeightFieldNumber = 3,
    kFilenameSuffixFieldNumber = 5,
    kImageCodecFieldNumber = 6,
    kDisableManifestFieldNumber = 7,
    kS3FieldNumber = 8,
    kGcpFieldNumber = 9,
    kAzureFieldNumber = 10,
    kAliOSSFieldNumber = 11,
  };
  // string filename_prefix = 4;
  void clear_filename_prefix() ;
  const std::string& filename_prefix() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_filename_prefix(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_filename_prefix();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_filename_prefix();
  void set_allocated_filename_prefix(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_filename_prefix() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_filename_prefix(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_filename_prefix();

  public:
  // uint32 capture_interval = 1;
  void clear_capture_interval() ;
  ::uint32_t capture_interval() const;
  void set_capture_interval(::uint32_t value);

  private:
  ::uint32_t _internal_capture_interval() const;
  void _internal_set_capture_interval(::uint32_t value);

  public:
  // int32 width = 2;
  void clear_width() ;
  ::int32_t width() const;
  void set_width(::int32_t value);

  private:
  ::int32_t _internal_width() const;
  void _internal_set_width(::int32_t value);

  public:
  // int32 height = 3;
  void clear_height() ;
  ::int32_t height() const;
  void set_height(::int32_t value);

  private:
  ::int32_t _internal_height() const;
  void _internal_set_height(::int32_t value);

  public:
  // .livekit.ImageFileSuffix filename_suffix = 5;
  void clear_filename_suffix() ;
  ::livekit::ImageFileSuffix filename_suffix() const;
  void set_filename_suffix(::livekit::ImageFileSuffix value);

  private:
  ::livekit::ImageFileSuffix _internal_filename_suffix() const;
  void _internal_set_filename_suffix(::livekit::ImageFileSuffix value);

  public:
  // .livekit.ImageCodec image_codec = 6;
  void clear_image_codec() ;
  ::livekit::ImageCodec image_codec() const;
  void set_image_codec(::livekit::ImageCodec value);

  private:
  ::livekit::ImageCodec _internal_image_codec() const;
  void _internal_set_image_codec(::livekit::ImageCodec value);

  public:
  // bool disable_manifest = 7;
  void clear_disable_manifest() ;
  bool disable_manifest() const;
  void set_disable_manifest(bool value);

  private:
  bool _internal_disable_manifest() const;
  void _internal_set_disable_manifest(bool value);

  public:
  // .livekit.S3Upload s3 = 8;
  bool has_s3() const;
  private:
  bool _internal_has_s3() const;

  public:
  void clear_s3() ;
  const ::livekit::S3Upload& s3() const;
  [[nodiscard]] ::livekit::S3Upload* PROTOBUF_NULLABLE release_s3();
  ::livekit::S3Upload* PROTOBUF_NONNULL mutable_s3();
  void set_allocated_s3(::livekit::S3Upload* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_s3(::livekit::S3Upload* PROTOBUF_NULLABLE value);
  ::livekit::S3Upload* PROTOBUF_NULLABLE unsafe_arena_release_s3();

  private:
  const ::livekit::S3Upload& _internal_s3() const;
  ::livekit::S3Upload* PROTOBUF_NONNULL _internal_mutable_s3();

  public:
  // .livekit.GCPUpload gcp = 9;
  bool has_gcp() const;
  private:
  bool _internal_has_gcp() const;

  public:
  void clear_gcp() ;
  const ::livekit::GCPUpload& gcp() const;
  [[nodiscard]] ::livekit::GCPUpload* PROTOBUF_NULLABLE release_gcp();
  ::livekit::GCPUpload* PROTOBUF_NONNULL mutable_gcp();
  void set_allocated_gcp(::livekit::GCPUpload* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_gcp(::livekit::GCPUpload* PROTOBUF_NULLABLE value);
  ::livekit::GCPUpload* PROTOBUF_NULLABLE unsafe_arena_release_gcp();

  private:
  const ::livekit::GCPUpload& _internal_gcp() const;
  ::livekit::GCPUpload* PROTOBUF_NONNULL _internal_mutable_gcp();

  public:
  // .livekit.AzureBlobUpload azure = 10;
  bool has_azure() const;
  private:
  bool _internal_has_azure() const;

  public:
  void clear_azure() ;
  const ::livekit::AzureBlobUpload& azure() const;
  [[nodiscard]] ::livekit::AzureBlobUpload* PROTOBUF_NULLABLE release_azure();
  ::livekit::AzureBlobUpload* PROTOBUF_NONNULL mutable_azure();
  void set_allocated_azure(::livekit::AzureBlobUpload* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_azure(::livekit::AzureBlobUpload* PROTOBUF_NULLABLE value);
  ::livekit::AzureBlobUpload* PROTOBUF_NULLABLE unsafe_arena_release_azure();

  private:
  const ::livekit::AzureBlobUpload& _internal_azure() const;
  ::livekit::AzureBlobUpload* PROTOBUF_NONNULL _internal_mutable_azure();

  public:
  // .livekit.AliOSSUpload aliOSS = 11;
  bool has_alioss() const;
  private:
  bool _internal_has_alioss() const;

  public:
  void clear_alioss() ;
  const ::livekit::AliOSSUpload& alioss() const;
  [[nodiscard]] ::livekit::AliOSSUpload* PROTOBUF_NULLABLE release_alioss();
  ::livekit::AliOSSUpload* PROTOBUF_NONNULL mutable_alioss();
  void set_allocated_alioss(::livekit::AliOSSUpload* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_alioss(::livekit::AliOSSUpload* PROTOBUF_NULLABLE value);
  ::livekit::AliOSSUpload* PROTOBUF_NULLABLE unsafe_arena_release_alioss();

  private:
  const ::livekit::AliOSSUpload& _internal_alioss() const;
  ::livekit::AliOSSUpload* PROTOBUF_NONNULL _internal_mutable_alioss();

  public:
  void clear_output();
  OutputCase output_case() const;
  // @@protoc_insertion_point(class_scope:livekit.ImageOutput)
 private:
  class _Internal;
  void set_has_s3();
  void set_has_gcp();
  void set_has_azure();
  void set_has_alioss();
  inline bool has_output() const;
  inline void clear_has_output();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 11,
                                   4, 51,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ImageOutput& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr filename_prefix_;
    ::uint32_t capture_interval_;
    ::int32_t width_;
    ::int32_t height_;
    int filename_suffix_;
    int image_codec_;
    bool disable_manifest_;
    union OutputUnion {
      constexpr OutputUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE s3_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE gcp_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE azure_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE alioss_;
    } output_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ImageOutput_class_data_;
// -------------------------------------------------------------------

class EncodedFileOutput final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.EncodedFileOutput) */ {
 public:
  inline EncodedFileOutput() : EncodedFileOutput(nullptr) {}
  ~EncodedFileOutput() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EncodedFileOutput* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EncodedFileOutput));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EncodedFileOutput(::google::protobuf::internal::ConstantInitialized);

  inline EncodedFileOutput(const EncodedFileOutput& from) : EncodedFileOutput(nullptr, from) {}
  inline EncodedFileOutput(EncodedFileOutput&& from) noexcept
      : EncodedFileOutput(nullptr, std::move(from)) {}
  inline EncodedFileOutput& operator=(const EncodedFileOutput& from) {
    CopyFrom(from);
    return *this;
  }
  inline EncodedFileOutput& operator=(EncodedFileOutput&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EncodedFileOutput& default_instance() {
    return *reinterpret_cast<const EncodedFileOutput*>(
        &_EncodedFileOutput_default_instance_);
  }
  enum OutputCase {
    kS3 = 3,
    kGcp = 4,
    kAzure = 5,
    kAliOSS = 7,
    OUTPUT_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(EncodedFileOutput& a, EncodedFileOutput& b) { a.Swap(&b); }
  inline void Swap(EncodedFileOutput* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EncodedFileOutput* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EncodedFileOutput* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EncodedFileOutput>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EncodedFileOutput& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EncodedFileOutput& from) { EncodedFileOutput::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EncodedFileOutput* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.EncodedFileOutput"; }

 protected:
  explicit EncodedFileOutput(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EncodedFileOutput(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EncodedFileOutput& from);
  EncodedFileOutput(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EncodedFileOutput&& from) noexcept
      : EncodedFileOutput(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFilepathFieldNumber = 2,
    kFileTypeFieldNumber = 1,
    kDisableManifestFieldNumber = 6,
    kS3FieldNumber = 3,
    kGcpFieldNumber = 4,
    kAzureFieldNumber = 5,
    kAliOSSFieldNumber = 7,
  };
  // string filepath = 2;
  void clear_filepath() ;
  const std::string& filepath() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_filepath(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_filepath();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_filepath();
  void set_allocated_filepath(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_filepath() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_filepath(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_filepath();

  public:
  // .livekit.EncodedFileType file_type = 1;
  void clear_file_type() ;
  ::livekit::EncodedFileType file_type() const;
  void set_file_type(::livekit::EncodedFileType value);

  private:
  ::livekit::EncodedFileType _internal_file_type() const;
  void _internal_set_file_type(::livekit::EncodedFileType value);

  public:
  // bool disable_manifest = 6;
  void clear_disable_manifest() ;
  bool disable_manifest() const;
  void set_disable_manifest(bool value);

  private:
  bool _internal_disable_manifest() const;
  void _internal_set_disable_manifest(bool value);

  public:
  // .livekit.S3Upload s3 = 3;
  bool has_s3() const;
  private:
  bool _internal_has_s3() const;

  public:
  void clear_s3() ;
  const ::livekit::S3Upload& s3() const;
  [[nodiscard]] ::livekit::S3Upload* PROTOBUF_NULLABLE release_s3();
  ::livekit::S3Upload* PROTOBUF_NONNULL mutable_s3();
  void set_allocated_s3(::livekit::S3Upload* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_s3(::livekit::S3Upload* PROTOBUF_NULLABLE value);
  ::livekit::S3Upload* PROTOBUF_NULLABLE unsafe_arena_release_s3();

  private:
  const ::livekit::S3Upload& _internal_s3() const;
  ::livekit::S3Upload* PROTOBUF_NONNULL _internal_mutable_s3();

  public:
  // .livekit.GCPUpload gcp = 4;
  bool has_gcp() const;
  private:
  bool _internal_has_gcp() const;

  public:
  void clear_gcp() ;
  const ::livekit::GCPUpload& gcp() const;
  [[nodiscard]] ::livekit::GCPUpload* PROTOBUF_NULLABLE release_gcp();
  ::livekit::GCPUpload* PROTOBUF_NONNULL mutable_gcp();
  void set_allocated_gcp(::livekit::GCPUpload* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_gcp(::livekit::GCPUpload* PROTOBUF_NULLABLE value);
  ::livekit::GCPUpload* PROTOBUF_NULLABLE unsafe_arena_release_gcp();

  private:
  const ::livekit::GCPUpload& _internal_gcp() const;
  ::livekit::GCPUpload* PROTOBUF_NONNULL _internal_mutable_gcp();

  public:
  // .livekit.AzureBlobUpload azure = 5;
  bool has_azure() const;
  private:
  bool _internal_has_azure() const;

  public:
  void clear_azure() ;
  const ::livekit::AzureBlobUpload& azure() const;
  [[nodiscard]] ::livekit::AzureBlobUpload* PROTOBUF_NULLABLE release_azure();
  ::livekit::AzureBlobUpload* PROTOBUF_NONNULL mutable_azure();
  void set_allocated_azure(::livekit::AzureBlobUpload* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_azure(::livekit::AzureBlobUpload* PROTOBUF_NULLABLE value);
  ::livekit::AzureBlobUpload* PROTOBUF_NULLABLE unsafe_arena_release_azure();

  private:
  const ::livekit::AzureBlobUpload& _internal_azure() const;
  ::livekit::AzureBlobUpload* PROTOBUF_NONNULL _internal_mutable_azure();

  public:
  // .livekit.AliOSSUpload aliOSS = 7;
  bool has_alioss() const;
  private:
  bool _internal_has_alioss() const;

  public:
  void clear_alioss() ;
  const ::livekit::AliOSSUpload& alioss() const;
  [[nodiscard]] ::livekit::AliOSSUpload* PROTOBUF_NULLABLE release_alioss();
  ::livekit::AliOSSUpload* PROTOBUF_NONNULL mutable_alioss();
  void set_allocated_alioss(::livekit::AliOSSUpload* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_alioss(::livekit::AliOSSUpload* PROTOBUF_NULLABLE value);
  ::livekit::AliOSSUpload* PROTOBUF_NULLABLE unsafe_arena_release_alioss();

  private:
  const ::livekit::AliOSSUpload& _internal_alioss() const;
  ::livekit::AliOSSUpload* PROTOBUF_NONNULL _internal_mutable_alioss();

  public:
  void clear_output();
  OutputCase output_case() const;
  // @@protoc_insertion_point(class_scope:livekit.EncodedFileOutput)
 private:
  class _Internal;
  void set_has_s3();
  void set_has_gcp();
  void set_has_azure();
  void set_has_alioss();
  inline bool has_output() const;
  inline void clear_has_output();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7,
                                   4, 42,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EncodedFileOutput& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr filepath_;
    int file_type_;
    bool disable_manifest_;
    union OutputUnion {
      constexpr OutputUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE s3_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE gcp_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE azure_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE alioss_;
    } output_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EncodedFileOutput_class_data_;
// -------------------------------------------------------------------

class DirectFileOutput final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.DirectFileOutput) */ {
 public:
  inline DirectFileOutput() : DirectFileOutput(nullptr) {}
  ~DirectFileOutput() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DirectFileOutput* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DirectFileOutput));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DirectFileOutput(::google::protobuf::internal::ConstantInitialized);

  inline DirectFileOutput(const DirectFileOutput& from) : DirectFileOutput(nullptr, from) {}
  inline DirectFileOutput(DirectFileOutput&& from) noexcept
      : DirectFileOutput(nullptr, std::move(from)) {}
  inline DirectFileOutput& operator=(const DirectFileOutput& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectFileOutput& operator=(DirectFileOutput&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DirectFileOutput& default_instance() {
    return *reinterpret_cast<const DirectFileOutput*>(
        &_DirectFileOutput_default_instance_);
  }
  enum OutputCase {
    kS3 = 2,
    kGcp = 3,
    kAzure = 4,
    kAliOSS = 6,
    OUTPUT_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(DirectFileOutput& a, DirectFileOutput& b) { a.Swap(&b); }
  inline void Swap(DirectFileOutput* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirectFileOutput* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DirectFileOutput* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DirectFileOutput>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DirectFileOutput& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DirectFileOutput& from) { DirectFileOutput::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DirectFileOutput* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.DirectFileOutput"; }

 protected:
  explicit DirectFileOutput(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DirectFileOutput(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DirectFileOutput& from);
  DirectFileOutput(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DirectFileOutput&& from) noexcept
      : DirectFileOutput(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFilepathFieldNumber = 1,
    kDisableManifestFieldNumber = 5,
    kS3FieldNumber = 2,
    kGcpFieldNumber = 3,
    kAzureFieldNumber = 4,
    kAliOSSFieldNumber = 6,
  };
  // string filepath = 1;
  void clear_filepath() ;
  const std::string& filepath() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_filepath(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_filepath();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_filepath();
  void set_allocated_filepath(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_filepath() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_filepath(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_filepath();

  public:
  // bool disable_manifest = 5;
  void clear_disable_manifest() ;
  bool disable_manifest() const;
  void set_disable_manifest(bool value);

  private:
  bool _internal_disable_manifest() const;
  void _internal_set_disable_manifest(bool value);

  public:
  // .livekit.S3Upload s3 = 2;
  bool has_s3() const;
  private:
  bool _internal_has_s3() const;

  public:
  void clear_s3() ;
  const ::livekit::S3Upload& s3() const;
  [[nodiscard]] ::livekit::S3Upload* PROTOBUF_NULLABLE release_s3();
  ::livekit::S3Upload* PROTOBUF_NONNULL mutable_s3();
  void set_allocated_s3(::livekit::S3Upload* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_s3(::livekit::S3Upload* PROTOBUF_NULLABLE value);
  ::livekit::S3Upload* PROTOBUF_NULLABLE unsafe_arena_release_s3();

  private:
  const ::livekit::S3Upload& _internal_s3() const;
  ::livekit::S3Upload* PROTOBUF_NONNULL _internal_mutable_s3();

  public:
  // .livekit.GCPUpload gcp = 3;
  bool has_gcp() const;
  private:
  bool _internal_has_gcp() const;

  public:
  void clear_gcp() ;
  const ::livekit::GCPUpload& gcp() const;
  [[nodiscard]] ::livekit::GCPUpload* PROTOBUF_NULLABLE release_gcp();
  ::livekit::GCPUpload* PROTOBUF_NONNULL mutable_gcp();
  void set_allocated_gcp(::livekit::GCPUpload* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_gcp(::livekit::GCPUpload* PROTOBUF_NULLABLE value);
  ::livekit::GCPUpload* PROTOBUF_NULLABLE unsafe_arena_release_gcp();

  private:
  const ::livekit::GCPUpload& _internal_gcp() const;
  ::livekit::GCPUpload* PROTOBUF_NONNULL _internal_mutable_gcp();

  public:
  // .livekit.AzureBlobUpload azure = 4;
  bool has_azure() const;
  private:
  bool _internal_has_azure() const;

  public:
  void clear_azure() ;
  const ::livekit::AzureBlobUpload& azure() const;
  [[nodiscard]] ::livekit::AzureBlobUpload* PROTOBUF_NULLABLE release_azure();
  ::livekit::AzureBlobUpload* PROTOBUF_NONNULL mutable_azure();
  void set_allocated_azure(::livekit::AzureBlobUpload* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_azure(::livekit::AzureBlobUpload* PROTOBUF_NULLABLE value);
  ::livekit::AzureBlobUpload* PROTOBUF_NULLABLE unsafe_arena_release_azure();

  private:
  const ::livekit::AzureBlobUpload& _internal_azure() const;
  ::livekit::AzureBlobUpload* PROTOBUF_NONNULL _internal_mutable_azure();

  public:
  // .livekit.AliOSSUpload aliOSS = 6;
  bool has_alioss() const;
  private:
  bool _internal_has_alioss() const;

  public:
  void clear_alioss() ;
  const ::livekit::AliOSSUpload& alioss() const;
  [[nodiscard]] ::livekit::AliOSSUpload* PROTOBUF_NULLABLE release_alioss();
  ::livekit::AliOSSUpload* PROTOBUF_NONNULL mutable_alioss();
  void set_allocated_alioss(::livekit::AliOSSUpload* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_alioss(::livekit::AliOSSUpload* PROTOBUF_NULLABLE value);
  ::livekit::AliOSSUpload* PROTOBUF_NULLABLE unsafe_arena_release_alioss();

  private:
  const ::livekit::AliOSSUpload& _internal_alioss() const;
  ::livekit::AliOSSUpload* PROTOBUF_NONNULL _internal_mutable_alioss();

  public:
  void clear_output();
  OutputCase output_case() const;
  // @@protoc_insertion_point(class_scope:livekit.DirectFileOutput)
 private:
  class _Internal;
  void set_has_s3();
  void set_has_gcp();
  void set_has_azure();
  void set_has_alioss();
  inline bool has_output() const;
  inline void clear_has_output();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   4, 41,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DirectFileOutput& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr filepath_;
    bool disable_manifest_;
    union OutputUnion {
      constexpr OutputUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE s3_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE gcp_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE azure_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE alioss_;
    } output_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DirectFileOutput_class_data_;
// -------------------------------------------------------------------

class AutoTrackEgress final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.AutoTrackEgress) */ {
 public:
  inline AutoTrackEgress() : AutoTrackEgress(nullptr) {}
  ~AutoTrackEgress() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AutoTrackEgress* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AutoTrackEgress));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AutoTrackEgress(::google::protobuf::internal::ConstantInitialized);

  inline AutoTrackEgress(const AutoTrackEgress& from) : AutoTrackEgress(nullptr, from) {}
  inline AutoTrackEgress(AutoTrackEgress&& from) noexcept
      : AutoTrackEgress(nullptr, std::move(from)) {}
  inline AutoTrackEgress& operator=(const AutoTrackEgress& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutoTrackEgress& operator=(AutoTrackEgress&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AutoTrackEgress& default_instance() {
    return *reinterpret_cast<const AutoTrackEgress*>(
        &_AutoTrackEgress_default_instance_);
  }
  enum OutputCase {
    kS3 = 2,
    kGcp = 3,
    kAzure = 4,
    kAliOSS = 6,
    OUTPUT_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 29;
  friend void swap(AutoTrackEgress& a, AutoTrackEgress& b) { a.Swap(&b); }
  inline void Swap(AutoTrackEgress* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutoTrackEgress* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutoTrackEgress* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AutoTrackEgress>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AutoTrackEgress& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AutoTrackEgress& from) { AutoTrackEgress::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AutoTrackEgress* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.AutoTrackEgress"; }

 protected:
  explicit AutoTrackEgress(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  AutoTrackEgress(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const AutoTrackEgress& from);
  AutoTrackEgress(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, AutoTrackEgress&& from) noexcept
      : AutoTrackEgress(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFilepathFieldNumber = 1,
    kDisableManifestFieldNumber = 5,
    kS3FieldNumber = 2,
    kGcpFieldNumber = 3,
    kAzureFieldNumber = 4,
    kAliOSSFieldNumber = 6,
  };
  // string filepath = 1;
  void clear_filepath() ;
  const std::string& filepath() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_filepath(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_filepath();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_filepath();
  void set_allocated_filepath(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_filepath() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_filepath(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_filepath();

  public:
  // bool disable_manifest = 5;
  void clear_disable_manifest() ;
  bool disable_manifest() const;
  void set_disable_manifest(bool value);

  private:
  bool _internal_disable_manifest() const;
  void _internal_set_disable_manifest(bool value);

  public:
  // .livekit.S3Upload s3 = 2;
  bool has_s3() const;
  private:
  bool _internal_has_s3() const;

  public:
  void clear_s3() ;
  const ::livekit::S3Upload& s3() const;
  [[nodiscard]] ::livekit::S3Upload* PROTOBUF_NULLABLE release_s3();
  ::livekit::S3Upload* PROTOBUF_NONNULL mutable_s3();
  void set_allocated_s3(::livekit::S3Upload* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_s3(::livekit::S3Upload* PROTOBUF_NULLABLE value);
  ::livekit::S3Upload* PROTOBUF_NULLABLE unsafe_arena_release_s3();

  private:
  const ::livekit::S3Upload& _internal_s3() const;
  ::livekit::S3Upload* PROTOBUF_NONNULL _internal_mutable_s3();

  public:
  // .livekit.GCPUpload gcp = 3;
  bool has_gcp() const;
  private:
  bool _internal_has_gcp() const;

  public:
  void clear_gcp() ;
  const ::livekit::GCPUpload& gcp() const;
  [[nodiscard]] ::livekit::GCPUpload* PROTOBUF_NULLABLE release_gcp();
  ::livekit::GCPUpload* PROTOBUF_NONNULL mutable_gcp();
  void set_allocated_gcp(::livekit::GCPUpload* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_gcp(::livekit::GCPUpload* PROTOBUF_NULLABLE value);
  ::livekit::GCPUpload* PROTOBUF_NULLABLE unsafe_arena_release_gcp();

  private:
  const ::livekit::GCPUpload& _internal_gcp() const;
  ::livekit::GCPUpload* PROTOBUF_NONNULL _internal_mutable_gcp();

  public:
  // .livekit.AzureBlobUpload azure = 4;
  bool has_azure() const;
  private:
  bool _internal_has_azure() const;

  public:
  void clear_azure() ;
  const ::livekit::AzureBlobUpload& azure() const;
  [[nodiscard]] ::livekit::AzureBlobUpload* PROTOBUF_NULLABLE release_azure();
  ::livekit::AzureBlobUpload* PROTOBUF_NONNULL mutable_azure();
  void set_allocated_azure(::livekit::AzureBlobUpload* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_azure(::livekit::AzureBlobUpload* PROTOBUF_NULLABLE value);
  ::livekit::AzureBlobUpload* PROTOBUF_NULLABLE unsafe_arena_release_azure();

  private:
  const ::livekit::AzureBlobUpload& _internal_azure() const;
  ::livekit::AzureBlobUpload* PROTOBUF_NONNULL _internal_mutable_azure();

  public:
  // .livekit.AliOSSUpload aliOSS = 6;
  bool has_alioss() const;
  private:
  bool _internal_has_alioss() const;

  public:
  void clear_alioss() ;
  const ::livekit::AliOSSUpload& alioss() const;
  [[nodiscard]] ::livekit::AliOSSUpload* PROTOBUF_NULLABLE release_alioss();
  ::livekit::AliOSSUpload* PROTOBUF_NONNULL mutable_alioss();
  void set_allocated_alioss(::livekit::AliOSSUpload* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_alioss(::livekit::AliOSSUpload* PROTOBUF_NULLABLE value);
  ::livekit::AliOSSUpload* PROTOBUF_NULLABLE unsafe_arena_release_alioss();

  private:
  const ::livekit::AliOSSUpload& _internal_alioss() const;
  ::livekit::AliOSSUpload* PROTOBUF_NONNULL _internal_mutable_alioss();

  public:
  void clear_output();
  OutputCase output_case() const;
  // @@protoc_insertion_point(class_scope:livekit.AutoTrackEgress)
 private:
  class _Internal;
  void set_has_s3();
  void set_has_gcp();
  void set_has_azure();
  void set_has_alioss();
  inline bool has_output() const;
  inline void clear_has_output();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   4, 40,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const AutoTrackEgress& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr filepath_;
    bool disable_manifest_;
    union OutputUnion {
      constexpr OutputUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE s3_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE gcp_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE azure_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE alioss_;
    } output_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull AutoTrackEgress_class_data_;
// -------------------------------------------------------------------

class WebEgressRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.WebEgressRequest) */ {
 public:
  inline WebEgressRequest() : WebEgressRequest(nullptr) {}
  ~WebEgressRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(WebEgressRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(WebEgressRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WebEgressRequest(::google::protobuf::internal::ConstantInitialized);

  inline WebEgressRequest(const WebEgressRequest& from) : WebEgressRequest(nullptr, from) {}
  inline WebEgressRequest(WebEgressRequest&& from) noexcept
      : WebEgressRequest(nullptr, std::move(from)) {}
  inline WebEgressRequest& operator=(const WebEgressRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WebEgressRequest& operator=(WebEgressRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WebEgressRequest& default_instance() {
    return *reinterpret_cast<const WebEgressRequest*>(
        &_WebEgressRequest_default_instance_);
  }
  enum OutputCase {
    kFile = 4,
    kStream = 5,
    kSegments = 6,
    OUTPUT_NOT_SET = 0,
  };
  enum OptionsCase {
    kPreset = 7,
    kAdvanced = 8,
    OPTIONS_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(WebEgressRequest& a, WebEgressRequest& b) { a.Swap(&b); }
  inline void Swap(WebEgressRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WebEgressRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WebEgressRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<WebEgressRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WebEgressRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const WebEgressRequest& from) { WebEgressRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(WebEgressRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.WebEgressRequest"; }

 protected:
  explicit WebEgressRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  WebEgressRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const WebEgressRequest& from);
  WebEgressRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, WebEgressRequest&& from) noexcept
      : WebEgressRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFileOutputsFieldNumber = 9,
    kStreamOutputsFieldNumber = 10,
    kSegmentOutputsFieldNumber = 11,
    kImageOutputsFieldNumber = 13,
    kUrlFieldNumber = 1,
    kAudioOnlyFieldNumber = 2,
    kVideoOnlyFieldNumber = 3,
    kAwaitStartSignalFieldNumber = 12,
    kFileFieldNumber = 4,
    kStreamFieldNumber = 5,
    kSegmentsFieldNumber = 6,
    kPresetFieldNumber = 7,
    kAdvancedFieldNumber = 8,
  };
  // repeated .livekit.EncodedFileOutput file_outputs = 9;
  int file_outputs_size() const;
  private:
  int _internal_file_outputs_size() const;

  public:
  void clear_file_outputs() ;
  ::livekit::EncodedFileOutput* PROTOBUF_NONNULL mutable_file_outputs(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::EncodedFileOutput>* PROTOBUF_NONNULL mutable_file_outputs();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::EncodedFileOutput>& _internal_file_outputs() const;
  ::google::protobuf::RepeatedPtrField<::livekit::EncodedFileOutput>* PROTOBUF_NONNULL _internal_mutable_file_outputs();
  public:
  const ::livekit::EncodedFileOutput& file_outputs(int index) const;
  ::livekit::EncodedFileOutput* PROTOBUF_NONNULL add_file_outputs();
  const ::google::protobuf::RepeatedPtrField<::livekit::EncodedFileOutput>& file_outputs() const;
  // repeated .livekit.StreamOutput stream_outputs = 10;
  int stream_outputs_size() const;
  private:
  int _internal_stream_outputs_size() const;

  public:
  void clear_stream_outputs() ;
  ::livekit::StreamOutput* PROTOBUF_NONNULL mutable_stream_outputs(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::StreamOutput>* PROTOBUF_NONNULL mutable_stream_outputs();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::StreamOutput>& _internal_stream_outputs() const;
  ::google::protobuf::RepeatedPtrField<::livekit::StreamOutput>* PROTOBUF_NONNULL _internal_mutable_stream_outputs();
  public:
  const ::livekit::StreamOutput& stream_outputs(int index) const;
  ::livekit::StreamOutput* PROTOBUF_NONNULL add_stream_outputs();
  const ::google::protobuf::RepeatedPtrField<::livekit::StreamOutput>& stream_outputs() const;
  // repeated .livekit.SegmentedFileOutput segment_outputs = 11;
  int segment_outputs_size() const;
  private:
  int _internal_segment_outputs_size() const;

  public:
  void clear_segment_outputs() ;
  ::livekit::SegmentedFileOutput* PROTOBUF_NONNULL mutable_segment_outputs(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::SegmentedFileOutput>* PROTOBUF_NONNULL mutable_segment_outputs();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::SegmentedFileOutput>& _internal_segment_outputs() const;
  ::google::protobuf::RepeatedPtrField<::livekit::SegmentedFileOutput>* PROTOBUF_NONNULL _internal_mutable_segment_outputs();
  public:
  const ::livekit::SegmentedFileOutput& segment_outputs(int index) const;
  ::livekit::SegmentedFileOutput* PROTOBUF_NONNULL add_segment_outputs();
  const ::google::protobuf::RepeatedPtrField<::livekit::SegmentedFileOutput>& segment_outputs() const;
  // repeated .livekit.ImageOutput image_outputs = 13;
  int image_outputs_size() const;
  private:
  int _internal_image_outputs_size() const;

  public:
  void clear_image_outputs() ;
  ::livekit::ImageOutput* PROTOBUF_NONNULL mutable_image_outputs(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::ImageOutput>* PROTOBUF_NONNULL mutable_image_outputs();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::ImageOutput>& _internal_image_outputs() const;
  ::google::protobuf::RepeatedPtrField<::livekit::ImageOutput>* PROTOBUF_NONNULL _internal_mutable_image_outputs();
  public:
  const ::livekit::ImageOutput& image_outputs(int index) const;
  ::livekit::ImageOutput* PROTOBUF_NONNULL add_image_outputs();
  const ::google::protobuf::RepeatedPtrField<::livekit::ImageOutput>& image_outputs() const;
  // string url = 1;
  void clear_url() ;
  const std::string& url() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_url(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_url();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_url();
  void set_allocated_url(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_url() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_url();

  public:
  // bool audio_only = 2;
  void clear_audio_only() ;
  bool audio_only() const;
  void set_audio_only(bool value);

  private:
  bool _internal_audio_only() const;
  void _internal_set_audio_only(bool value);

  public:
  // bool video_only = 3;
  void clear_video_only() ;
  bool video_only() const;
  void set_video_only(bool value);

  private:
  bool _internal_video_only() const;
  void _internal_set_video_only(bool value);

  public:
  // bool await_start_signal = 12;
  void clear_await_start_signal() ;
  bool await_start_signal() const;
  void set_await_start_signal(bool value);

  private:
  bool _internal_await_start_signal() const;
  void _internal_set_await_start_signal(bool value);

  public:
  // .livekit.EncodedFileOutput file = 4 [deprecated = true];
  [[deprecated]]  bool has_file() const;
  private:
  bool _internal_has_file() const;

  public:
  [[deprecated]]  void clear_file() ;
  [[deprecated]] const ::livekit::EncodedFileOutput& file() const;
  [[deprecated]] [[nodiscard]] ::livekit::EncodedFileOutput* PROTOBUF_NULLABLE release_file();
  [[deprecated]] ::livekit::EncodedFileOutput* PROTOBUF_NONNULL mutable_file();
  [[deprecated]] void set_allocated_file(::livekit::EncodedFileOutput* PROTOBUF_NULLABLE value);
  [[deprecated]] void unsafe_arena_set_allocated_file(::livekit::EncodedFileOutput* PROTOBUF_NULLABLE value);
  [[deprecated]] ::livekit::EncodedFileOutput* PROTOBUF_NULLABLE unsafe_arena_release_file();

  private:
  const ::livekit::EncodedFileOutput& _internal_file() const;
  ::livekit::EncodedFileOutput* PROTOBUF_NONNULL _internal_mutable_file();

  public:
  // .livekit.StreamOutput stream = 5 [deprecated = true];
  [[deprecated]]  bool has_stream() const;
  private:
  bool _internal_has_stream() const;

  public:
  [[deprecated]]  void clear_stream() ;
  [[deprecated]] const ::livekit::StreamOutput& stream() const;
  [[deprecated]] [[nodiscard]] ::livekit::StreamOutput* PROTOBUF_NULLABLE release_stream();
  [[deprecated]] ::livekit::StreamOutput* PROTOBUF_NONNULL mutable_stream();
  [[deprecated]] void set_allocated_stream(::livekit::StreamOutput* PROTOBUF_NULLABLE value);
  [[deprecated]] void unsafe_arena_set_allocated_stream(::livekit::StreamOutput* PROTOBUF_NULLABLE value);
  [[deprecated]] ::livekit::StreamOutput* PROTOBUF_NULLABLE unsafe_arena_release_stream();

  private:
  const ::livekit::StreamOutput& _internal_stream() const;
  ::livekit::StreamOutput* PROTOBUF_NONNULL _internal_mutable_stream();

  public:
  // .livekit.SegmentedFileOutput segments = 6 [deprecated = true];
  [[deprecated]]  bool has_segments() const;
  private:
  bool _internal_has_segments() const;

  public:
  [[deprecated]]  void clear_segments() ;
  [[deprecated]] const ::livekit::SegmentedFileOutput& segments() const;
  [[deprecated]] [[nodiscard]] ::livekit::SegmentedFileOutput* PROTOBUF_NULLABLE release_segments();
  [[deprecated]] ::livekit::SegmentedFileOutput* PROTOBUF_NONNULL mutable_segments();
  [[deprecated]] void set_allocated_segments(::livekit::SegmentedFileOutput* PROTOBUF_NULLABLE value);
  [[deprecated]] void unsafe_arena_set_allocated_segments(::livekit::SegmentedFileOutput* PROTOBUF_NULLABLE value);
  [[deprecated]] ::livekit::SegmentedFileOutput* PROTOBUF_NULLABLE unsafe_arena_release_segments();

  private:
  const ::livekit::SegmentedFileOutput& _internal_segments() const;
  ::livekit::SegmentedFileOutput* PROTOBUF_NONNULL _internal_mutable_segments();

  public:
  // .livekit.EncodingOptionsPreset preset = 7;
  bool has_preset() const;
  void clear_preset() ;
  ::livekit::EncodingOptionsPreset preset() const;
  void set_preset(::livekit::EncodingOptionsPreset value);

  private:
  ::livekit::EncodingOptionsPreset _internal_preset() const;
  void _internal_set_preset(::livekit::EncodingOptionsPreset value);

  public:
  // .livekit.EncodingOptions advanced = 8;
  bool has_advanced() const;
  private:
  bool _internal_has_advanced() const;

  public:
  void clear_advanced() ;
  const ::livekit::EncodingOptions& advanced() const;
  [[nodiscard]] ::livekit::EncodingOptions* PROTOBUF_NULLABLE release_advanced();
  ::livekit::EncodingOptions* PROTOBUF_NONNULL mutable_advanced();
  void set_allocated_advanced(::livekit::EncodingOptions* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_advanced(::livekit::EncodingOptions* PROTOBUF_NULLABLE value);
  ::livekit::EncodingOptions* PROTOBUF_NULLABLE unsafe_arena_release_advanced();

  private:
  const ::livekit::EncodingOptions& _internal_advanced() const;
  ::livekit::EncodingOptions* PROTOBUF_NONNULL _internal_mutable_advanced();

  public:
  void clear_output();
  OutputCase output_case() const;
  void clear_options();
  OptionsCase options_case() const;
  // @@protoc_insertion_point(class_scope:livekit.WebEgressRequest)
 private:
  class _Internal;
  void set_has_file();
  void set_has_stream();
  void set_has_segments();
  void set_has_preset();
  void set_has_advanced();
  inline bool has_output() const;
  inline void clear_has_output();
  inline bool has_options() const;
  inline void clear_has_options();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 13,
                                   8, 44,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const WebEgressRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::livekit::EncodedFileOutput > file_outputs_;
    ::google::protobuf::RepeatedPtrField< ::livekit::StreamOutput > stream_outputs_;
    ::google::protobuf::RepeatedPtrField< ::livekit::SegmentedFileOutput > segment_outputs_;
    ::google::protobuf::RepeatedPtrField< ::livekit::ImageOutput > image_outputs_;
    ::google::protobuf::internal::ArenaStringPtr url_;
    bool audio_only_;
    bool video_only_;
    bool await_start_signal_;
    union OutputUnion {
      constexpr OutputUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE file_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE stream_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE segments_;
    } output_;
    union OptionsUnion {
      constexpr OptionsUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      int preset_;
      ::livekit::EncodingOptions* PROTOBUF_NULLABLE advanced_;
    } options_;
    ::uint32_t _oneof_case_[2];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull WebEgressRequest_class_data_;
// -------------------------------------------------------------------

class TrackEgressRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.TrackEgressRequest) */ {
 public:
  inline TrackEgressRequest() : TrackEgressRequest(nullptr) {}
  ~TrackEgressRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TrackEgressRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TrackEgressRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TrackEgressRequest(::google::protobuf::internal::ConstantInitialized);

  inline TrackEgressRequest(const TrackEgressRequest& from) : TrackEgressRequest(nullptr, from) {}
  inline TrackEgressRequest(TrackEgressRequest&& from) noexcept
      : TrackEgressRequest(nullptr, std::move(from)) {}
  inline TrackEgressRequest& operator=(const TrackEgressRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackEgressRequest& operator=(TrackEgressRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackEgressRequest& default_instance() {
    return *reinterpret_cast<const TrackEgressRequest*>(
        &_TrackEgressRequest_default_instance_);
  }
  enum OutputCase {
    kFile = 3,
    kWebsocketUrl = 4,
    OUTPUT_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(TrackEgressRequest& a, TrackEgressRequest& b) { a.Swap(&b); }
  inline void Swap(TrackEgressRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackEgressRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackEgressRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TrackEgressRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrackEgressRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TrackEgressRequest& from) { TrackEgressRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TrackEgressRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.TrackEgressRequest"; }

 protected:
  explicit TrackEgressRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TrackEgressRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TrackEgressRequest& from);
  TrackEgressRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TrackEgressRequest&& from) noexcept
      : TrackEgressRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRoomNameFieldNumber = 1,
    kTrackIdFieldNumber = 2,
    kFileFieldNumber = 3,
    kWebsocketUrlFieldNumber = 4,
  };
  // string room_name = 1;
  void clear_room_name() ;
  const std::string& room_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_room_name(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_room_name();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_room_name();
  void set_allocated_room_name(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_room_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_room_name(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_room_name();

  public:
  // string track_id = 2;
  void clear_track_id() ;
  const std::string& track_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_track_id(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_track_id();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_track_id();
  void set_allocated_track_id(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_track_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_track_id(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_track_id();

  public:
  // .livekit.DirectFileOutput file = 3;
  bool has_file() const;
  private:
  bool _internal_has_file() const;

  public:
  void clear_file() ;
  const ::livekit::DirectFileOutput& file() const;
  [[nodiscard]] ::livekit::DirectFileOutput* PROTOBUF_NULLABLE release_file();
  ::livekit::DirectFileOutput* PROTOBUF_NONNULL mutable_file();
  void set_allocated_file(::livekit::DirectFileOutput* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_file(::livekit::DirectFileOutput* PROTOBUF_NULLABLE value);
  ::livekit::DirectFileOutput* PROTOBUF_NULLABLE unsafe_arena_release_file();

  private:
  const ::livekit::DirectFileOutput& _internal_file() const;
  ::livekit::DirectFileOutput* PROTOBUF_NONNULL _internal_mutable_file();

  public:
  // string websocket_url = 4;
  bool has_websocket_url() const;
  void clear_websocket_url() ;
  const std::string& websocket_url() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_websocket_url(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_websocket_url();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_websocket_url();
  void set_allocated_websocket_url(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_websocket_url() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_websocket_url(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_websocket_url();

  public:
  void clear_output();
  OutputCase output_case() const;
  // @@protoc_insertion_point(class_scope:livekit.TrackEgressRequest)
 private:
  class _Internal;
  void set_has_file();
  void set_has_websocket_url();
  inline bool has_output() const;
  inline void clear_has_output();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 4,
                                   1, 65,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TrackEgressRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr room_name_;
    ::google::protobuf::internal::ArenaStringPtr track_id_;
    union OutputUnion {
      constexpr OutputUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::livekit::DirectFileOutput* PROTOBUF_NULLABLE file_;
      ::google::protobuf::internal::ArenaStringPtr websocket_url_;
    } output_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TrackEgressRequest_class_data_;
// -------------------------------------------------------------------

class TrackCompositeEgressRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.TrackCompositeEgressRequest) */ {
 public:
  inline TrackCompositeEgressRequest() : TrackCompositeEgressRequest(nullptr) {}
  ~TrackCompositeEgressRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TrackCompositeEgressRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TrackCompositeEgressRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TrackCompositeEgressRequest(::google::protobuf::internal::ConstantInitialized);

  inline TrackCompositeEgressRequest(const TrackCompositeEgressRequest& from) : TrackCompositeEgressRequest(nullptr, from) {}
  inline TrackCompositeEgressRequest(TrackCompositeEgressRequest&& from) noexcept
      : TrackCompositeEgressRequest(nullptr, std::move(from)) {}
  inline TrackCompositeEgressRequest& operator=(const TrackCompositeEgressRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackCompositeEgressRequest& operator=(TrackCompositeEgressRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackCompositeEgressRequest& default_instance() {
    return *reinterpret_cast<const TrackCompositeEgressRequest*>(
        &_TrackCompositeEgressRequest_default_instance_);
  }
  enum OutputCase {
    kFile = 4,
    kStream = 5,
    kSegments = 8,
    OUTPUT_NOT_SET = 0,
  };
  enum OptionsCase {
    kPreset = 6,
    kAdvanced = 7,
    OPTIONS_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(TrackCompositeEgressRequest& a, TrackCompositeEgressRequest& b) { a.Swap(&b); }
  inline void Swap(TrackCompositeEgressRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackCompositeEgressRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackCompositeEgressRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TrackCompositeEgressRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrackCompositeEgressRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TrackCompositeEgressRequest& from) { TrackCompositeEgressRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TrackCompositeEgressRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.TrackCompositeEgressRequest"; }

 protected:
  explicit TrackCompositeEgressRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TrackCompositeEgressRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TrackCompositeEgressRequest& from);
  TrackCompositeEgressRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TrackCompositeEgressRequest&& from) noexcept
      : TrackCompositeEgressRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFileOutputsFieldNumber = 11,
    kStreamOutputsFieldNumber = 12,
    kSegmentOutputsFieldNumber = 13,
    kImageOutputsFieldNumber = 14,
    kRoomNameFieldNumber = 1,
    kAudioTrackIdFieldNumber = 2,
    kVideoTrackIdFieldNumber = 3,
    kFileFieldNumber = 4,
    kStreamFieldNumber = 5,
    kSegmentsFieldNumber = 8,
    kPresetFieldNumber = 6,
    kAdvancedFieldNumber = 7,
  };
  // repeated .livekit.EncodedFileOutput file_outputs = 11;
  int file_outputs_size() const;
  private:
  int _internal_file_outputs_size() const;

  public:
  void clear_file_outputs() ;
  ::livekit::EncodedFileOutput* PROTOBUF_NONNULL mutable_file_outputs(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::EncodedFileOutput>* PROTOBUF_NONNULL mutable_file_outputs();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::EncodedFileOutput>& _internal_file_outputs() const;
  ::google::protobuf::RepeatedPtrField<::livekit::EncodedFileOutput>* PROTOBUF_NONNULL _internal_mutable_file_outputs();
  public:
  const ::livekit::EncodedFileOutput& file_outputs(int index) const;
  ::livekit::EncodedFileOutput* PROTOBUF_NONNULL add_file_outputs();
  const ::google::protobuf::RepeatedPtrField<::livekit::EncodedFileOutput>& file_outputs() const;
  // repeated .livekit.StreamOutput stream_outputs = 12;
  int stream_outputs_size() const;
  private:
  int _internal_stream_outputs_size() const;

  public:
  void clear_stream_outputs() ;
  ::livekit::StreamOutput* PROTOBUF_NONNULL mutable_stream_outputs(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::StreamOutput>* PROTOBUF_NONNULL mutable_stream_outputs();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::StreamOutput>& _internal_stream_outputs() const;
  ::google::protobuf::RepeatedPtrField<::livekit::StreamOutput>* PROTOBUF_NONNULL _internal_mutable_stream_outputs();
  public:
  const ::livekit::StreamOutput& stream_outputs(int index) const;
  ::livekit::StreamOutput* PROTOBUF_NONNULL add_stream_outputs();
  const ::google::protobuf::RepeatedPtrField<::livekit::StreamOutput>& stream_outputs() const;
  // repeated .livekit.SegmentedFileOutput segment_outputs = 13;
  int segment_outputs_size() const;
  private:
  int _internal_segment_outputs_size() const;

  public:
  void clear_segment_outputs() ;
  ::livekit::SegmentedFileOutput* PROTOBUF_NONNULL mutable_segment_outputs(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::SegmentedFileOutput>* PROTOBUF_NONNULL mutable_segment_outputs();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::SegmentedFileOutput>& _internal_segment_outputs() const;
  ::google::protobuf::RepeatedPtrField<::livekit::SegmentedFileOutput>* PROTOBUF_NONNULL _internal_mutable_segment_outputs();
  public:
  const ::livekit::SegmentedFileOutput& segment_outputs(int index) const;
  ::livekit::SegmentedFileOutput* PROTOBUF_NONNULL add_segment_outputs();
  const ::google::protobuf::RepeatedPtrField<::livekit::SegmentedFileOutput>& segment_outputs() const;
  // repeated .livekit.ImageOutput image_outputs = 14;
  int image_outputs_size() const;
  private:
  int _internal_image_outputs_size() const;

  public:
  void clear_image_outputs() ;
  ::livekit::ImageOutput* PROTOBUF_NONNULL mutable_image_outputs(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::ImageOutput>* PROTOBUF_NONNULL mutable_image_outputs();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::ImageOutput>& _internal_image_outputs() const;
  ::google::protobuf::RepeatedPtrField<::livekit::ImageOutput>* PROTOBUF_NONNULL _internal_mutable_image_outputs();
  public:
  const ::livekit::ImageOutput& image_outputs(int index) const;
  ::livekit::ImageOutput* PROTOBUF_NONNULL add_image_outputs();
  const ::google::protobuf::RepeatedPtrField<::livekit::ImageOutput>& image_outputs() const;
  // string room_name = 1;
  void clear_room_name() ;
  const std::string& room_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_room_name(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_room_name();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_room_name();
  void set_allocated_room_name(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_room_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_room_name(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_room_name();

  public:
  // string audio_track_id = 2;
  void clear_audio_track_id() ;
  const std::string& audio_track_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_audio_track_id(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_audio_track_id();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_audio_track_id();
  void set_allocated_audio_track_id(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_audio_track_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_audio_track_id(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_audio_track_id();

  public:
  // string video_track_id = 3;
  void clear_video_track_id() ;
  const std::string& video_track_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_video_track_id(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_video_track_id();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_video_track_id();
  void set_allocated_video_track_id(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_video_track_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_video_track_id(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_video_track_id();

  public:
  // .livekit.EncodedFileOutput file = 4 [deprecated = true];
  [[deprecated]]  bool has_file() const;
  private:
  bool _internal_has_file() const;

  public:
  [[deprecated]]  void clear_file() ;
  [[deprecated]] const ::livekit::EncodedFileOutput& file() const;
  [[deprecated]] [[nodiscard]] ::livekit::EncodedFileOutput* PROTOBUF_NULLABLE release_file();
  [[deprecated]] ::livekit::EncodedFileOutput* PROTOBUF_NONNULL mutable_file();
  [[deprecated]] void set_allocated_file(::livekit::EncodedFileOutput* PROTOBUF_NULLABLE value);
  [[deprecated]] void unsafe_arena_set_allocated_file(::livekit::EncodedFileOutput* PROTOBUF_NULLABLE value);
  [[deprecated]] ::livekit::EncodedFileOutput* PROTOBUF_NULLABLE unsafe_arena_release_file();

  private:
  const ::livekit::EncodedFileOutput& _internal_file() const;
  ::livekit::EncodedFileOutput* PROTOBUF_NONNULL _internal_mutable_file();

  public:
  // .livekit.StreamOutput stream = 5 [deprecated = true];
  [[deprecated]]  bool has_stream() const;
  private:
  bool _internal_has_stream() const;

  public:
  [[deprecated]]  void clear_stream() ;
  [[deprecated]] const ::livekit::StreamOutput& stream() const;
  [[deprecated]] [[nodiscard]] ::livekit::StreamOutput* PROTOBUF_NULLABLE release_stream();
  [[deprecated]] ::livekit::StreamOutput* PROTOBUF_NONNULL mutable_stream();
  [[deprecated]] void set_allocated_stream(::livekit::StreamOutput* PROTOBUF_NULLABLE value);
  [[deprecated]] void unsafe_arena_set_allocated_stream(::livekit::StreamOutput* PROTOBUF_NULLABLE value);
  [[deprecated]] ::livekit::StreamOutput* PROTOBUF_NULLABLE unsafe_arena_release_stream();

  private:
  const ::livekit::StreamOutput& _internal_stream() const;
  ::livekit::StreamOutput* PROTOBUF_NONNULL _internal_mutable_stream();

  public:
  // .livekit.SegmentedFileOutput segments = 8 [deprecated = true];
  [[deprecated]]  bool has_segments() const;
  private:
  bool _internal_has_segments() const;

  public:
  [[deprecated]]  void clear_segments() ;
  [[deprecated]] const ::livekit::SegmentedFileOutput& segments() const;
  [[deprecated]] [[nodiscard]] ::livekit::SegmentedFileOutput* PROTOBUF_NULLABLE release_segments();
  [[deprecated]] ::livekit::SegmentedFileOutput* PROTOBUF_NONNULL mutable_segments();
  [[deprecated]] void set_allocated_segments(::livekit::SegmentedFileOutput* PROTOBUF_NULLABLE value);
  [[deprecated]] void unsafe_arena_set_allocated_segments(::livekit::SegmentedFileOutput* PROTOBUF_NULLABLE value);
  [[deprecated]] ::livekit::SegmentedFileOutput* PROTOBUF_NULLABLE unsafe_arena_release_segments();

  private:
  const ::livekit::SegmentedFileOutput& _internal_segments() const;
  ::livekit::SegmentedFileOutput* PROTOBUF_NONNULL _internal_mutable_segments();

  public:
  // .livekit.EncodingOptionsPreset preset = 6;
  bool has_preset() const;
  void clear_preset() ;
  ::livekit::EncodingOptionsPreset preset() const;
  void set_preset(::livekit::EncodingOptionsPreset value);

  private:
  ::livekit::EncodingOptionsPreset _internal_preset() const;
  void _internal_set_preset(::livekit::EncodingOptionsPreset value);

  public:
  // .livekit.EncodingOptions advanced = 7;
  bool has_advanced() const;
  private:
  bool _internal_has_advanced() const;

  public:
  void clear_advanced() ;
  const ::livekit::EncodingOptions& advanced() const;
  [[nodiscard]] ::livekit::EncodingOptions* PROTOBUF_NULLABLE release_advanced();
  ::livekit::EncodingOptions* PROTOBUF_NONNULL mutable_advanced();
  void set_allocated_advanced(::livekit::EncodingOptions* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_advanced(::livekit::EncodingOptions* PROTOBUF_NULLABLE value);
  ::livekit::EncodingOptions* PROTOBUF_NULLABLE unsafe_arena_release_advanced();

  private:
  const ::livekit::EncodingOptions& _internal_advanced() const;
  ::livekit::EncodingOptions* PROTOBUF_NONNULL _internal_mutable_advanced();

  public:
  void clear_output();
  OutputCase output_case() const;
  void clear_options();
  OptionsCase options_case() const;
  // @@protoc_insertion_point(class_scope:livekit.TrackCompositeEgressRequest)
 private:
  class _Internal;
  void set_has_file();
  void set_has_stream();
  void set_has_segments();
  void set_has_preset();
  void set_has_advanced();
  inline bool has_output() const;
  inline void clear_has_output();
  inline bool has_options() const;
  inline void clear_has_options();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 12,
                                   8, 89,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TrackCompositeEgressRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::livekit::EncodedFileOutput > file_outputs_;
    ::google::protobuf::RepeatedPtrField< ::livekit::StreamOutput > stream_outputs_;
    ::google::protobuf::RepeatedPtrField< ::livekit::SegmentedFileOutput > segment_outputs_;
    ::google::protobuf::RepeatedPtrField< ::livekit::ImageOutput > image_outputs_;
    ::google::protobuf::internal::ArenaStringPtr room_name_;
    ::google::protobuf::internal::ArenaStringPtr audio_track_id_;
    ::google::protobuf::internal::ArenaStringPtr video_track_id_;
    union OutputUnion {
      constexpr OutputUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE file_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE stream_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE segments_;
    } output_;
    union OptionsUnion {
      constexpr OptionsUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      int preset_;
      ::livekit::EncodingOptions* PROTOBUF_NULLABLE advanced_;
    } options_;
    ::uint32_t _oneof_case_[2];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TrackCompositeEgressRequest_class_data_;
// -------------------------------------------------------------------

class RoomCompositeEgressRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.RoomCompositeEgressRequest) */ {
 public:
  inline RoomCompositeEgressRequest() : RoomCompositeEgressRequest(nullptr) {}
  ~RoomCompositeEgressRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RoomCompositeEgressRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RoomCompositeEgressRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RoomCompositeEgressRequest(::google::protobuf::internal::ConstantInitialized);

  inline RoomCompositeEgressRequest(const RoomCompositeEgressRequest& from) : RoomCompositeEgressRequest(nullptr, from) {}
  inline RoomCompositeEgressRequest(RoomCompositeEgressRequest&& from) noexcept
      : RoomCompositeEgressRequest(nullptr, std::move(from)) {}
  inline RoomCompositeEgressRequest& operator=(const RoomCompositeEgressRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomCompositeEgressRequest& operator=(RoomCompositeEgressRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomCompositeEgressRequest& default_instance() {
    return *reinterpret_cast<const RoomCompositeEgressRequest*>(
        &_RoomCompositeEgressRequest_default_instance_);
  }
  enum OutputCase {
    kFile = 6,
    kStream = 7,
    kSegments = 10,
    OUTPUT_NOT_SET = 0,
  };
  enum OptionsCase {
    kPreset = 8,
    kAdvanced = 9,
    OPTIONS_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(RoomCompositeEgressRequest& a, RoomCompositeEgressRequest& b) { a.Swap(&b); }
  inline void Swap(RoomCompositeEgressRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomCompositeEgressRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomCompositeEgressRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RoomCompositeEgressRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoomCompositeEgressRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RoomCompositeEgressRequest& from) { RoomCompositeEgressRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RoomCompositeEgressRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.RoomCompositeEgressRequest"; }

 protected:
  explicit RoomCompositeEgressRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RoomCompositeEgressRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RoomCompositeEgressRequest& from);
  RoomCompositeEgressRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RoomCompositeEgressRequest&& from) noexcept
      : RoomCompositeEgressRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFileOutputsFieldNumber = 11,
    kStreamOutputsFieldNumber = 12,
    kSegmentOutputsFieldNumber = 13,
    kImageOutputsFieldNumber = 14,
    kRoomNameFieldNumber = 1,
    kLayoutFieldNumber = 2,
    kCustomBaseUrlFieldNumber = 5,
    kAudioOnlyFieldNumber = 3,
    kVideoOnlyFieldNumber = 4,
    kAudioMixingFieldNumber = 15,
    kFileFieldNumber = 6,
    kStreamFieldNumber = 7,
    kSegmentsFieldNumber = 10,
    kPresetFieldNumber = 8,
    kAdvancedFieldNumber = 9,
  };
  // repeated .livekit.EncodedFileOutput file_outputs = 11;
  int file_outputs_size() const;
  private:
  int _internal_file_outputs_size() const;

  public:
  void clear_file_outputs() ;
  ::livekit::EncodedFileOutput* PROTOBUF_NONNULL mutable_file_outputs(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::EncodedFileOutput>* PROTOBUF_NONNULL mutable_file_outputs();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::EncodedFileOutput>& _internal_file_outputs() const;
  ::google::protobuf::RepeatedPtrField<::livekit::EncodedFileOutput>* PROTOBUF_NONNULL _internal_mutable_file_outputs();
  public:
  const ::livekit::EncodedFileOutput& file_outputs(int index) const;
  ::livekit::EncodedFileOutput* PROTOBUF_NONNULL add_file_outputs();
  const ::google::protobuf::RepeatedPtrField<::livekit::EncodedFileOutput>& file_outputs() const;
  // repeated .livekit.StreamOutput stream_outputs = 12;
  int stream_outputs_size() const;
  private:
  int _internal_stream_outputs_size() const;

  public:
  void clear_stream_outputs() ;
  ::livekit::StreamOutput* PROTOBUF_NONNULL mutable_stream_outputs(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::StreamOutput>* PROTOBUF_NONNULL mutable_stream_outputs();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::StreamOutput>& _internal_stream_outputs() const;
  ::google::protobuf::RepeatedPtrField<::livekit::StreamOutput>* PROTOBUF_NONNULL _internal_mutable_stream_outputs();
  public:
  const ::livekit::StreamOutput& stream_outputs(int index) const;
  ::livekit::StreamOutput* PROTOBUF_NONNULL add_stream_outputs();
  const ::google::protobuf::RepeatedPtrField<::livekit::StreamOutput>& stream_outputs() const;
  // repeated .livekit.SegmentedFileOutput segment_outputs = 13;
  int segment_outputs_size() const;
  private:
  int _internal_segment_outputs_size() const;

  public:
  void clear_segment_outputs() ;
  ::livekit::SegmentedFileOutput* PROTOBUF_NONNULL mutable_segment_outputs(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::SegmentedFileOutput>* PROTOBUF_NONNULL mutable_segment_outputs();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::SegmentedFileOutput>& _internal_segment_outputs() const;
  ::google::protobuf::RepeatedPtrField<::livekit::SegmentedFileOutput>* PROTOBUF_NONNULL _internal_mutable_segment_outputs();
  public:
  const ::livekit::SegmentedFileOutput& segment_outputs(int index) const;
  ::livekit::SegmentedFileOutput* PROTOBUF_NONNULL add_segment_outputs();
  const ::google::protobuf::RepeatedPtrField<::livekit::SegmentedFileOutput>& segment_outputs() const;
  // repeated .livekit.ImageOutput image_outputs = 14;
  int image_outputs_size() const;
  private:
  int _internal_image_outputs_size() const;

  public:
  void clear_image_outputs() ;
  ::livekit::ImageOutput* PROTOBUF_NONNULL mutable_image_outputs(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::ImageOutput>* PROTOBUF_NONNULL mutable_image_outputs();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::ImageOutput>& _internal_image_outputs() const;
  ::google::protobuf::RepeatedPtrField<::livekit::ImageOutput>* PROTOBUF_NONNULL _internal_mutable_image_outputs();
  public:
  const ::livekit::ImageOutput& image_outputs(int index) const;
  ::livekit::ImageOutput* PROTOBUF_NONNULL add_image_outputs();
  const ::google::protobuf::RepeatedPtrField<::livekit::ImageOutput>& image_outputs() const;
  // string room_name = 1;
  void clear_room_name() ;
  const std::string& room_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_room_name(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_room_name();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_room_name();
  void set_allocated_room_name(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_room_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_room_name(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_room_name();

  public:
  // string layout = 2;
  void clear_layout() ;
  const std::string& layout() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_layout(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_layout();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_layout();
  void set_allocated_layout(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_layout() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_layout(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_layout();

  public:
  // string custom_base_url = 5;
  void clear_custom_base_url() ;
  const std::string& custom_base_url() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_custom_base_url(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_custom_base_url();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_custom_base_url();
  void set_allocated_custom_base_url(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_custom_base_url() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_custom_base_url(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_custom_base_url();

  public:
  // bool audio_only = 3;
  void clear_audio_only() ;
  bool audio_only() const;
  void set_audio_only(bool value);

  private:
  bool _internal_audio_only() const;
  void _internal_set_audio_only(bool value);

  public:
  // bool video_only = 4;
  void clear_video_only() ;
  bool video_only() const;
  void set_video_only(bool value);

  private:
  bool _internal_video_only() const;
  void _internal_set_video_only(bool value);

  public:
  // .livekit.AudioMixing audio_mixing = 15;
  void clear_audio_mixing() ;
  ::livekit::AudioMixing audio_mixing() const;
  void set_audio_mixing(::livekit::AudioMixing value);

  private:
  ::livekit::AudioMixing _internal_audio_mixing() const;
  void _internal_set_audio_mixing(::livekit::AudioMixing value);

  public:
  // .livekit.EncodedFileOutput file = 6 [deprecated = true];
  [[deprecated]]  bool has_file() const;
  private:
  bool _internal_has_file() const;

  public:
  [[deprecated]]  void clear_file() ;
  [[deprecated]] const ::livekit::EncodedFileOutput& file() const;
  [[deprecated]] [[nodiscard]] ::livekit::EncodedFileOutput* PROTOBUF_NULLABLE release_file();
  [[deprecated]] ::livekit::EncodedFileOutput* PROTOBUF_NONNULL mutable_file();
  [[deprecated]] void set_allocated_file(::livekit::EncodedFileOutput* PROTOBUF_NULLABLE value);
  [[deprecated]] void unsafe_arena_set_allocated_file(::livekit::EncodedFileOutput* PROTOBUF_NULLABLE value);
  [[deprecated]] ::livekit::EncodedFileOutput* PROTOBUF_NULLABLE unsafe_arena_release_file();

  private:
  const ::livekit::EncodedFileOutput& _internal_file() const;
  ::livekit::EncodedFileOutput* PROTOBUF_NONNULL _internal_mutable_file();

  public:
  // .livekit.StreamOutput stream = 7 [deprecated = true];
  [[deprecated]]  bool has_stream() const;
  private:
  bool _internal_has_stream() const;

  public:
  [[deprecated]]  void clear_stream() ;
  [[deprecated]] const ::livekit::StreamOutput& stream() const;
  [[deprecated]] [[nodiscard]] ::livekit::StreamOutput* PROTOBUF_NULLABLE release_stream();
  [[deprecated]] ::livekit::StreamOutput* PROTOBUF_NONNULL mutable_stream();
  [[deprecated]] void set_allocated_stream(::livekit::StreamOutput* PROTOBUF_NULLABLE value);
  [[deprecated]] void unsafe_arena_set_allocated_stream(::livekit::StreamOutput* PROTOBUF_NULLABLE value);
  [[deprecated]] ::livekit::StreamOutput* PROTOBUF_NULLABLE unsafe_arena_release_stream();

  private:
  const ::livekit::StreamOutput& _internal_stream() const;
  ::livekit::StreamOutput* PROTOBUF_NONNULL _internal_mutable_stream();

  public:
  // .livekit.SegmentedFileOutput segments = 10 [deprecated = true];
  [[deprecated]]  bool has_segments() const;
  private:
  bool _internal_has_segments() const;

  public:
  [[deprecated]]  void clear_segments() ;
  [[deprecated]] const ::livekit::SegmentedFileOutput& segments() const;
  [[deprecated]] [[nodiscard]] ::livekit::SegmentedFileOutput* PROTOBUF_NULLABLE release_segments();
  [[deprecated]] ::livekit::SegmentedFileOutput* PROTOBUF_NONNULL mutable_segments();
  [[deprecated]] void set_allocated_segments(::livekit::SegmentedFileOutput* PROTOBUF_NULLABLE value);
  [[deprecated]] void unsafe_arena_set_allocated_segments(::livekit::SegmentedFileOutput* PROTOBUF_NULLABLE value);
  [[deprecated]] ::livekit::SegmentedFileOutput* PROTOBUF_NULLABLE unsafe_arena_release_segments();

  private:
  const ::livekit::SegmentedFileOutput& _internal_segments() const;
  ::livekit::SegmentedFileOutput* PROTOBUF_NONNULL _internal_mutable_segments();

  public:
  // .livekit.EncodingOptionsPreset preset = 8;
  bool has_preset() const;
  void clear_preset() ;
  ::livekit::EncodingOptionsPreset preset() const;
  void set_preset(::livekit::EncodingOptionsPreset value);

  private:
  ::livekit::EncodingOptionsPreset _internal_preset() const;
  void _internal_set_preset(::livekit::EncodingOptionsPreset value);

  public:
  // .livekit.EncodingOptions advanced = 9;
  bool has_advanced() const;
  private:
  bool _internal_has_advanced() const;

  public:
  void clear_advanced() ;
  const ::livekit::EncodingOptions& advanced() const;
  [[nodiscard]] ::livekit::EncodingOptions* PROTOBUF_NULLABLE release_advanced();
  ::livekit::EncodingOptions* PROTOBUF_NONNULL mutable_advanced();
  void set_allocated_advanced(::livekit::EncodingOptions* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_advanced(::livekit::EncodingOptions* PROTOBUF_NULLABLE value);
  ::livekit::EncodingOptions* PROTOBUF_NULLABLE unsafe_arena_release_advanced();

  private:
  const ::livekit::EncodingOptions& _internal_advanced() const;
  ::livekit::EncodingOptions* PROTOBUF_NONNULL _internal_mutable_advanced();

  public:
  void clear_output();
  OutputCase output_case() const;
  void clear_options();
  OptionsCase options_case() const;
  // @@protoc_insertion_point(class_scope:livekit.RoomCompositeEgressRequest)
 private:
  class _Internal;
  void set_has_file();
  void set_has_stream();
  void set_has_segments();
  void set_has_preset();
  void set_has_advanced();
  inline bool has_output() const;
  inline void clear_has_output();
  inline bool has_options() const;
  inline void clear_has_options();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 15,
                                   8, 81,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RoomCompositeEgressRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::livekit::EncodedFileOutput > file_outputs_;
    ::google::protobuf::RepeatedPtrField< ::livekit::StreamOutput > stream_outputs_;
    ::google::protobuf::RepeatedPtrField< ::livekit::SegmentedFileOutput > segment_outputs_;
    ::google::protobuf::RepeatedPtrField< ::livekit::ImageOutput > image_outputs_;
    ::google::protobuf::internal::ArenaStringPtr room_name_;
    ::google::protobuf::internal::ArenaStringPtr layout_;
    ::google::protobuf::internal::ArenaStringPtr custom_base_url_;
    bool audio_only_;
    bool video_only_;
    int audio_mixing_;
    union OutputUnion {
      constexpr OutputUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE file_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE stream_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE segments_;
    } output_;
    union OptionsUnion {
      constexpr OptionsUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      int preset_;
      ::livekit::EncodingOptions* PROTOBUF_NULLABLE advanced_;
    } options_;
    ::uint32_t _oneof_case_[2];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RoomCompositeEgressRequest_class_data_;
// -------------------------------------------------------------------

class ParticipantEgressRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.ParticipantEgressRequest) */ {
 public:
  inline ParticipantEgressRequest() : ParticipantEgressRequest(nullptr) {}
  ~ParticipantEgressRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ParticipantEgressRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ParticipantEgressRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ParticipantEgressRequest(::google::protobuf::internal::ConstantInitialized);

  inline ParticipantEgressRequest(const ParticipantEgressRequest& from) : ParticipantEgressRequest(nullptr, from) {}
  inline ParticipantEgressRequest(ParticipantEgressRequest&& from) noexcept
      : ParticipantEgressRequest(nullptr, std::move(from)) {}
  inline ParticipantEgressRequest& operator=(const ParticipantEgressRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParticipantEgressRequest& operator=(ParticipantEgressRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ParticipantEgressRequest& default_instance() {
    return *reinterpret_cast<const ParticipantEgressRequest*>(
        &_ParticipantEgressRequest_default_instance_);
  }
  enum OptionsCase {
    kPreset = 4,
    kAdvanced = 5,
    OPTIONS_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(ParticipantEgressRequest& a, ParticipantEgressRequest& b) { a.Swap(&b); }
  inline void Swap(ParticipantEgressRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParticipantEgressRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ParticipantEgressRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ParticipantEgressRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ParticipantEgressRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ParticipantEgressRequest& from) { ParticipantEgressRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ParticipantEgressRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.ParticipantEgressRequest"; }

 protected:
  explicit ParticipantEgressRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ParticipantEgressRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ParticipantEgressRequest& from);
  ParticipantEgressRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ParticipantEgressRequest&& from) noexcept
      : ParticipantEgressRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFileOutputsFieldNumber = 6,
    kStreamOutputsFieldNumber = 7,
    kSegmentOutputsFieldNumber = 8,
    kImageOutputsFieldNumber = 9,
    kRoomNameFieldNumber = 1,
    kIdentityFieldNumber = 2,
    kScreenShareFieldNumber = 3,
    kPresetFieldNumber = 4,
    kAdvancedFieldNumber = 5,
  };
  // repeated .livekit.EncodedFileOutput file_outputs = 6;
  int file_outputs_size() const;
  private:
  int _internal_file_outputs_size() const;

  public:
  void clear_file_outputs() ;
  ::livekit::EncodedFileOutput* PROTOBUF_NONNULL mutable_file_outputs(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::EncodedFileOutput>* PROTOBUF_NONNULL mutable_file_outputs();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::EncodedFileOutput>& _internal_file_outputs() const;
  ::google::protobuf::RepeatedPtrField<::livekit::EncodedFileOutput>* PROTOBUF_NONNULL _internal_mutable_file_outputs();
  public:
  const ::livekit::EncodedFileOutput& file_outputs(int index) const;
  ::livekit::EncodedFileOutput* PROTOBUF_NONNULL add_file_outputs();
  const ::google::protobuf::RepeatedPtrField<::livekit::EncodedFileOutput>& file_outputs() const;
  // repeated .livekit.StreamOutput stream_outputs = 7;
  int stream_outputs_size() const;
  private:
  int _internal_stream_outputs_size() const;

  public:
  void clear_stream_outputs() ;
  ::livekit::StreamOutput* PROTOBUF_NONNULL mutable_stream_outputs(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::StreamOutput>* PROTOBUF_NONNULL mutable_stream_outputs();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::StreamOutput>& _internal_stream_outputs() const;
  ::google::protobuf::RepeatedPtrField<::livekit::StreamOutput>* PROTOBUF_NONNULL _internal_mutable_stream_outputs();
  public:
  const ::livekit::StreamOutput& stream_outputs(int index) const;
  ::livekit::StreamOutput* PROTOBUF_NONNULL add_stream_outputs();
  const ::google::protobuf::RepeatedPtrField<::livekit::StreamOutput>& stream_outputs() const;
  // repeated .livekit.SegmentedFileOutput segment_outputs = 8;
  int segment_outputs_size() const;
  private:
  int _internal_segment_outputs_size() const;

  public:
  void clear_segment_outputs() ;
  ::livekit::SegmentedFileOutput* PROTOBUF_NONNULL mutable_segment_outputs(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::SegmentedFileOutput>* PROTOBUF_NONNULL mutable_segment_outputs();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::SegmentedFileOutput>& _internal_segment_outputs() const;
  ::google::protobuf::RepeatedPtrField<::livekit::SegmentedFileOutput>* PROTOBUF_NONNULL _internal_mutable_segment_outputs();
  public:
  const ::livekit::SegmentedFileOutput& segment_outputs(int index) const;
  ::livekit::SegmentedFileOutput* PROTOBUF_NONNULL add_segment_outputs();
  const ::google::protobuf::RepeatedPtrField<::livekit::SegmentedFileOutput>& segment_outputs() const;
  // repeated .livekit.ImageOutput image_outputs = 9;
  int image_outputs_size() const;
  private:
  int _internal_image_outputs_size() const;

  public:
  void clear_image_outputs() ;
  ::livekit::ImageOutput* PROTOBUF_NONNULL mutable_image_outputs(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::ImageOutput>* PROTOBUF_NONNULL mutable_image_outputs();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::ImageOutput>& _internal_image_outputs() const;
  ::google::protobuf::RepeatedPtrField<::livekit::ImageOutput>* PROTOBUF_NONNULL _internal_mutable_image_outputs();
  public:
  const ::livekit::ImageOutput& image_outputs(int index) const;
  ::livekit::ImageOutput* PROTOBUF_NONNULL add_image_outputs();
  const ::google::protobuf::RepeatedPtrField<::livekit::ImageOutput>& image_outputs() const;
  // string room_name = 1;
  void clear_room_name() ;
  const std::string& room_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_room_name(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_room_name();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_room_name();
  void set_allocated_room_name(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_room_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_room_name(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_room_name();

  public:
  // string identity = 2;
  void clear_identity() ;
  const std::string& identity() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_identity(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_identity();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_identity();
  void set_allocated_identity(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_identity() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_identity(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_identity();

  public:
  // bool screen_share = 3;
  void clear_screen_share() ;
  bool screen_share() const;
  void set_screen_share(bool value);

  private:
  bool _internal_screen_share() const;
  void _internal_set_screen_share(bool value);

  public:
  // .livekit.EncodingOptionsPreset preset = 4;
  bool has_preset() const;
  void clear_preset() ;
  ::livekit::EncodingOptionsPreset preset() const;
  void set_preset(::livekit::EncodingOptionsPreset value);

  private:
  ::livekit::EncodingOptionsPreset _internal_preset() const;
  void _internal_set_preset(::livekit::EncodingOptionsPreset value);

  public:
  // .livekit.EncodingOptions advanced = 5;
  bool has_advanced() const;
  private:
  bool _internal_has_advanced() const;

  public:
  void clear_advanced() ;
  const ::livekit::EncodingOptions& advanced() const;
  [[nodiscard]] ::livekit::EncodingOptions* PROTOBUF_NULLABLE release_advanced();
  ::livekit::EncodingOptions* PROTOBUF_NONNULL mutable_advanced();
  void set_allocated_advanced(::livekit::EncodingOptions* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_advanced(::livekit::EncodingOptions* PROTOBUF_NULLABLE value);
  ::livekit::EncodingOptions* PROTOBUF_NULLABLE unsafe_arena_release_advanced();

  private:
  const ::livekit::EncodingOptions& _internal_advanced() const;
  ::livekit::EncodingOptions* PROTOBUF_NONNULL _internal_mutable_advanced();

  public:
  void clear_options();
  OptionsCase options_case() const;
  // @@protoc_insertion_point(class_scope:livekit.ParticipantEgressRequest)
 private:
  class _Internal;
  void set_has_preset();
  void set_has_advanced();
  inline bool has_options() const;
  inline void clear_has_options();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 9,
                                   5, 66,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ParticipantEgressRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::livekit::EncodedFileOutput > file_outputs_;
    ::google::protobuf::RepeatedPtrField< ::livekit::StreamOutput > stream_outputs_;
    ::google::protobuf::RepeatedPtrField< ::livekit::SegmentedFileOutput > segment_outputs_;
    ::google::protobuf::RepeatedPtrField< ::livekit::ImageOutput > image_outputs_;
    ::google::protobuf::internal::ArenaStringPtr room_name_;
    ::google::protobuf::internal::ArenaStringPtr identity_;
    bool screen_share_;
    union OptionsUnion {
      constexpr OptionsUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      int preset_;
      ::livekit::EncodingOptions* PROTOBUF_NULLABLE advanced_;
    } options_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ParticipantEgressRequest_class_data_;
// -------------------------------------------------------------------

class AutoParticipantEgress final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.AutoParticipantEgress) */ {
 public:
  inline AutoParticipantEgress() : AutoParticipantEgress(nullptr) {}
  ~AutoParticipantEgress() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AutoParticipantEgress* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AutoParticipantEgress));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AutoParticipantEgress(::google::protobuf::internal::ConstantInitialized);

  inline AutoParticipantEgress(const AutoParticipantEgress& from) : AutoParticipantEgress(nullptr, from) {}
  inline AutoParticipantEgress(AutoParticipantEgress&& from) noexcept
      : AutoParticipantEgress(nullptr, std::move(from)) {}
  inline AutoParticipantEgress& operator=(const AutoParticipantEgress& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutoParticipantEgress& operator=(AutoParticipantEgress&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AutoParticipantEgress& default_instance() {
    return *reinterpret_cast<const AutoParticipantEgress*>(
        &_AutoParticipantEgress_default_instance_);
  }
  enum OptionsCase {
    kPreset = 1,
    kAdvanced = 2,
    OPTIONS_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 28;
  friend void swap(AutoParticipantEgress& a, AutoParticipantEgress& b) { a.Swap(&b); }
  inline void Swap(AutoParticipantEgress* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutoParticipantEgress* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutoParticipantEgress* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AutoParticipantEgress>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AutoParticipantEgress& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AutoParticipantEgress& from) { AutoParticipantEgress::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AutoParticipantEgress* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.AutoParticipantEgress"; }

 protected:
  explicit AutoParticipantEgress(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  AutoParticipantEgress(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const AutoParticipantEgress& from);
  AutoParticipantEgress(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, AutoParticipantEgress&& from) noexcept
      : AutoParticipantEgress(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFileOutputsFieldNumber = 3,
    kSegmentOutputsFieldNumber = 4,
    kPresetFieldNumber = 1,
    kAdvancedFieldNumber = 2,
  };
  // repeated .livekit.EncodedFileOutput file_outputs = 3;
  int file_outputs_size() const;
  private:
  int _internal_file_outputs_size() const;

  public:
  void clear_file_outputs() ;
  ::livekit::EncodedFileOutput* PROTOBUF_NONNULL mutable_file_outputs(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::EncodedFileOutput>* PROTOBUF_NONNULL mutable_file_outputs();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::EncodedFileOutput>& _internal_file_outputs() const;
  ::google::protobuf::RepeatedPtrField<::livekit::EncodedFileOutput>* PROTOBUF_NONNULL _internal_mutable_file_outputs();
  public:
  const ::livekit::EncodedFileOutput& file_outputs(int index) const;
  ::livekit::EncodedFileOutput* PROTOBUF_NONNULL add_file_outputs();
  const ::google::protobuf::RepeatedPtrField<::livekit::EncodedFileOutput>& file_outputs() const;
  // repeated .livekit.SegmentedFileOutput segment_outputs = 4;
  int segment_outputs_size() const;
  private:
  int _internal_segment_outputs_size() const;

  public:
  void clear_segment_outputs() ;
  ::livekit::SegmentedFileOutput* PROTOBUF_NONNULL mutable_segment_outputs(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::SegmentedFileOutput>* PROTOBUF_NONNULL mutable_segment_outputs();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::SegmentedFileOutput>& _internal_segment_outputs() const;
  ::google::protobuf::RepeatedPtrField<::livekit::SegmentedFileOutput>* PROTOBUF_NONNULL _internal_mutable_segment_outputs();
  public:
  const ::livekit::SegmentedFileOutput& segment_outputs(int index) const;
  ::livekit::SegmentedFileOutput* PROTOBUF_NONNULL add_segment_outputs();
  const ::google::protobuf::RepeatedPtrField<::livekit::SegmentedFileOutput>& segment_outputs() const;
  // .livekit.EncodingOptionsPreset preset = 1;
  bool has_preset() const;
  void clear_preset() ;
  ::livekit::EncodingOptionsPreset preset() const;
  void set_preset(::livekit::EncodingOptionsPreset value);

  private:
  ::livekit::EncodingOptionsPreset _internal_preset() const;
  void _internal_set_preset(::livekit::EncodingOptionsPreset value);

  public:
  // .livekit.EncodingOptions advanced = 2;
  bool has_advanced() const;
  private:
  bool _internal_has_advanced() const;

  public:
  void clear_advanced() ;
  const ::livekit::EncodingOptions& advanced() const;
  [[nodiscard]] ::livekit::EncodingOptions* PROTOBUF_NULLABLE release_advanced();
  ::livekit::EncodingOptions* PROTOBUF_NONNULL mutable_advanced();
  void set_allocated_advanced(::livekit::EncodingOptions* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_advanced(::livekit::EncodingOptions* PROTOBUF_NULLABLE value);
  ::livekit::EncodingOptions* PROTOBUF_NULLABLE unsafe_arena_release_advanced();

  private:
  const ::livekit::EncodingOptions& _internal_advanced() const;
  ::livekit::EncodingOptions* PROTOBUF_NONNULL _internal_mutable_advanced();

  public:
  void clear_options();
  OptionsCase options_case() const;
  // @@protoc_insertion_point(class_scope:livekit.AutoParticipantEgress)
 private:
  class _Internal;
  void set_has_preset();
  void set_has_advanced();
  inline bool has_options() const;
  inline void clear_has_options();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 4,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const AutoParticipantEgress& from_msg);
    ::google::protobuf::RepeatedPtrField< ::livekit::EncodedFileOutput > file_outputs_;
    ::google::protobuf::RepeatedPtrField< ::livekit::SegmentedFileOutput > segment_outputs_;
    union OptionsUnion {
      constexpr OptionsUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      int preset_;
      ::livekit::EncodingOptions* PROTOBUF_NULLABLE advanced_;
    } options_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull AutoParticipantEgress_class_data_;
// -------------------------------------------------------------------

class EgressInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.EgressInfo) */ {
 public:
  inline EgressInfo() : EgressInfo(nullptr) {}
  ~EgressInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EgressInfo* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EgressInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EgressInfo(::google::protobuf::internal::ConstantInitialized);

  inline EgressInfo(const EgressInfo& from) : EgressInfo(nullptr, from) {}
  inline EgressInfo(EgressInfo&& from) noexcept
      : EgressInfo(nullptr, std::move(from)) {}
  inline EgressInfo& operator=(const EgressInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgressInfo& operator=(EgressInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgressInfo& default_instance() {
    return *reinterpret_cast<const EgressInfo*>(
        &_EgressInfo_default_instance_);
  }
  enum RequestCase {
    kRoomComposite = 4,
    kWeb = 14,
    kParticipant = 19,
    kTrackComposite = 5,
    kTrack = 6,
    REQUEST_NOT_SET = 0,
  };
  enum ResultCase {
    kStream = 7,
    kFile = 8,
    kSegments = 12,
    RESULT_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(EgressInfo& a, EgressInfo& b) { a.Swap(&b); }
  inline void Swap(EgressInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgressInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgressInfo* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EgressInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EgressInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EgressInfo& from) { EgressInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EgressInfo* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.EgressInfo"; }

 protected:
  explicit EgressInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EgressInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EgressInfo& from);
  EgressInfo(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EgressInfo&& from) noexcept
      : EgressInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStreamResultsFieldNumber = 15,
    kFileResultsFieldNumber = 16,
    kSegmentResultsFieldNumber = 17,
    kImageResultsFieldNumber = 20,
    kEgressIdFieldNumber = 1,
    kRoomIdFieldNumber = 2,
    kErrorFieldNumber = 9,
    kRoomNameFieldNumber = 13,
    kDetailsFieldNumber = 21,
    kManifestLocationFieldNumber = 23,
    kStartedAtFieldNumber = 10,
    kEndedAtFieldNumber = 11,
    kStatusFieldNumber = 3,
    kErrorCodeFieldNumber = 22,
    kUpdatedAtFieldNumber = 18,
    kBackupStorageUsedFieldNumber = 25,
    kSourceTypeFieldNumber = 26,
    kRoomCompositeFieldNumber = 4,
    kWebFieldNumber = 14,
    kParticipantFieldNumber = 19,
    kTrackCompositeFieldNumber = 5,
    kTrackFieldNumber = 6,
    kStreamFieldNumber = 7,
    kFileFieldNumber = 8,
    kSegmentsFieldNumber = 12,
  };
  // repeated .livekit.StreamInfo stream_results = 15;
  int stream_results_size() const;
  private:
  int _internal_stream_results_size() const;

  public:
  void clear_stream_results() ;
  ::livekit::StreamInfo* PROTOBUF_NONNULL mutable_stream_results(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::StreamInfo>* PROTOBUF_NONNULL mutable_stream_results();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::StreamInfo>& _internal_stream_results() const;
  ::google::protobuf::RepeatedPtrField<::livekit::StreamInfo>* PROTOBUF_NONNULL _internal_mutable_stream_results();
  public:
  const ::livekit::StreamInfo& stream_results(int index) const;
  ::livekit::StreamInfo* PROTOBUF_NONNULL add_stream_results();
  const ::google::protobuf::RepeatedPtrField<::livekit::StreamInfo>& stream_results() const;
  // repeated .livekit.FileInfo file_results = 16;
  int file_results_size() const;
  private:
  int _internal_file_results_size() const;

  public:
  void clear_file_results() ;
  ::livekit::FileInfo* PROTOBUF_NONNULL mutable_file_results(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::FileInfo>* PROTOBUF_NONNULL mutable_file_results();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::FileInfo>& _internal_file_results() const;
  ::google::protobuf::RepeatedPtrField<::livekit::FileInfo>* PROTOBUF_NONNULL _internal_mutable_file_results();
  public:
  const ::livekit::FileInfo& file_results(int index) const;
  ::livekit::FileInfo* PROTOBUF_NONNULL add_file_results();
  const ::google::protobuf::RepeatedPtrField<::livekit::FileInfo>& file_results() const;
  // repeated .livekit.SegmentsInfo segment_results = 17;
  int segment_results_size() const;
  private:
  int _internal_segment_results_size() const;

  public:
  void clear_segment_results() ;
  ::livekit::SegmentsInfo* PROTOBUF_NONNULL mutable_segment_results(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::SegmentsInfo>* PROTOBUF_NONNULL mutable_segment_results();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::SegmentsInfo>& _internal_segment_results() const;
  ::google::protobuf::RepeatedPtrField<::livekit::SegmentsInfo>* PROTOBUF_NONNULL _internal_mutable_segment_results();
  public:
  const ::livekit::SegmentsInfo& segment_results(int index) const;
  ::livekit::SegmentsInfo* PROTOBUF_NONNULL add_segment_results();
  const ::google::protobuf::RepeatedPtrField<::livekit::SegmentsInfo>& segment_results() const;
  // repeated .livekit.ImagesInfo image_results = 20;
  int image_results_size() const;
  private:
  int _internal_image_results_size() const;

  public:
  void clear_image_results() ;
  ::livekit::ImagesInfo* PROTOBUF_NONNULL mutable_image_results(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::ImagesInfo>* PROTOBUF_NONNULL mutable_image_results();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::ImagesInfo>& _internal_image_results() const;
  ::google::protobuf::RepeatedPtrField<::livekit::ImagesInfo>* PROTOBUF_NONNULL _internal_mutable_image_results();
  public:
  const ::livekit::ImagesInfo& image_results(int index) const;
  ::livekit::ImagesInfo* PROTOBUF_NONNULL add_image_results();
  const ::google::protobuf::RepeatedPtrField<::livekit::ImagesInfo>& image_results() const;
  // string egress_id = 1;
  void clear_egress_id() ;
  const std::string& egress_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_egress_id(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_egress_id();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_egress_id();
  void set_allocated_egress_id(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_egress_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_egress_id(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_egress_id();

  public:
  // string room_id = 2;
  void clear_room_id() ;
  const std::string& room_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_room_id(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_room_id();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_room_id();
  void set_allocated_room_id(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_room_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_room_id(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_room_id();

  public:
  // string error = 9;
  void clear_error() ;
  const std::string& error() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_error();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_error();
  void set_allocated_error(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_error() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_error();

  public:
  // string room_name = 13;
  void clear_room_name() ;
  const std::string& room_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_room_name(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_room_name();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_room_name();
  void set_allocated_room_name(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_room_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_room_name(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_room_name();

  public:
  // string details = 21;
  void clear_details() ;
  const std::string& details() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_details(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_details();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_details();
  void set_allocated_details(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_details() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_details(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_details();

  public:
  // string manifest_location = 23;
  void clear_manifest_location() ;
  const std::string& manifest_location() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_manifest_location(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_manifest_location();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_manifest_location();
  void set_allocated_manifest_location(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_manifest_location() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_manifest_location(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_manifest_location();

  public:
  // int64 started_at = 10;
  void clear_started_at() ;
  ::int64_t started_at() const;
  void set_started_at(::int64_t value);

  private:
  ::int64_t _internal_started_at() const;
  void _internal_set_started_at(::int64_t value);

  public:
  // int64 ended_at = 11;
  void clear_ended_at() ;
  ::int64_t ended_at() const;
  void set_ended_at(::int64_t value);

  private:
  ::int64_t _internal_ended_at() const;
  void _internal_set_ended_at(::int64_t value);

  public:
  // .livekit.EgressStatus status = 3;
  void clear_status() ;
  ::livekit::EgressStatus status() const;
  void set_status(::livekit::EgressStatus value);

  private:
  ::livekit::EgressStatus _internal_status() const;
  void _internal_set_status(::livekit::EgressStatus value);

  public:
  // int32 error_code = 22;
  void clear_error_code() ;
  ::int32_t error_code() const;
  void set_error_code(::int32_t value);

  private:
  ::int32_t _internal_error_code() const;
  void _internal_set_error_code(::int32_t value);

  public:
  // int64 updated_at = 18;
  void clear_updated_at() ;
  ::int64_t updated_at() const;
  void set_updated_at(::int64_t value);

  private:
  ::int64_t _internal_updated_at() const;
  void _internal_set_updated_at(::int64_t value);

  public:
  // bool backup_storage_used = 25;
  void clear_backup_storage_used() ;
  bool backup_storage_used() const;
  void set_backup_storage_used(bool value);

  private:
  bool _internal_backup_storage_used() const;
  void _internal_set_backup_storage_used(bool value);

  public:
  // .livekit.EgressSourceType source_type = 26;
  void clear_source_type() ;
  ::livekit::EgressSourceType source_type() const;
  void set_source_type(::livekit::EgressSourceType value);

  private:
  ::livekit::EgressSourceType _internal_source_type() const;
  void _internal_set_source_type(::livekit::EgressSourceType value);

  public:
  // .livekit.RoomCompositeEgressRequest room_composite = 4;
  bool has_room_composite() const;
  private:
  bool _internal_has_room_composite() const;

  public:
  void clear_room_composite() ;
  const ::livekit::RoomCompositeEgressRequest& room_composite() const;
  [[nodiscard]] ::livekit::RoomCompositeEgressRequest* PROTOBUF_NULLABLE release_room_composite();
  ::livekit::RoomCompositeEgressRequest* PROTOBUF_NONNULL mutable_room_composite();
  void set_allocated_room_composite(::livekit::RoomCompositeEgressRequest* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_room_composite(::livekit::RoomCompositeEgressRequest* PROTOBUF_NULLABLE value);
  ::livekit::RoomCompositeEgressRequest* PROTOBUF_NULLABLE unsafe_arena_release_room_composite();

  private:
  const ::livekit::RoomCompositeEgressRequest& _internal_room_composite() const;
  ::livekit::RoomCompositeEgressRequest* PROTOBUF_NONNULL _internal_mutable_room_composite();

  public:
  // .livekit.WebEgressRequest web = 14;
  bool has_web() const;
  private:
  bool _internal_has_web() const;

  public:
  void clear_web() ;
  const ::livekit::WebEgressRequest& web() const;
  [[nodiscard]] ::livekit::WebEgressRequest* PROTOBUF_NULLABLE release_web();
  ::livekit::WebEgressRequest* PROTOBUF_NONNULL mutable_web();
  void set_allocated_web(::livekit::WebEgressRequest* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_web(::livekit::WebEgressRequest* PROTOBUF_NULLABLE value);
  ::livekit::WebEgressRequest* PROTOBUF_NULLABLE unsafe_arena_release_web();

  private:
  const ::livekit::WebEgressRequest& _internal_web() const;
  ::livekit::WebEgressRequest* PROTOBUF_NONNULL _internal_mutable_web();

  public:
  // .livekit.ParticipantEgressRequest participant = 19;
  bool has_participant() const;
  private:
  bool _internal_has_participant() const;

  public:
  void clear_participant() ;
  const ::livekit::ParticipantEgressRequest& participant() const;
  [[nodiscard]] ::livekit::ParticipantEgressRequest* PROTOBUF_NULLABLE release_participant();
  ::livekit::ParticipantEgressRequest* PROTOBUF_NONNULL mutable_participant();
  void set_allocated_participant(::livekit::ParticipantEgressRequest* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_participant(::livekit::ParticipantEgressRequest* PROTOBUF_NULLABLE value);
  ::livekit::ParticipantEgressRequest* PROTOBUF_NULLABLE unsafe_arena_release_participant();

  private:
  const ::livekit::ParticipantEgressRequest& _internal_participant() const;
  ::livekit::ParticipantEgressRequest* PROTOBUF_NONNULL _internal_mutable_participant();

  public:
  // .livekit.TrackCompositeEgressRequest track_composite = 5;
  bool has_track_composite() const;
  private:
  bool _internal_has_track_composite() const;

  public:
  void clear_track_composite() ;
  const ::livekit::TrackCompositeEgressRequest& track_composite() const;
  [[nodiscard]] ::livekit::TrackCompositeEgressRequest* PROTOBUF_NULLABLE release_track_composite();
  ::livekit::TrackCompositeEgressRequest* PROTOBUF_NONNULL mutable_track_composite();
  void set_allocated_track_composite(::livekit::TrackCompositeEgressRequest* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_track_composite(::livekit::TrackCompositeEgressRequest* PROTOBUF_NULLABLE value);
  ::livekit::TrackCompositeEgressRequest* PROTOBUF_NULLABLE unsafe_arena_release_track_composite();

  private:
  const ::livekit::TrackCompositeEgressRequest& _internal_track_composite() const;
  ::livekit::TrackCompositeEgressRequest* PROTOBUF_NONNULL _internal_mutable_track_composite();

  public:
  // .livekit.TrackEgressRequest track = 6;
  bool has_track() const;
  private:
  bool _internal_has_track() const;

  public:
  void clear_track() ;
  const ::livekit::TrackEgressRequest& track() const;
  [[nodiscard]] ::livekit::TrackEgressRequest* PROTOBUF_NULLABLE release_track();
  ::livekit::TrackEgressRequest* PROTOBUF_NONNULL mutable_track();
  void set_allocated_track(::livekit::TrackEgressRequest* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_track(::livekit::TrackEgressRequest* PROTOBUF_NULLABLE value);
  ::livekit::TrackEgressRequest* PROTOBUF_NULLABLE unsafe_arena_release_track();

  private:
  const ::livekit::TrackEgressRequest& _internal_track() const;
  ::livekit::TrackEgressRequest* PROTOBUF_NONNULL _internal_mutable_track();

  public:
  // .livekit.StreamInfoList stream = 7 [deprecated = true];
  [[deprecated]]  bool has_stream() const;
  private:
  bool _internal_has_stream() const;

  public:
  [[deprecated]]  void clear_stream() ;
  [[deprecated]] const ::livekit::StreamInfoList& stream() const;
  [[deprecated]] [[nodiscard]] ::livekit::StreamInfoList* PROTOBUF_NULLABLE release_stream();
  [[deprecated]] ::livekit::StreamInfoList* PROTOBUF_NONNULL mutable_stream();
  [[deprecated]] void set_allocated_stream(::livekit::StreamInfoList* PROTOBUF_NULLABLE value);
  [[deprecated]] void unsafe_arena_set_allocated_stream(::livekit::StreamInfoList* PROTOBUF_NULLABLE value);
  [[deprecated]] ::livekit::StreamInfoList* PROTOBUF_NULLABLE unsafe_arena_release_stream();

  private:
  const ::livekit::StreamInfoList& _internal_stream() const;
  ::livekit::StreamInfoList* PROTOBUF_NONNULL _internal_mutable_stream();

  public:
  // .livekit.FileInfo file = 8 [deprecated = true];
  [[deprecated]]  bool has_file() const;
  private:
  bool _internal_has_file() const;

  public:
  [[deprecated]]  void clear_file() ;
  [[deprecated]] const ::livekit::FileInfo& file() const;
  [[deprecated]] [[nodiscard]] ::livekit::FileInfo* PROTOBUF_NULLABLE release_file();
  [[deprecated]] ::livekit::FileInfo* PROTOBUF_NONNULL mutable_file();
  [[deprecated]] void set_allocated_file(::livekit::FileInfo* PROTOBUF_NULLABLE value);
  [[deprecated]] void unsafe_arena_set_allocated_file(::livekit::FileInfo* PROTOBUF_NULLABLE value);
  [[deprecated]] ::livekit::FileInfo* PROTOBUF_NULLABLE unsafe_arena_release_file();

  private:
  const ::livekit::FileInfo& _internal_file() const;
  ::livekit::FileInfo* PROTOBUF_NONNULL _internal_mutable_file();

  public:
  // .livekit.SegmentsInfo segments = 12 [deprecated = true];
  [[deprecated]]  bool has_segments() const;
  private:
  bool _internal_has_segments() const;

  public:
  [[deprecated]]  void clear_segments() ;
  [[deprecated]] const ::livekit::SegmentsInfo& segments() const;
  [[deprecated]] [[nodiscard]] ::livekit::SegmentsInfo* PROTOBUF_NULLABLE release_segments();
  [[deprecated]] ::livekit::SegmentsInfo* PROTOBUF_NONNULL mutable_segments();
  [[deprecated]] void set_allocated_segments(::livekit::SegmentsInfo* PROTOBUF_NULLABLE value);
  [[deprecated]] void unsafe_arena_set_allocated_segments(::livekit::SegmentsInfo* PROTOBUF_NULLABLE value);
  [[deprecated]] ::livekit::SegmentsInfo* PROTOBUF_NULLABLE unsafe_arena_release_segments();

  private:
  const ::livekit::SegmentsInfo& _internal_segments() const;
  ::livekit::SegmentsInfo* PROTOBUF_NONNULL _internal_mutable_segments();

  public:
  void clear_request();
  RequestCase request_case() const;
  void clear_result();
  ResultCase result_case() const;
  // @@protoc_insertion_point(class_scope:livekit.EgressInfo)
 private:
  class _Internal;
  void set_has_room_composite();
  void set_has_web();
  void set_has_participant();
  void set_has_track_composite();
  void set_has_track();
  void set_has_stream();
  void set_has_file();
  void set_has_segments();
  inline bool has_request() const;
  inline void clear_has_request();
  inline bool has_result() const;
  inline void clear_has_result();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<5, 25,
                                   12, 105,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EgressInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::livekit::StreamInfo > stream_results_;
    ::google::protobuf::RepeatedPtrField< ::livekit::FileInfo > file_results_;
    ::google::protobuf::RepeatedPtrField< ::livekit::SegmentsInfo > segment_results_;
    ::google::protobuf::RepeatedPtrField< ::livekit::ImagesInfo > image_results_;
    ::google::protobuf::internal::ArenaStringPtr egress_id_;
    ::google::protobuf::internal::ArenaStringPtr room_id_;
    ::google::protobuf::internal::ArenaStringPtr error_;
    ::google::protobuf::internal::ArenaStringPtr room_name_;
    ::google::protobuf::internal::ArenaStringPtr details_;
    ::google::protobuf::internal::ArenaStringPtr manifest_location_;
    ::int64_t started_at_;
    ::int64_t ended_at_;
    int status_;
    ::int32_t error_code_;
    ::int64_t updated_at_;
    bool backup_storage_used_;
    int source_type_;
    union RequestUnion {
      constexpr RequestUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE room_composite_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE web_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE participant_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE track_composite_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE track_;
    } request_;
    union ResultUnion {
      constexpr ResultUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE stream_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE file_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE segments_;
    } result_;
    ::uint32_t _oneof_case_[2];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EgressInfo_class_data_;
// -------------------------------------------------------------------

class ListEgressResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.ListEgressResponse) */ {
 public:
  inline ListEgressResponse() : ListEgressResponse(nullptr) {}
  ~ListEgressResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ListEgressResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ListEgressResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListEgressResponse(::google::protobuf::internal::ConstantInitialized);

  inline ListEgressResponse(const ListEgressResponse& from) : ListEgressResponse(nullptr, from) {}
  inline ListEgressResponse(ListEgressResponse&& from) noexcept
      : ListEgressResponse(nullptr, std::move(from)) {}
  inline ListEgressResponse& operator=(const ListEgressResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListEgressResponse& operator=(ListEgressResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListEgressResponse& default_instance() {
    return *reinterpret_cast<const ListEgressResponse*>(
        &_ListEgressResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(ListEgressResponse& a, ListEgressResponse& b) { a.Swap(&b); }
  inline void Swap(ListEgressResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListEgressResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListEgressResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ListEgressResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListEgressResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListEgressResponse& from) { ListEgressResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ListEgressResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.ListEgressResponse"; }

 protected:
  explicit ListEgressResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ListEgressResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ListEgressResponse& from);
  ListEgressResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ListEgressResponse&& from) noexcept
      : ListEgressResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .livekit.EgressInfo items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::livekit::EgressInfo* PROTOBUF_NONNULL mutable_items(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::EgressInfo>* PROTOBUF_NONNULL mutable_items();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::EgressInfo>& _internal_items() const;
  ::google::protobuf::RepeatedPtrField<::livekit::EgressInfo>* PROTOBUF_NONNULL _internal_mutable_items();
  public:
  const ::livekit::EgressInfo& items(int index) const;
  ::livekit::EgressInfo* PROTOBUF_NONNULL add_items();
  const ::google::protobuf::RepeatedPtrField<::livekit::EgressInfo>& items() const;
  // @@protoc_insertion_point(class_scope:livekit.ListEgressResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ListEgressResponse& from_msg);
    ::google::protobuf::RepeatedPtrField< ::livekit::EgressInfo > items_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ListEgressResponse_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// RoomCompositeEgressRequest

// string room_name = 1;
inline void RoomCompositeEgressRequest::clear_room_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.room_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RoomCompositeEgressRequest::room_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.RoomCompositeEgressRequest.room_name)
  return _internal_room_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RoomCompositeEgressRequest::set_room_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.room_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.RoomCompositeEgressRequest.room_name)
}
inline std::string* PROTOBUF_NONNULL RoomCompositeEgressRequest::mutable_room_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_room_name();
  // @@protoc_insertion_point(field_mutable:livekit.RoomCompositeEgressRequest.room_name)
  return _s;
}
inline const std::string& RoomCompositeEgressRequest::_internal_room_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.room_name_.Get();
}
inline void RoomCompositeEgressRequest::_internal_set_room_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.room_name_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL RoomCompositeEgressRequest::_internal_mutable_room_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.room_name_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE RoomCompositeEgressRequest::release_room_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.RoomCompositeEgressRequest.room_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.room_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.room_name_.Set("", GetArena());
  }
  return released;
}
inline void RoomCompositeEgressRequest::set_allocated_room_name(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.room_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.room_name_.IsDefault()) {
    _impl_.room_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.RoomCompositeEgressRequest.room_name)
}

// string layout = 2;
inline void RoomCompositeEgressRequest::clear_layout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.layout_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RoomCompositeEgressRequest::layout() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.RoomCompositeEgressRequest.layout)
  return _internal_layout();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RoomCompositeEgressRequest::set_layout(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.layout_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.RoomCompositeEgressRequest.layout)
}
inline std::string* PROTOBUF_NONNULL RoomCompositeEgressRequest::mutable_layout()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_layout();
  // @@protoc_insertion_point(field_mutable:livekit.RoomCompositeEgressRequest.layout)
  return _s;
}
inline const std::string& RoomCompositeEgressRequest::_internal_layout() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.layout_.Get();
}
inline void RoomCompositeEgressRequest::_internal_set_layout(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.layout_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL RoomCompositeEgressRequest::_internal_mutable_layout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.layout_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE RoomCompositeEgressRequest::release_layout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.RoomCompositeEgressRequest.layout)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.layout_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.layout_.Set("", GetArena());
  }
  return released;
}
inline void RoomCompositeEgressRequest::set_allocated_layout(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.layout_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.layout_.IsDefault()) {
    _impl_.layout_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.RoomCompositeEgressRequest.layout)
}

// bool audio_only = 3;
inline void RoomCompositeEgressRequest::clear_audio_only() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.audio_only_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool RoomCompositeEgressRequest::audio_only() const {
  // @@protoc_insertion_point(field_get:livekit.RoomCompositeEgressRequest.audio_only)
  return _internal_audio_only();
}
inline void RoomCompositeEgressRequest::set_audio_only(bool value) {
  _internal_set_audio_only(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:livekit.RoomCompositeEgressRequest.audio_only)
}
inline bool RoomCompositeEgressRequest::_internal_audio_only() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.audio_only_;
}
inline void RoomCompositeEgressRequest::_internal_set_audio_only(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.audio_only_ = value;
}

// .livekit.AudioMixing audio_mixing = 15;
inline void RoomCompositeEgressRequest::clear_audio_mixing() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.audio_mixing_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::livekit::AudioMixing RoomCompositeEgressRequest::audio_mixing() const {
  // @@protoc_insertion_point(field_get:livekit.RoomCompositeEgressRequest.audio_mixing)
  return _internal_audio_mixing();
}
inline void RoomCompositeEgressRequest::set_audio_mixing(::livekit::AudioMixing value) {
  _internal_set_audio_mixing(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:livekit.RoomCompositeEgressRequest.audio_mixing)
}
inline ::livekit::AudioMixing RoomCompositeEgressRequest::_internal_audio_mixing() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::livekit::AudioMixing>(_impl_.audio_mixing_);
}
inline void RoomCompositeEgressRequest::_internal_set_audio_mixing(::livekit::AudioMixing value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.audio_mixing_ = value;
}

// bool video_only = 4;
inline void RoomCompositeEgressRequest::clear_video_only() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.video_only_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool RoomCompositeEgressRequest::video_only() const {
  // @@protoc_insertion_point(field_get:livekit.RoomCompositeEgressRequest.video_only)
  return _internal_video_only();
}
inline void RoomCompositeEgressRequest::set_video_only(bool value) {
  _internal_set_video_only(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:livekit.RoomCompositeEgressRequest.video_only)
}
inline bool RoomCompositeEgressRequest::_internal_video_only() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.video_only_;
}
inline void RoomCompositeEgressRequest::_internal_set_video_only(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.video_only_ = value;
}

// string custom_base_url = 5;
inline void RoomCompositeEgressRequest::clear_custom_base_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.custom_base_url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& RoomCompositeEgressRequest::custom_base_url() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.RoomCompositeEgressRequest.custom_base_url)
  return _internal_custom_base_url();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RoomCompositeEgressRequest::set_custom_base_url(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.custom_base_url_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.RoomCompositeEgressRequest.custom_base_url)
}
inline std::string* PROTOBUF_NONNULL RoomCompositeEgressRequest::mutable_custom_base_url()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_custom_base_url();
  // @@protoc_insertion_point(field_mutable:livekit.RoomCompositeEgressRequest.custom_base_url)
  return _s;
}
inline const std::string& RoomCompositeEgressRequest::_internal_custom_base_url() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.custom_base_url_.Get();
}
inline void RoomCompositeEgressRequest::_internal_set_custom_base_url(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.custom_base_url_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL RoomCompositeEgressRequest::_internal_mutable_custom_base_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.custom_base_url_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE RoomCompositeEgressRequest::release_custom_base_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.RoomCompositeEgressRequest.custom_base_url)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.custom_base_url_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.custom_base_url_.Set("", GetArena());
  }
  return released;
}
inline void RoomCompositeEgressRequest::set_allocated_custom_base_url(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.custom_base_url_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.custom_base_url_.IsDefault()) {
    _impl_.custom_base_url_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.RoomCompositeEgressRequest.custom_base_url)
}

// .livekit.EncodedFileOutput file = 6 [deprecated = true];
inline bool RoomCompositeEgressRequest::has_file() const {
  return output_case() == kFile;
}
inline bool RoomCompositeEgressRequest::_internal_has_file() const {
  return output_case() == kFile;
}
inline void RoomCompositeEgressRequest::set_has_file() {
  _impl_._oneof_case_[0] = kFile;
}
inline void RoomCompositeEgressRequest::clear_file() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (output_case() == kFile) {
    if (GetArena() == nullptr) {
      delete _impl_.output_.file_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.output_.file_);
    }
    clear_has_output();
  }
}
inline ::livekit::EncodedFileOutput* PROTOBUF_NULLABLE RoomCompositeEgressRequest::release_file() {
  // @@protoc_insertion_point(field_release:livekit.RoomCompositeEgressRequest.file)
  if (output_case() == kFile) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::EncodedFileOutput*>(_impl_.output_.file_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.file_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::EncodedFileOutput& RoomCompositeEgressRequest::_internal_file() const {
  return output_case() == kFile ? *reinterpret_cast<::livekit::EncodedFileOutput*>(_impl_.output_.file_) : reinterpret_cast<::livekit::EncodedFileOutput&>(::livekit::_EncodedFileOutput_default_instance_);
}
inline const ::livekit::EncodedFileOutput& RoomCompositeEgressRequest::file() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.RoomCompositeEgressRequest.file)
  return _internal_file();
}
inline ::livekit::EncodedFileOutput* PROTOBUF_NULLABLE RoomCompositeEgressRequest::unsafe_arena_release_file() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.RoomCompositeEgressRequest.file)
  if (output_case() == kFile) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::EncodedFileOutput*>(_impl_.output_.file_);
    _impl_.output_.file_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RoomCompositeEgressRequest::unsafe_arena_set_allocated_file(
    ::livekit::EncodedFileOutput* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_output();
  if (value) {
    set_has_file();
    _impl_.output_.file_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.RoomCompositeEgressRequest.file)
}
inline ::livekit::EncodedFileOutput* PROTOBUF_NONNULL RoomCompositeEgressRequest::_internal_mutable_file() {
  if (output_case() != kFile) {
    clear_output();
    set_has_file();
    _impl_.output_.file_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::EncodedFileOutput>(GetArena()));
  }
  return reinterpret_cast<::livekit::EncodedFileOutput*>(_impl_.output_.file_);
}
inline ::livekit::EncodedFileOutput* PROTOBUF_NONNULL RoomCompositeEgressRequest::mutable_file()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::EncodedFileOutput* _msg = _internal_mutable_file();
  // @@protoc_insertion_point(field_mutable:livekit.RoomCompositeEgressRequest.file)
  return _msg;
}

// .livekit.StreamOutput stream = 7 [deprecated = true];
inline bool RoomCompositeEgressRequest::has_stream() const {
  return output_case() == kStream;
}
inline bool RoomCompositeEgressRequest::_internal_has_stream() const {
  return output_case() == kStream;
}
inline void RoomCompositeEgressRequest::set_has_stream() {
  _impl_._oneof_case_[0] = kStream;
}
inline void RoomCompositeEgressRequest::clear_stream() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (output_case() == kStream) {
    if (GetArena() == nullptr) {
      delete _impl_.output_.stream_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.output_.stream_);
    }
    clear_has_output();
  }
}
inline ::livekit::StreamOutput* PROTOBUF_NULLABLE RoomCompositeEgressRequest::release_stream() {
  // @@protoc_insertion_point(field_release:livekit.RoomCompositeEgressRequest.stream)
  if (output_case() == kStream) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::StreamOutput*>(_impl_.output_.stream_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.stream_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::StreamOutput& RoomCompositeEgressRequest::_internal_stream() const {
  return output_case() == kStream ? *reinterpret_cast<::livekit::StreamOutput*>(_impl_.output_.stream_) : reinterpret_cast<::livekit::StreamOutput&>(::livekit::_StreamOutput_default_instance_);
}
inline const ::livekit::StreamOutput& RoomCompositeEgressRequest::stream() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.RoomCompositeEgressRequest.stream)
  return _internal_stream();
}
inline ::livekit::StreamOutput* PROTOBUF_NULLABLE RoomCompositeEgressRequest::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.RoomCompositeEgressRequest.stream)
  if (output_case() == kStream) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::StreamOutput*>(_impl_.output_.stream_);
    _impl_.output_.stream_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RoomCompositeEgressRequest::unsafe_arena_set_allocated_stream(
    ::livekit::StreamOutput* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_output();
  if (value) {
    set_has_stream();
    _impl_.output_.stream_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.RoomCompositeEgressRequest.stream)
}
inline ::livekit::StreamOutput* PROTOBUF_NONNULL RoomCompositeEgressRequest::_internal_mutable_stream() {
  if (output_case() != kStream) {
    clear_output();
    set_has_stream();
    _impl_.output_.stream_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::StreamOutput>(GetArena()));
  }
  return reinterpret_cast<::livekit::StreamOutput*>(_impl_.output_.stream_);
}
inline ::livekit::StreamOutput* PROTOBUF_NONNULL RoomCompositeEgressRequest::mutable_stream()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::StreamOutput* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:livekit.RoomCompositeEgressRequest.stream)
  return _msg;
}

// .livekit.SegmentedFileOutput segments = 10 [deprecated = true];
inline bool RoomCompositeEgressRequest::has_segments() const {
  return output_case() == kSegments;
}
inline bool RoomCompositeEgressRequest::_internal_has_segments() const {
  return output_case() == kSegments;
}
inline void RoomCompositeEgressRequest::set_has_segments() {
  _impl_._oneof_case_[0] = kSegments;
}
inline void RoomCompositeEgressRequest::clear_segments() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (output_case() == kSegments) {
    if (GetArena() == nullptr) {
      delete _impl_.output_.segments_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.output_.segments_);
    }
    clear_has_output();
  }
}
inline ::livekit::SegmentedFileOutput* PROTOBUF_NULLABLE RoomCompositeEgressRequest::release_segments() {
  // @@protoc_insertion_point(field_release:livekit.RoomCompositeEgressRequest.segments)
  if (output_case() == kSegments) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::SegmentedFileOutput*>(_impl_.output_.segments_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.segments_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::SegmentedFileOutput& RoomCompositeEgressRequest::_internal_segments() const {
  return output_case() == kSegments ? *reinterpret_cast<::livekit::SegmentedFileOutput*>(_impl_.output_.segments_) : reinterpret_cast<::livekit::SegmentedFileOutput&>(::livekit::_SegmentedFileOutput_default_instance_);
}
inline const ::livekit::SegmentedFileOutput& RoomCompositeEgressRequest::segments() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.RoomCompositeEgressRequest.segments)
  return _internal_segments();
}
inline ::livekit::SegmentedFileOutput* PROTOBUF_NULLABLE RoomCompositeEgressRequest::unsafe_arena_release_segments() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.RoomCompositeEgressRequest.segments)
  if (output_case() == kSegments) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::SegmentedFileOutput*>(_impl_.output_.segments_);
    _impl_.output_.segments_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RoomCompositeEgressRequest::unsafe_arena_set_allocated_segments(
    ::livekit::SegmentedFileOutput* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_output();
  if (value) {
    set_has_segments();
    _impl_.output_.segments_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.RoomCompositeEgressRequest.segments)
}
inline ::livekit::SegmentedFileOutput* PROTOBUF_NONNULL RoomCompositeEgressRequest::_internal_mutable_segments() {
  if (output_case() != kSegments) {
    clear_output();
    set_has_segments();
    _impl_.output_.segments_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::SegmentedFileOutput>(GetArena()));
  }
  return reinterpret_cast<::livekit::SegmentedFileOutput*>(_impl_.output_.segments_);
}
inline ::livekit::SegmentedFileOutput* PROTOBUF_NONNULL RoomCompositeEgressRequest::mutable_segments()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::SegmentedFileOutput* _msg = _internal_mutable_segments();
  // @@protoc_insertion_point(field_mutable:livekit.RoomCompositeEgressRequest.segments)
  return _msg;
}

// .livekit.EncodingOptionsPreset preset = 8;
inline bool RoomCompositeEgressRequest::has_preset() const {
  return options_case() == kPreset;
}
inline void RoomCompositeEgressRequest::set_has_preset() {
  _impl_._oneof_case_[1] = kPreset;
}
inline void RoomCompositeEgressRequest::clear_preset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (options_case() == kPreset) {
    _impl_.options_.preset_ = 0;
    clear_has_options();
  }
}
inline ::livekit::EncodingOptionsPreset RoomCompositeEgressRequest::preset() const {
  // @@protoc_insertion_point(field_get:livekit.RoomCompositeEgressRequest.preset)
  return _internal_preset();
}
inline void RoomCompositeEgressRequest::set_preset(::livekit::EncodingOptionsPreset value) {
  if (options_case() != kPreset) {
    clear_options();
    set_has_preset();
  }
  _impl_.options_.preset_ = value;
  // @@protoc_insertion_point(field_set:livekit.RoomCompositeEgressRequest.preset)
}
inline ::livekit::EncodingOptionsPreset RoomCompositeEgressRequest::_internal_preset() const {
  if (options_case() == kPreset) {
    return static_cast<::livekit::EncodingOptionsPreset>(_impl_.options_.preset_);
  }
  return static_cast<::livekit::EncodingOptionsPreset>(0);
}

// .livekit.EncodingOptions advanced = 9;
inline bool RoomCompositeEgressRequest::has_advanced() const {
  return options_case() == kAdvanced;
}
inline bool RoomCompositeEgressRequest::_internal_has_advanced() const {
  return options_case() == kAdvanced;
}
inline void RoomCompositeEgressRequest::set_has_advanced() {
  _impl_._oneof_case_[1] = kAdvanced;
}
inline void RoomCompositeEgressRequest::clear_advanced() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (options_case() == kAdvanced) {
    if (GetArena() == nullptr) {
      delete _impl_.options_.advanced_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.options_.advanced_);
    }
    clear_has_options();
  }
}
inline ::livekit::EncodingOptions* PROTOBUF_NULLABLE RoomCompositeEgressRequest::release_advanced() {
  // @@protoc_insertion_point(field_release:livekit.RoomCompositeEgressRequest.advanced)
  if (options_case() == kAdvanced) {
    clear_has_options();
    auto* temp = _impl_.options_.advanced_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.options_.advanced_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::EncodingOptions& RoomCompositeEgressRequest::_internal_advanced() const {
  return options_case() == kAdvanced ? *_impl_.options_.advanced_ : reinterpret_cast<::livekit::EncodingOptions&>(::livekit::_EncodingOptions_default_instance_);
}
inline const ::livekit::EncodingOptions& RoomCompositeEgressRequest::advanced() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.RoomCompositeEgressRequest.advanced)
  return _internal_advanced();
}
inline ::livekit::EncodingOptions* PROTOBUF_NULLABLE RoomCompositeEgressRequest::unsafe_arena_release_advanced() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.RoomCompositeEgressRequest.advanced)
  if (options_case() == kAdvanced) {
    clear_has_options();
    auto* temp = _impl_.options_.advanced_;
    _impl_.options_.advanced_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RoomCompositeEgressRequest::unsafe_arena_set_allocated_advanced(
    ::livekit::EncodingOptions* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_options();
  if (value) {
    set_has_advanced();
    _impl_.options_.advanced_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.RoomCompositeEgressRequest.advanced)
}
inline ::livekit::EncodingOptions* PROTOBUF_NONNULL RoomCompositeEgressRequest::_internal_mutable_advanced() {
  if (options_case() != kAdvanced) {
    clear_options();
    set_has_advanced();
    _impl_.options_.advanced_ = 
        ::google::protobuf::Message::DefaultConstruct<::livekit::EncodingOptions>(GetArena());
  }
  return _impl_.options_.advanced_;
}
inline ::livekit::EncodingOptions* PROTOBUF_NONNULL RoomCompositeEgressRequest::mutable_advanced()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::EncodingOptions* _msg = _internal_mutable_advanced();
  // @@protoc_insertion_point(field_mutable:livekit.RoomCompositeEgressRequest.advanced)
  return _msg;
}

// repeated .livekit.EncodedFileOutput file_outputs = 11;
inline int RoomCompositeEgressRequest::_internal_file_outputs_size() const {
  return _internal_file_outputs().size();
}
inline int RoomCompositeEgressRequest::file_outputs_size() const {
  return _internal_file_outputs_size();
}
inline void RoomCompositeEgressRequest::clear_file_outputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.file_outputs_.Clear();
}
inline ::livekit::EncodedFileOutput* PROTOBUF_NONNULL RoomCompositeEgressRequest::mutable_file_outputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.RoomCompositeEgressRequest.file_outputs)
  return _internal_mutable_file_outputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::EncodedFileOutput>* PROTOBUF_NONNULL RoomCompositeEgressRequest::mutable_file_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.RoomCompositeEgressRequest.file_outputs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_file_outputs();
}
inline const ::livekit::EncodedFileOutput& RoomCompositeEgressRequest::file_outputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.RoomCompositeEgressRequest.file_outputs)
  return _internal_file_outputs().Get(index);
}
inline ::livekit::EncodedFileOutput* PROTOBUF_NONNULL RoomCompositeEgressRequest::add_file_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::EncodedFileOutput* _add = _internal_mutable_file_outputs()->Add();
  // @@protoc_insertion_point(field_add:livekit.RoomCompositeEgressRequest.file_outputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::EncodedFileOutput>& RoomCompositeEgressRequest::file_outputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.RoomCompositeEgressRequest.file_outputs)
  return _internal_file_outputs();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::EncodedFileOutput>&
RoomCompositeEgressRequest::_internal_file_outputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.file_outputs_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::EncodedFileOutput>* PROTOBUF_NONNULL
RoomCompositeEgressRequest::_internal_mutable_file_outputs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.file_outputs_;
}

// repeated .livekit.StreamOutput stream_outputs = 12;
inline int RoomCompositeEgressRequest::_internal_stream_outputs_size() const {
  return _internal_stream_outputs().size();
}
inline int RoomCompositeEgressRequest::stream_outputs_size() const {
  return _internal_stream_outputs_size();
}
inline void RoomCompositeEgressRequest::clear_stream_outputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stream_outputs_.Clear();
}
inline ::livekit::StreamOutput* PROTOBUF_NONNULL RoomCompositeEgressRequest::mutable_stream_outputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.RoomCompositeEgressRequest.stream_outputs)
  return _internal_mutable_stream_outputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::StreamOutput>* PROTOBUF_NONNULL RoomCompositeEgressRequest::mutable_stream_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.RoomCompositeEgressRequest.stream_outputs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_stream_outputs();
}
inline const ::livekit::StreamOutput& RoomCompositeEgressRequest::stream_outputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.RoomCompositeEgressRequest.stream_outputs)
  return _internal_stream_outputs().Get(index);
}
inline ::livekit::StreamOutput* PROTOBUF_NONNULL RoomCompositeEgressRequest::add_stream_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::StreamOutput* _add = _internal_mutable_stream_outputs()->Add();
  // @@protoc_insertion_point(field_add:livekit.RoomCompositeEgressRequest.stream_outputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::StreamOutput>& RoomCompositeEgressRequest::stream_outputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.RoomCompositeEgressRequest.stream_outputs)
  return _internal_stream_outputs();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::StreamOutput>&
RoomCompositeEgressRequest::_internal_stream_outputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stream_outputs_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::StreamOutput>* PROTOBUF_NONNULL
RoomCompositeEgressRequest::_internal_mutable_stream_outputs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.stream_outputs_;
}

// repeated .livekit.SegmentedFileOutput segment_outputs = 13;
inline int RoomCompositeEgressRequest::_internal_segment_outputs_size() const {
  return _internal_segment_outputs().size();
}
inline int RoomCompositeEgressRequest::segment_outputs_size() const {
  return _internal_segment_outputs_size();
}
inline void RoomCompositeEgressRequest::clear_segment_outputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.segment_outputs_.Clear();
}
inline ::livekit::SegmentedFileOutput* PROTOBUF_NONNULL RoomCompositeEgressRequest::mutable_segment_outputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.RoomCompositeEgressRequest.segment_outputs)
  return _internal_mutable_segment_outputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::SegmentedFileOutput>* PROTOBUF_NONNULL RoomCompositeEgressRequest::mutable_segment_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.RoomCompositeEgressRequest.segment_outputs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_segment_outputs();
}
inline const ::livekit::SegmentedFileOutput& RoomCompositeEgressRequest::segment_outputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.RoomCompositeEgressRequest.segment_outputs)
  return _internal_segment_outputs().Get(index);
}
inline ::livekit::SegmentedFileOutput* PROTOBUF_NONNULL RoomCompositeEgressRequest::add_segment_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::SegmentedFileOutput* _add = _internal_mutable_segment_outputs()->Add();
  // @@protoc_insertion_point(field_add:livekit.RoomCompositeEgressRequest.segment_outputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::SegmentedFileOutput>& RoomCompositeEgressRequest::segment_outputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.RoomCompositeEgressRequest.segment_outputs)
  return _internal_segment_outputs();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::SegmentedFileOutput>&
RoomCompositeEgressRequest::_internal_segment_outputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.segment_outputs_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::SegmentedFileOutput>* PROTOBUF_NONNULL
RoomCompositeEgressRequest::_internal_mutable_segment_outputs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.segment_outputs_;
}

// repeated .livekit.ImageOutput image_outputs = 14;
inline int RoomCompositeEgressRequest::_internal_image_outputs_size() const {
  return _internal_image_outputs().size();
}
inline int RoomCompositeEgressRequest::image_outputs_size() const {
  return _internal_image_outputs_size();
}
inline void RoomCompositeEgressRequest::clear_image_outputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.image_outputs_.Clear();
}
inline ::livekit::ImageOutput* PROTOBUF_NONNULL RoomCompositeEgressRequest::mutable_image_outputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.RoomCompositeEgressRequest.image_outputs)
  return _internal_mutable_image_outputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::ImageOutput>* PROTOBUF_NONNULL RoomCompositeEgressRequest::mutable_image_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.RoomCompositeEgressRequest.image_outputs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_image_outputs();
}
inline const ::livekit::ImageOutput& RoomCompositeEgressRequest::image_outputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.RoomCompositeEgressRequest.image_outputs)
  return _internal_image_outputs().Get(index);
}
inline ::livekit::ImageOutput* PROTOBUF_NONNULL RoomCompositeEgressRequest::add_image_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::ImageOutput* _add = _internal_mutable_image_outputs()->Add();
  // @@protoc_insertion_point(field_add:livekit.RoomCompositeEgressRequest.image_outputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::ImageOutput>& RoomCompositeEgressRequest::image_outputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.RoomCompositeEgressRequest.image_outputs)
  return _internal_image_outputs();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::ImageOutput>&
RoomCompositeEgressRequest::_internal_image_outputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.image_outputs_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::ImageOutput>* PROTOBUF_NONNULL
RoomCompositeEgressRequest::_internal_mutable_image_outputs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.image_outputs_;
}

inline bool RoomCompositeEgressRequest::has_output() const {
  return output_case() != OUTPUT_NOT_SET;
}
inline void RoomCompositeEgressRequest::clear_has_output() {
  _impl_._oneof_case_[0] = OUTPUT_NOT_SET;
}
inline bool RoomCompositeEgressRequest::has_options() const {
  return options_case() != OPTIONS_NOT_SET;
}
inline void RoomCompositeEgressRequest::clear_has_options() {
  _impl_._oneof_case_[1] = OPTIONS_NOT_SET;
}
inline RoomCompositeEgressRequest::OutputCase RoomCompositeEgressRequest::output_case() const {
  return RoomCompositeEgressRequest::OutputCase(_impl_._oneof_case_[0]);
}
inline RoomCompositeEgressRequest::OptionsCase RoomCompositeEgressRequest::options_case() const {
  return RoomCompositeEgressRequest::OptionsCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// WebEgressRequest

// string url = 1;
inline void WebEgressRequest::clear_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& WebEgressRequest::url() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.WebEgressRequest.url)
  return _internal_url();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void WebEgressRequest::set_url(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.url_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.WebEgressRequest.url)
}
inline std::string* PROTOBUF_NONNULL WebEgressRequest::mutable_url()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:livekit.WebEgressRequest.url)
  return _s;
}
inline const std::string& WebEgressRequest::_internal_url() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.url_.Get();
}
inline void WebEgressRequest::_internal_set_url(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.url_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL WebEgressRequest::_internal_mutable_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.url_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE WebEgressRequest::release_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.WebEgressRequest.url)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.url_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.url_.Set("", GetArena());
  }
  return released;
}
inline void WebEgressRequest::set_allocated_url(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.url_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.WebEgressRequest.url)
}

// bool audio_only = 2;
inline void WebEgressRequest::clear_audio_only() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.audio_only_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool WebEgressRequest::audio_only() const {
  // @@protoc_insertion_point(field_get:livekit.WebEgressRequest.audio_only)
  return _internal_audio_only();
}
inline void WebEgressRequest::set_audio_only(bool value) {
  _internal_set_audio_only(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:livekit.WebEgressRequest.audio_only)
}
inline bool WebEgressRequest::_internal_audio_only() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.audio_only_;
}
inline void WebEgressRequest::_internal_set_audio_only(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.audio_only_ = value;
}

// bool video_only = 3;
inline void WebEgressRequest::clear_video_only() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.video_only_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool WebEgressRequest::video_only() const {
  // @@protoc_insertion_point(field_get:livekit.WebEgressRequest.video_only)
  return _internal_video_only();
}
inline void WebEgressRequest::set_video_only(bool value) {
  _internal_set_video_only(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:livekit.WebEgressRequest.video_only)
}
inline bool WebEgressRequest::_internal_video_only() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.video_only_;
}
inline void WebEgressRequest::_internal_set_video_only(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.video_only_ = value;
}

// bool await_start_signal = 12;
inline void WebEgressRequest::clear_await_start_signal() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.await_start_signal_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool WebEgressRequest::await_start_signal() const {
  // @@protoc_insertion_point(field_get:livekit.WebEgressRequest.await_start_signal)
  return _internal_await_start_signal();
}
inline void WebEgressRequest::set_await_start_signal(bool value) {
  _internal_set_await_start_signal(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:livekit.WebEgressRequest.await_start_signal)
}
inline bool WebEgressRequest::_internal_await_start_signal() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.await_start_signal_;
}
inline void WebEgressRequest::_internal_set_await_start_signal(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.await_start_signal_ = value;
}

// .livekit.EncodedFileOutput file = 4 [deprecated = true];
inline bool WebEgressRequest::has_file() const {
  return output_case() == kFile;
}
inline bool WebEgressRequest::_internal_has_file() const {
  return output_case() == kFile;
}
inline void WebEgressRequest::set_has_file() {
  _impl_._oneof_case_[0] = kFile;
}
inline void WebEgressRequest::clear_file() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (output_case() == kFile) {
    if (GetArena() == nullptr) {
      delete _impl_.output_.file_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.output_.file_);
    }
    clear_has_output();
  }
}
inline ::livekit::EncodedFileOutput* PROTOBUF_NULLABLE WebEgressRequest::release_file() {
  // @@protoc_insertion_point(field_release:livekit.WebEgressRequest.file)
  if (output_case() == kFile) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::EncodedFileOutput*>(_impl_.output_.file_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.file_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::EncodedFileOutput& WebEgressRequest::_internal_file() const {
  return output_case() == kFile ? *reinterpret_cast<::livekit::EncodedFileOutput*>(_impl_.output_.file_) : reinterpret_cast<::livekit::EncodedFileOutput&>(::livekit::_EncodedFileOutput_default_instance_);
}
inline const ::livekit::EncodedFileOutput& WebEgressRequest::file() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.WebEgressRequest.file)
  return _internal_file();
}
inline ::livekit::EncodedFileOutput* PROTOBUF_NULLABLE WebEgressRequest::unsafe_arena_release_file() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.WebEgressRequest.file)
  if (output_case() == kFile) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::EncodedFileOutput*>(_impl_.output_.file_);
    _impl_.output_.file_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WebEgressRequest::unsafe_arena_set_allocated_file(
    ::livekit::EncodedFileOutput* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_output();
  if (value) {
    set_has_file();
    _impl_.output_.file_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.WebEgressRequest.file)
}
inline ::livekit::EncodedFileOutput* PROTOBUF_NONNULL WebEgressRequest::_internal_mutable_file() {
  if (output_case() != kFile) {
    clear_output();
    set_has_file();
    _impl_.output_.file_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::EncodedFileOutput>(GetArena()));
  }
  return reinterpret_cast<::livekit::EncodedFileOutput*>(_impl_.output_.file_);
}
inline ::livekit::EncodedFileOutput* PROTOBUF_NONNULL WebEgressRequest::mutable_file()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::EncodedFileOutput* _msg = _internal_mutable_file();
  // @@protoc_insertion_point(field_mutable:livekit.WebEgressRequest.file)
  return _msg;
}

// .livekit.StreamOutput stream = 5 [deprecated = true];
inline bool WebEgressRequest::has_stream() const {
  return output_case() == kStream;
}
inline bool WebEgressRequest::_internal_has_stream() const {
  return output_case() == kStream;
}
inline void WebEgressRequest::set_has_stream() {
  _impl_._oneof_case_[0] = kStream;
}
inline void WebEgressRequest::clear_stream() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (output_case() == kStream) {
    if (GetArena() == nullptr) {
      delete _impl_.output_.stream_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.output_.stream_);
    }
    clear_has_output();
  }
}
inline ::livekit::StreamOutput* PROTOBUF_NULLABLE WebEgressRequest::release_stream() {
  // @@protoc_insertion_point(field_release:livekit.WebEgressRequest.stream)
  if (output_case() == kStream) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::StreamOutput*>(_impl_.output_.stream_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.stream_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::StreamOutput& WebEgressRequest::_internal_stream() const {
  return output_case() == kStream ? *reinterpret_cast<::livekit::StreamOutput*>(_impl_.output_.stream_) : reinterpret_cast<::livekit::StreamOutput&>(::livekit::_StreamOutput_default_instance_);
}
inline const ::livekit::StreamOutput& WebEgressRequest::stream() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.WebEgressRequest.stream)
  return _internal_stream();
}
inline ::livekit::StreamOutput* PROTOBUF_NULLABLE WebEgressRequest::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.WebEgressRequest.stream)
  if (output_case() == kStream) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::StreamOutput*>(_impl_.output_.stream_);
    _impl_.output_.stream_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WebEgressRequest::unsafe_arena_set_allocated_stream(
    ::livekit::StreamOutput* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_output();
  if (value) {
    set_has_stream();
    _impl_.output_.stream_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.WebEgressRequest.stream)
}
inline ::livekit::StreamOutput* PROTOBUF_NONNULL WebEgressRequest::_internal_mutable_stream() {
  if (output_case() != kStream) {
    clear_output();
    set_has_stream();
    _impl_.output_.stream_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::StreamOutput>(GetArena()));
  }
  return reinterpret_cast<::livekit::StreamOutput*>(_impl_.output_.stream_);
}
inline ::livekit::StreamOutput* PROTOBUF_NONNULL WebEgressRequest::mutable_stream()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::StreamOutput* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:livekit.WebEgressRequest.stream)
  return _msg;
}

// .livekit.SegmentedFileOutput segments = 6 [deprecated = true];
inline bool WebEgressRequest::has_segments() const {
  return output_case() == kSegments;
}
inline bool WebEgressRequest::_internal_has_segments() const {
  return output_case() == kSegments;
}
inline void WebEgressRequest::set_has_segments() {
  _impl_._oneof_case_[0] = kSegments;
}
inline void WebEgressRequest::clear_segments() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (output_case() == kSegments) {
    if (GetArena() == nullptr) {
      delete _impl_.output_.segments_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.output_.segments_);
    }
    clear_has_output();
  }
}
inline ::livekit::SegmentedFileOutput* PROTOBUF_NULLABLE WebEgressRequest::release_segments() {
  // @@protoc_insertion_point(field_release:livekit.WebEgressRequest.segments)
  if (output_case() == kSegments) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::SegmentedFileOutput*>(_impl_.output_.segments_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.segments_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::SegmentedFileOutput& WebEgressRequest::_internal_segments() const {
  return output_case() == kSegments ? *reinterpret_cast<::livekit::SegmentedFileOutput*>(_impl_.output_.segments_) : reinterpret_cast<::livekit::SegmentedFileOutput&>(::livekit::_SegmentedFileOutput_default_instance_);
}
inline const ::livekit::SegmentedFileOutput& WebEgressRequest::segments() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.WebEgressRequest.segments)
  return _internal_segments();
}
inline ::livekit::SegmentedFileOutput* PROTOBUF_NULLABLE WebEgressRequest::unsafe_arena_release_segments() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.WebEgressRequest.segments)
  if (output_case() == kSegments) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::SegmentedFileOutput*>(_impl_.output_.segments_);
    _impl_.output_.segments_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WebEgressRequest::unsafe_arena_set_allocated_segments(
    ::livekit::SegmentedFileOutput* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_output();
  if (value) {
    set_has_segments();
    _impl_.output_.segments_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.WebEgressRequest.segments)
}
inline ::livekit::SegmentedFileOutput* PROTOBUF_NONNULL WebEgressRequest::_internal_mutable_segments() {
  if (output_case() != kSegments) {
    clear_output();
    set_has_segments();
    _impl_.output_.segments_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::SegmentedFileOutput>(GetArena()));
  }
  return reinterpret_cast<::livekit::SegmentedFileOutput*>(_impl_.output_.segments_);
}
inline ::livekit::SegmentedFileOutput* PROTOBUF_NONNULL WebEgressRequest::mutable_segments()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::SegmentedFileOutput* _msg = _internal_mutable_segments();
  // @@protoc_insertion_point(field_mutable:livekit.WebEgressRequest.segments)
  return _msg;
}

// .livekit.EncodingOptionsPreset preset = 7;
inline bool WebEgressRequest::has_preset() const {
  return options_case() == kPreset;
}
inline void WebEgressRequest::set_has_preset() {
  _impl_._oneof_case_[1] = kPreset;
}
inline void WebEgressRequest::clear_preset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (options_case() == kPreset) {
    _impl_.options_.preset_ = 0;
    clear_has_options();
  }
}
inline ::livekit::EncodingOptionsPreset WebEgressRequest::preset() const {
  // @@protoc_insertion_point(field_get:livekit.WebEgressRequest.preset)
  return _internal_preset();
}
inline void WebEgressRequest::set_preset(::livekit::EncodingOptionsPreset value) {
  if (options_case() != kPreset) {
    clear_options();
    set_has_preset();
  }
  _impl_.options_.preset_ = value;
  // @@protoc_insertion_point(field_set:livekit.WebEgressRequest.preset)
}
inline ::livekit::EncodingOptionsPreset WebEgressRequest::_internal_preset() const {
  if (options_case() == kPreset) {
    return static_cast<::livekit::EncodingOptionsPreset>(_impl_.options_.preset_);
  }
  return static_cast<::livekit::EncodingOptionsPreset>(0);
}

// .livekit.EncodingOptions advanced = 8;
inline bool WebEgressRequest::has_advanced() const {
  return options_case() == kAdvanced;
}
inline bool WebEgressRequest::_internal_has_advanced() const {
  return options_case() == kAdvanced;
}
inline void WebEgressRequest::set_has_advanced() {
  _impl_._oneof_case_[1] = kAdvanced;
}
inline void WebEgressRequest::clear_advanced() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (options_case() == kAdvanced) {
    if (GetArena() == nullptr) {
      delete _impl_.options_.advanced_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.options_.advanced_);
    }
    clear_has_options();
  }
}
inline ::livekit::EncodingOptions* PROTOBUF_NULLABLE WebEgressRequest::release_advanced() {
  // @@protoc_insertion_point(field_release:livekit.WebEgressRequest.advanced)
  if (options_case() == kAdvanced) {
    clear_has_options();
    auto* temp = _impl_.options_.advanced_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.options_.advanced_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::EncodingOptions& WebEgressRequest::_internal_advanced() const {
  return options_case() == kAdvanced ? *_impl_.options_.advanced_ : reinterpret_cast<::livekit::EncodingOptions&>(::livekit::_EncodingOptions_default_instance_);
}
inline const ::livekit::EncodingOptions& WebEgressRequest::advanced() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.WebEgressRequest.advanced)
  return _internal_advanced();
}
inline ::livekit::EncodingOptions* PROTOBUF_NULLABLE WebEgressRequest::unsafe_arena_release_advanced() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.WebEgressRequest.advanced)
  if (options_case() == kAdvanced) {
    clear_has_options();
    auto* temp = _impl_.options_.advanced_;
    _impl_.options_.advanced_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WebEgressRequest::unsafe_arena_set_allocated_advanced(
    ::livekit::EncodingOptions* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_options();
  if (value) {
    set_has_advanced();
    _impl_.options_.advanced_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.WebEgressRequest.advanced)
}
inline ::livekit::EncodingOptions* PROTOBUF_NONNULL WebEgressRequest::_internal_mutable_advanced() {
  if (options_case() != kAdvanced) {
    clear_options();
    set_has_advanced();
    _impl_.options_.advanced_ = 
        ::google::protobuf::Message::DefaultConstruct<::livekit::EncodingOptions>(GetArena());
  }
  return _impl_.options_.advanced_;
}
inline ::livekit::EncodingOptions* PROTOBUF_NONNULL WebEgressRequest::mutable_advanced()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::EncodingOptions* _msg = _internal_mutable_advanced();
  // @@protoc_insertion_point(field_mutable:livekit.WebEgressRequest.advanced)
  return _msg;
}

// repeated .livekit.EncodedFileOutput file_outputs = 9;
inline int WebEgressRequest::_internal_file_outputs_size() const {
  return _internal_file_outputs().size();
}
inline int WebEgressRequest::file_outputs_size() const {
  return _internal_file_outputs_size();
}
inline void WebEgressRequest::clear_file_outputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.file_outputs_.Clear();
}
inline ::livekit::EncodedFileOutput* PROTOBUF_NONNULL WebEgressRequest::mutable_file_outputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.WebEgressRequest.file_outputs)
  return _internal_mutable_file_outputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::EncodedFileOutput>* PROTOBUF_NONNULL WebEgressRequest::mutable_file_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.WebEgressRequest.file_outputs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_file_outputs();
}
inline const ::livekit::EncodedFileOutput& WebEgressRequest::file_outputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.WebEgressRequest.file_outputs)
  return _internal_file_outputs().Get(index);
}
inline ::livekit::EncodedFileOutput* PROTOBUF_NONNULL WebEgressRequest::add_file_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::EncodedFileOutput* _add = _internal_mutable_file_outputs()->Add();
  // @@protoc_insertion_point(field_add:livekit.WebEgressRequest.file_outputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::EncodedFileOutput>& WebEgressRequest::file_outputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.WebEgressRequest.file_outputs)
  return _internal_file_outputs();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::EncodedFileOutput>&
WebEgressRequest::_internal_file_outputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.file_outputs_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::EncodedFileOutput>* PROTOBUF_NONNULL
WebEgressRequest::_internal_mutable_file_outputs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.file_outputs_;
}

// repeated .livekit.StreamOutput stream_outputs = 10;
inline int WebEgressRequest::_internal_stream_outputs_size() const {
  return _internal_stream_outputs().size();
}
inline int WebEgressRequest::stream_outputs_size() const {
  return _internal_stream_outputs_size();
}
inline void WebEgressRequest::clear_stream_outputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stream_outputs_.Clear();
}
inline ::livekit::StreamOutput* PROTOBUF_NONNULL WebEgressRequest::mutable_stream_outputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.WebEgressRequest.stream_outputs)
  return _internal_mutable_stream_outputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::StreamOutput>* PROTOBUF_NONNULL WebEgressRequest::mutable_stream_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.WebEgressRequest.stream_outputs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_stream_outputs();
}
inline const ::livekit::StreamOutput& WebEgressRequest::stream_outputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.WebEgressRequest.stream_outputs)
  return _internal_stream_outputs().Get(index);
}
inline ::livekit::StreamOutput* PROTOBUF_NONNULL WebEgressRequest::add_stream_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::StreamOutput* _add = _internal_mutable_stream_outputs()->Add();
  // @@protoc_insertion_point(field_add:livekit.WebEgressRequest.stream_outputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::StreamOutput>& WebEgressRequest::stream_outputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.WebEgressRequest.stream_outputs)
  return _internal_stream_outputs();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::StreamOutput>&
WebEgressRequest::_internal_stream_outputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stream_outputs_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::StreamOutput>* PROTOBUF_NONNULL
WebEgressRequest::_internal_mutable_stream_outputs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.stream_outputs_;
}

// repeated .livekit.SegmentedFileOutput segment_outputs = 11;
inline int WebEgressRequest::_internal_segment_outputs_size() const {
  return _internal_segment_outputs().size();
}
inline int WebEgressRequest::segment_outputs_size() const {
  return _internal_segment_outputs_size();
}
inline void WebEgressRequest::clear_segment_outputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.segment_outputs_.Clear();
}
inline ::livekit::SegmentedFileOutput* PROTOBUF_NONNULL WebEgressRequest::mutable_segment_outputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.WebEgressRequest.segment_outputs)
  return _internal_mutable_segment_outputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::SegmentedFileOutput>* PROTOBUF_NONNULL WebEgressRequest::mutable_segment_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.WebEgressRequest.segment_outputs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_segment_outputs();
}
inline const ::livekit::SegmentedFileOutput& WebEgressRequest::segment_outputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.WebEgressRequest.segment_outputs)
  return _internal_segment_outputs().Get(index);
}
inline ::livekit::SegmentedFileOutput* PROTOBUF_NONNULL WebEgressRequest::add_segment_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::SegmentedFileOutput* _add = _internal_mutable_segment_outputs()->Add();
  // @@protoc_insertion_point(field_add:livekit.WebEgressRequest.segment_outputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::SegmentedFileOutput>& WebEgressRequest::segment_outputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.WebEgressRequest.segment_outputs)
  return _internal_segment_outputs();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::SegmentedFileOutput>&
WebEgressRequest::_internal_segment_outputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.segment_outputs_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::SegmentedFileOutput>* PROTOBUF_NONNULL
WebEgressRequest::_internal_mutable_segment_outputs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.segment_outputs_;
}

// repeated .livekit.ImageOutput image_outputs = 13;
inline int WebEgressRequest::_internal_image_outputs_size() const {
  return _internal_image_outputs().size();
}
inline int WebEgressRequest::image_outputs_size() const {
  return _internal_image_outputs_size();
}
inline void WebEgressRequest::clear_image_outputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.image_outputs_.Clear();
}
inline ::livekit::ImageOutput* PROTOBUF_NONNULL WebEgressRequest::mutable_image_outputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.WebEgressRequest.image_outputs)
  return _internal_mutable_image_outputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::ImageOutput>* PROTOBUF_NONNULL WebEgressRequest::mutable_image_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.WebEgressRequest.image_outputs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_image_outputs();
}
inline const ::livekit::ImageOutput& WebEgressRequest::image_outputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.WebEgressRequest.image_outputs)
  return _internal_image_outputs().Get(index);
}
inline ::livekit::ImageOutput* PROTOBUF_NONNULL WebEgressRequest::add_image_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::ImageOutput* _add = _internal_mutable_image_outputs()->Add();
  // @@protoc_insertion_point(field_add:livekit.WebEgressRequest.image_outputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::ImageOutput>& WebEgressRequest::image_outputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.WebEgressRequest.image_outputs)
  return _internal_image_outputs();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::ImageOutput>&
WebEgressRequest::_internal_image_outputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.image_outputs_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::ImageOutput>* PROTOBUF_NONNULL
WebEgressRequest::_internal_mutable_image_outputs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.image_outputs_;
}

inline bool WebEgressRequest::has_output() const {
  return output_case() != OUTPUT_NOT_SET;
}
inline void WebEgressRequest::clear_has_output() {
  _impl_._oneof_case_[0] = OUTPUT_NOT_SET;
}
inline bool WebEgressRequest::has_options() const {
  return options_case() != OPTIONS_NOT_SET;
}
inline void WebEgressRequest::clear_has_options() {
  _impl_._oneof_case_[1] = OPTIONS_NOT_SET;
}
inline WebEgressRequest::OutputCase WebEgressRequest::output_case() const {
  return WebEgressRequest::OutputCase(_impl_._oneof_case_[0]);
}
inline WebEgressRequest::OptionsCase WebEgressRequest::options_case() const {
  return WebEgressRequest::OptionsCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// ParticipantEgressRequest

// string room_name = 1;
inline void ParticipantEgressRequest::clear_room_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.room_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ParticipantEgressRequest::room_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.ParticipantEgressRequest.room_name)
  return _internal_room_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ParticipantEgressRequest::set_room_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.room_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.ParticipantEgressRequest.room_name)
}
inline std::string* PROTOBUF_NONNULL ParticipantEgressRequest::mutable_room_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_room_name();
  // @@protoc_insertion_point(field_mutable:livekit.ParticipantEgressRequest.room_name)
  return _s;
}
inline const std::string& ParticipantEgressRequest::_internal_room_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.room_name_.Get();
}
inline void ParticipantEgressRequest::_internal_set_room_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.room_name_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL ParticipantEgressRequest::_internal_mutable_room_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.room_name_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE ParticipantEgressRequest::release_room_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.ParticipantEgressRequest.room_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.room_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.room_name_.Set("", GetArena());
  }
  return released;
}
inline void ParticipantEgressRequest::set_allocated_room_name(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.room_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.room_name_.IsDefault()) {
    _impl_.room_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.ParticipantEgressRequest.room_name)
}

// string identity = 2;
inline void ParticipantEgressRequest::clear_identity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.identity_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ParticipantEgressRequest::identity() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.ParticipantEgressRequest.identity)
  return _internal_identity();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ParticipantEgressRequest::set_identity(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.identity_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.ParticipantEgressRequest.identity)
}
inline std::string* PROTOBUF_NONNULL ParticipantEgressRequest::mutable_identity()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_identity();
  // @@protoc_insertion_point(field_mutable:livekit.ParticipantEgressRequest.identity)
  return _s;
}
inline const std::string& ParticipantEgressRequest::_internal_identity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.identity_.Get();
}
inline void ParticipantEgressRequest::_internal_set_identity(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.identity_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL ParticipantEgressRequest::_internal_mutable_identity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.identity_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE ParticipantEgressRequest::release_identity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.ParticipantEgressRequest.identity)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.identity_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.identity_.Set("", GetArena());
  }
  return released;
}
inline void ParticipantEgressRequest::set_allocated_identity(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.identity_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.identity_.IsDefault()) {
    _impl_.identity_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.ParticipantEgressRequest.identity)
}

// bool screen_share = 3;
inline void ParticipantEgressRequest::clear_screen_share() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.screen_share_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool ParticipantEgressRequest::screen_share() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantEgressRequest.screen_share)
  return _internal_screen_share();
}
inline void ParticipantEgressRequest::set_screen_share(bool value) {
  _internal_set_screen_share(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:livekit.ParticipantEgressRequest.screen_share)
}
inline bool ParticipantEgressRequest::_internal_screen_share() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.screen_share_;
}
inline void ParticipantEgressRequest::_internal_set_screen_share(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.screen_share_ = value;
}

// .livekit.EncodingOptionsPreset preset = 4;
inline bool ParticipantEgressRequest::has_preset() const {
  return options_case() == kPreset;
}
inline void ParticipantEgressRequest::set_has_preset() {
  _impl_._oneof_case_[0] = kPreset;
}
inline void ParticipantEgressRequest::clear_preset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (options_case() == kPreset) {
    _impl_.options_.preset_ = 0;
    clear_has_options();
  }
}
inline ::livekit::EncodingOptionsPreset ParticipantEgressRequest::preset() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantEgressRequest.preset)
  return _internal_preset();
}
inline void ParticipantEgressRequest::set_preset(::livekit::EncodingOptionsPreset value) {
  if (options_case() != kPreset) {
    clear_options();
    set_has_preset();
  }
  _impl_.options_.preset_ = value;
  // @@protoc_insertion_point(field_set:livekit.ParticipantEgressRequest.preset)
}
inline ::livekit::EncodingOptionsPreset ParticipantEgressRequest::_internal_preset() const {
  if (options_case() == kPreset) {
    return static_cast<::livekit::EncodingOptionsPreset>(_impl_.options_.preset_);
  }
  return static_cast<::livekit::EncodingOptionsPreset>(0);
}

// .livekit.EncodingOptions advanced = 5;
inline bool ParticipantEgressRequest::has_advanced() const {
  return options_case() == kAdvanced;
}
inline bool ParticipantEgressRequest::_internal_has_advanced() const {
  return options_case() == kAdvanced;
}
inline void ParticipantEgressRequest::set_has_advanced() {
  _impl_._oneof_case_[0] = kAdvanced;
}
inline void ParticipantEgressRequest::clear_advanced() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (options_case() == kAdvanced) {
    if (GetArena() == nullptr) {
      delete _impl_.options_.advanced_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.options_.advanced_);
    }
    clear_has_options();
  }
}
inline ::livekit::EncodingOptions* PROTOBUF_NULLABLE ParticipantEgressRequest::release_advanced() {
  // @@protoc_insertion_point(field_release:livekit.ParticipantEgressRequest.advanced)
  if (options_case() == kAdvanced) {
    clear_has_options();
    auto* temp = _impl_.options_.advanced_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.options_.advanced_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::EncodingOptions& ParticipantEgressRequest::_internal_advanced() const {
  return options_case() == kAdvanced ? *_impl_.options_.advanced_ : reinterpret_cast<::livekit::EncodingOptions&>(::livekit::_EncodingOptions_default_instance_);
}
inline const ::livekit::EncodingOptions& ParticipantEgressRequest::advanced() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.ParticipantEgressRequest.advanced)
  return _internal_advanced();
}
inline ::livekit::EncodingOptions* PROTOBUF_NULLABLE ParticipantEgressRequest::unsafe_arena_release_advanced() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.ParticipantEgressRequest.advanced)
  if (options_case() == kAdvanced) {
    clear_has_options();
    auto* temp = _impl_.options_.advanced_;
    _impl_.options_.advanced_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ParticipantEgressRequest::unsafe_arena_set_allocated_advanced(
    ::livekit::EncodingOptions* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_options();
  if (value) {
    set_has_advanced();
    _impl_.options_.advanced_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.ParticipantEgressRequest.advanced)
}
inline ::livekit::EncodingOptions* PROTOBUF_NONNULL ParticipantEgressRequest::_internal_mutable_advanced() {
  if (options_case() != kAdvanced) {
    clear_options();
    set_has_advanced();
    _impl_.options_.advanced_ = 
        ::google::protobuf::Message::DefaultConstruct<::livekit::EncodingOptions>(GetArena());
  }
  return _impl_.options_.advanced_;
}
inline ::livekit::EncodingOptions* PROTOBUF_NONNULL ParticipantEgressRequest::mutable_advanced()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::EncodingOptions* _msg = _internal_mutable_advanced();
  // @@protoc_insertion_point(field_mutable:livekit.ParticipantEgressRequest.advanced)
  return _msg;
}

// repeated .livekit.EncodedFileOutput file_outputs = 6;
inline int ParticipantEgressRequest::_internal_file_outputs_size() const {
  return _internal_file_outputs().size();
}
inline int ParticipantEgressRequest::file_outputs_size() const {
  return _internal_file_outputs_size();
}
inline void ParticipantEgressRequest::clear_file_outputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.file_outputs_.Clear();
}
inline ::livekit::EncodedFileOutput* PROTOBUF_NONNULL ParticipantEgressRequest::mutable_file_outputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.ParticipantEgressRequest.file_outputs)
  return _internal_mutable_file_outputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::EncodedFileOutput>* PROTOBUF_NONNULL ParticipantEgressRequest::mutable_file_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.ParticipantEgressRequest.file_outputs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_file_outputs();
}
inline const ::livekit::EncodedFileOutput& ParticipantEgressRequest::file_outputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.ParticipantEgressRequest.file_outputs)
  return _internal_file_outputs().Get(index);
}
inline ::livekit::EncodedFileOutput* PROTOBUF_NONNULL ParticipantEgressRequest::add_file_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::EncodedFileOutput* _add = _internal_mutable_file_outputs()->Add();
  // @@protoc_insertion_point(field_add:livekit.ParticipantEgressRequest.file_outputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::EncodedFileOutput>& ParticipantEgressRequest::file_outputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.ParticipantEgressRequest.file_outputs)
  return _internal_file_outputs();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::EncodedFileOutput>&
ParticipantEgressRequest::_internal_file_outputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.file_outputs_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::EncodedFileOutput>* PROTOBUF_NONNULL
ParticipantEgressRequest::_internal_mutable_file_outputs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.file_outputs_;
}

// repeated .livekit.StreamOutput stream_outputs = 7;
inline int ParticipantEgressRequest::_internal_stream_outputs_size() const {
  return _internal_stream_outputs().size();
}
inline int ParticipantEgressRequest::stream_outputs_size() const {
  return _internal_stream_outputs_size();
}
inline void ParticipantEgressRequest::clear_stream_outputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stream_outputs_.Clear();
}
inline ::livekit::StreamOutput* PROTOBUF_NONNULL ParticipantEgressRequest::mutable_stream_outputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.ParticipantEgressRequest.stream_outputs)
  return _internal_mutable_stream_outputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::StreamOutput>* PROTOBUF_NONNULL ParticipantEgressRequest::mutable_stream_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.ParticipantEgressRequest.stream_outputs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_stream_outputs();
}
inline const ::livekit::StreamOutput& ParticipantEgressRequest::stream_outputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.ParticipantEgressRequest.stream_outputs)
  return _internal_stream_outputs().Get(index);
}
inline ::livekit::StreamOutput* PROTOBUF_NONNULL ParticipantEgressRequest::add_stream_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::StreamOutput* _add = _internal_mutable_stream_outputs()->Add();
  // @@protoc_insertion_point(field_add:livekit.ParticipantEgressRequest.stream_outputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::StreamOutput>& ParticipantEgressRequest::stream_outputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.ParticipantEgressRequest.stream_outputs)
  return _internal_stream_outputs();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::StreamOutput>&
ParticipantEgressRequest::_internal_stream_outputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stream_outputs_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::StreamOutput>* PROTOBUF_NONNULL
ParticipantEgressRequest::_internal_mutable_stream_outputs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.stream_outputs_;
}

// repeated .livekit.SegmentedFileOutput segment_outputs = 8;
inline int ParticipantEgressRequest::_internal_segment_outputs_size() const {
  return _internal_segment_outputs().size();
}
inline int ParticipantEgressRequest::segment_outputs_size() const {
  return _internal_segment_outputs_size();
}
inline void ParticipantEgressRequest::clear_segment_outputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.segment_outputs_.Clear();
}
inline ::livekit::SegmentedFileOutput* PROTOBUF_NONNULL ParticipantEgressRequest::mutable_segment_outputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.ParticipantEgressRequest.segment_outputs)
  return _internal_mutable_segment_outputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::SegmentedFileOutput>* PROTOBUF_NONNULL ParticipantEgressRequest::mutable_segment_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.ParticipantEgressRequest.segment_outputs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_segment_outputs();
}
inline const ::livekit::SegmentedFileOutput& ParticipantEgressRequest::segment_outputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.ParticipantEgressRequest.segment_outputs)
  return _internal_segment_outputs().Get(index);
}
inline ::livekit::SegmentedFileOutput* PROTOBUF_NONNULL ParticipantEgressRequest::add_segment_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::SegmentedFileOutput* _add = _internal_mutable_segment_outputs()->Add();
  // @@protoc_insertion_point(field_add:livekit.ParticipantEgressRequest.segment_outputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::SegmentedFileOutput>& ParticipantEgressRequest::segment_outputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.ParticipantEgressRequest.segment_outputs)
  return _internal_segment_outputs();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::SegmentedFileOutput>&
ParticipantEgressRequest::_internal_segment_outputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.segment_outputs_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::SegmentedFileOutput>* PROTOBUF_NONNULL
ParticipantEgressRequest::_internal_mutable_segment_outputs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.segment_outputs_;
}

// repeated .livekit.ImageOutput image_outputs = 9;
inline int ParticipantEgressRequest::_internal_image_outputs_size() const {
  return _internal_image_outputs().size();
}
inline int ParticipantEgressRequest::image_outputs_size() const {
  return _internal_image_outputs_size();
}
inline void ParticipantEgressRequest::clear_image_outputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.image_outputs_.Clear();
}
inline ::livekit::ImageOutput* PROTOBUF_NONNULL ParticipantEgressRequest::mutable_image_outputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.ParticipantEgressRequest.image_outputs)
  return _internal_mutable_image_outputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::ImageOutput>* PROTOBUF_NONNULL ParticipantEgressRequest::mutable_image_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.ParticipantEgressRequest.image_outputs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_image_outputs();
}
inline const ::livekit::ImageOutput& ParticipantEgressRequest::image_outputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.ParticipantEgressRequest.image_outputs)
  return _internal_image_outputs().Get(index);
}
inline ::livekit::ImageOutput* PROTOBUF_NONNULL ParticipantEgressRequest::add_image_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::ImageOutput* _add = _internal_mutable_image_outputs()->Add();
  // @@protoc_insertion_point(field_add:livekit.ParticipantEgressRequest.image_outputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::ImageOutput>& ParticipantEgressRequest::image_outputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.ParticipantEgressRequest.image_outputs)
  return _internal_image_outputs();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::ImageOutput>&
ParticipantEgressRequest::_internal_image_outputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.image_outputs_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::ImageOutput>* PROTOBUF_NONNULL
ParticipantEgressRequest::_internal_mutable_image_outputs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.image_outputs_;
}

inline bool ParticipantEgressRequest::has_options() const {
  return options_case() != OPTIONS_NOT_SET;
}
inline void ParticipantEgressRequest::clear_has_options() {
  _impl_._oneof_case_[0] = OPTIONS_NOT_SET;
}
inline ParticipantEgressRequest::OptionsCase ParticipantEgressRequest::options_case() const {
  return ParticipantEgressRequest::OptionsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// TrackCompositeEgressRequest

// string room_name = 1;
inline void TrackCompositeEgressRequest::clear_room_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.room_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TrackCompositeEgressRequest::room_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.TrackCompositeEgressRequest.room_name)
  return _internal_room_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void TrackCompositeEgressRequest::set_room_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.room_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.TrackCompositeEgressRequest.room_name)
}
inline std::string* PROTOBUF_NONNULL TrackCompositeEgressRequest::mutable_room_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_room_name();
  // @@protoc_insertion_point(field_mutable:livekit.TrackCompositeEgressRequest.room_name)
  return _s;
}
inline const std::string& TrackCompositeEgressRequest::_internal_room_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.room_name_.Get();
}
inline void TrackCompositeEgressRequest::_internal_set_room_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.room_name_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL TrackCompositeEgressRequest::_internal_mutable_room_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.room_name_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE TrackCompositeEgressRequest::release_room_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.TrackCompositeEgressRequest.room_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.room_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.room_name_.Set("", GetArena());
  }
  return released;
}
inline void TrackCompositeEgressRequest::set_allocated_room_name(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.room_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.room_name_.IsDefault()) {
    _impl_.room_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.TrackCompositeEgressRequest.room_name)
}

// string audio_track_id = 2;
inline void TrackCompositeEgressRequest::clear_audio_track_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.audio_track_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TrackCompositeEgressRequest::audio_track_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.TrackCompositeEgressRequest.audio_track_id)
  return _internal_audio_track_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void TrackCompositeEgressRequest::set_audio_track_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.audio_track_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.TrackCompositeEgressRequest.audio_track_id)
}
inline std::string* PROTOBUF_NONNULL TrackCompositeEgressRequest::mutable_audio_track_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_audio_track_id();
  // @@protoc_insertion_point(field_mutable:livekit.TrackCompositeEgressRequest.audio_track_id)
  return _s;
}
inline const std::string& TrackCompositeEgressRequest::_internal_audio_track_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.audio_track_id_.Get();
}
inline void TrackCompositeEgressRequest::_internal_set_audio_track_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.audio_track_id_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL TrackCompositeEgressRequest::_internal_mutable_audio_track_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.audio_track_id_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE TrackCompositeEgressRequest::release_audio_track_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.TrackCompositeEgressRequest.audio_track_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.audio_track_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.audio_track_id_.Set("", GetArena());
  }
  return released;
}
inline void TrackCompositeEgressRequest::set_allocated_audio_track_id(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.audio_track_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.audio_track_id_.IsDefault()) {
    _impl_.audio_track_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.TrackCompositeEgressRequest.audio_track_id)
}

// string video_track_id = 3;
inline void TrackCompositeEgressRequest::clear_video_track_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.video_track_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TrackCompositeEgressRequest::video_track_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.TrackCompositeEgressRequest.video_track_id)
  return _internal_video_track_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void TrackCompositeEgressRequest::set_video_track_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.video_track_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.TrackCompositeEgressRequest.video_track_id)
}
inline std::string* PROTOBUF_NONNULL TrackCompositeEgressRequest::mutable_video_track_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_video_track_id();
  // @@protoc_insertion_point(field_mutable:livekit.TrackCompositeEgressRequest.video_track_id)
  return _s;
}
inline const std::string& TrackCompositeEgressRequest::_internal_video_track_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.video_track_id_.Get();
}
inline void TrackCompositeEgressRequest::_internal_set_video_track_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.video_track_id_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL TrackCompositeEgressRequest::_internal_mutable_video_track_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.video_track_id_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE TrackCompositeEgressRequest::release_video_track_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.TrackCompositeEgressRequest.video_track_id)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.video_track_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.video_track_id_.Set("", GetArena());
  }
  return released;
}
inline void TrackCompositeEgressRequest::set_allocated_video_track_id(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.video_track_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.video_track_id_.IsDefault()) {
    _impl_.video_track_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.TrackCompositeEgressRequest.video_track_id)
}

// .livekit.EncodedFileOutput file = 4 [deprecated = true];
inline bool TrackCompositeEgressRequest::has_file() const {
  return output_case() == kFile;
}
inline bool TrackCompositeEgressRequest::_internal_has_file() const {
  return output_case() == kFile;
}
inline void TrackCompositeEgressRequest::set_has_file() {
  _impl_._oneof_case_[0] = kFile;
}
inline void TrackCompositeEgressRequest::clear_file() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (output_case() == kFile) {
    if (GetArena() == nullptr) {
      delete _impl_.output_.file_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.output_.file_);
    }
    clear_has_output();
  }
}
inline ::livekit::EncodedFileOutput* PROTOBUF_NULLABLE TrackCompositeEgressRequest::release_file() {
  // @@protoc_insertion_point(field_release:livekit.TrackCompositeEgressRequest.file)
  if (output_case() == kFile) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::EncodedFileOutput*>(_impl_.output_.file_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.file_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::EncodedFileOutput& TrackCompositeEgressRequest::_internal_file() const {
  return output_case() == kFile ? *reinterpret_cast<::livekit::EncodedFileOutput*>(_impl_.output_.file_) : reinterpret_cast<::livekit::EncodedFileOutput&>(::livekit::_EncodedFileOutput_default_instance_);
}
inline const ::livekit::EncodedFileOutput& TrackCompositeEgressRequest::file() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.TrackCompositeEgressRequest.file)
  return _internal_file();
}
inline ::livekit::EncodedFileOutput* PROTOBUF_NULLABLE TrackCompositeEgressRequest::unsafe_arena_release_file() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.TrackCompositeEgressRequest.file)
  if (output_case() == kFile) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::EncodedFileOutput*>(_impl_.output_.file_);
    _impl_.output_.file_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrackCompositeEgressRequest::unsafe_arena_set_allocated_file(
    ::livekit::EncodedFileOutput* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_output();
  if (value) {
    set_has_file();
    _impl_.output_.file_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.TrackCompositeEgressRequest.file)
}
inline ::livekit::EncodedFileOutput* PROTOBUF_NONNULL TrackCompositeEgressRequest::_internal_mutable_file() {
  if (output_case() != kFile) {
    clear_output();
    set_has_file();
    _impl_.output_.file_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::EncodedFileOutput>(GetArena()));
  }
  return reinterpret_cast<::livekit::EncodedFileOutput*>(_impl_.output_.file_);
}
inline ::livekit::EncodedFileOutput* PROTOBUF_NONNULL TrackCompositeEgressRequest::mutable_file()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::EncodedFileOutput* _msg = _internal_mutable_file();
  // @@protoc_insertion_point(field_mutable:livekit.TrackCompositeEgressRequest.file)
  return _msg;
}

// .livekit.StreamOutput stream = 5 [deprecated = true];
inline bool TrackCompositeEgressRequest::has_stream() const {
  return output_case() == kStream;
}
inline bool TrackCompositeEgressRequest::_internal_has_stream() const {
  return output_case() == kStream;
}
inline void TrackCompositeEgressRequest::set_has_stream() {
  _impl_._oneof_case_[0] = kStream;
}
inline void TrackCompositeEgressRequest::clear_stream() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (output_case() == kStream) {
    if (GetArena() == nullptr) {
      delete _impl_.output_.stream_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.output_.stream_);
    }
    clear_has_output();
  }
}
inline ::livekit::StreamOutput* PROTOBUF_NULLABLE TrackCompositeEgressRequest::release_stream() {
  // @@protoc_insertion_point(field_release:livekit.TrackCompositeEgressRequest.stream)
  if (output_case() == kStream) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::StreamOutput*>(_impl_.output_.stream_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.stream_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::StreamOutput& TrackCompositeEgressRequest::_internal_stream() const {
  return output_case() == kStream ? *reinterpret_cast<::livekit::StreamOutput*>(_impl_.output_.stream_) : reinterpret_cast<::livekit::StreamOutput&>(::livekit::_StreamOutput_default_instance_);
}
inline const ::livekit::StreamOutput& TrackCompositeEgressRequest::stream() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.TrackCompositeEgressRequest.stream)
  return _internal_stream();
}
inline ::livekit::StreamOutput* PROTOBUF_NULLABLE TrackCompositeEgressRequest::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.TrackCompositeEgressRequest.stream)
  if (output_case() == kStream) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::StreamOutput*>(_impl_.output_.stream_);
    _impl_.output_.stream_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrackCompositeEgressRequest::unsafe_arena_set_allocated_stream(
    ::livekit::StreamOutput* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_output();
  if (value) {
    set_has_stream();
    _impl_.output_.stream_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.TrackCompositeEgressRequest.stream)
}
inline ::livekit::StreamOutput* PROTOBUF_NONNULL TrackCompositeEgressRequest::_internal_mutable_stream() {
  if (output_case() != kStream) {
    clear_output();
    set_has_stream();
    _impl_.output_.stream_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::StreamOutput>(GetArena()));
  }
  return reinterpret_cast<::livekit::StreamOutput*>(_impl_.output_.stream_);
}
inline ::livekit::StreamOutput* PROTOBUF_NONNULL TrackCompositeEgressRequest::mutable_stream()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::StreamOutput* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:livekit.TrackCompositeEgressRequest.stream)
  return _msg;
}

// .livekit.SegmentedFileOutput segments = 8 [deprecated = true];
inline bool TrackCompositeEgressRequest::has_segments() const {
  return output_case() == kSegments;
}
inline bool TrackCompositeEgressRequest::_internal_has_segments() const {
  return output_case() == kSegments;
}
inline void TrackCompositeEgressRequest::set_has_segments() {
  _impl_._oneof_case_[0] = kSegments;
}
inline void TrackCompositeEgressRequest::clear_segments() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (output_case() == kSegments) {
    if (GetArena() == nullptr) {
      delete _impl_.output_.segments_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.output_.segments_);
    }
    clear_has_output();
  }
}
inline ::livekit::SegmentedFileOutput* PROTOBUF_NULLABLE TrackCompositeEgressRequest::release_segments() {
  // @@protoc_insertion_point(field_release:livekit.TrackCompositeEgressRequest.segments)
  if (output_case() == kSegments) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::SegmentedFileOutput*>(_impl_.output_.segments_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.segments_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::SegmentedFileOutput& TrackCompositeEgressRequest::_internal_segments() const {
  return output_case() == kSegments ? *reinterpret_cast<::livekit::SegmentedFileOutput*>(_impl_.output_.segments_) : reinterpret_cast<::livekit::SegmentedFileOutput&>(::livekit::_SegmentedFileOutput_default_instance_);
}
inline const ::livekit::SegmentedFileOutput& TrackCompositeEgressRequest::segments() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.TrackCompositeEgressRequest.segments)
  return _internal_segments();
}
inline ::livekit::SegmentedFileOutput* PROTOBUF_NULLABLE TrackCompositeEgressRequest::unsafe_arena_release_segments() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.TrackCompositeEgressRequest.segments)
  if (output_case() == kSegments) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::SegmentedFileOutput*>(_impl_.output_.segments_);
    _impl_.output_.segments_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrackCompositeEgressRequest::unsafe_arena_set_allocated_segments(
    ::livekit::SegmentedFileOutput* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_output();
  if (value) {
    set_has_segments();
    _impl_.output_.segments_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.TrackCompositeEgressRequest.segments)
}
inline ::livekit::SegmentedFileOutput* PROTOBUF_NONNULL TrackCompositeEgressRequest::_internal_mutable_segments() {
  if (output_case() != kSegments) {
    clear_output();
    set_has_segments();
    _impl_.output_.segments_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::SegmentedFileOutput>(GetArena()));
  }
  return reinterpret_cast<::livekit::SegmentedFileOutput*>(_impl_.output_.segments_);
}
inline ::livekit::SegmentedFileOutput* PROTOBUF_NONNULL TrackCompositeEgressRequest::mutable_segments()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::SegmentedFileOutput* _msg = _internal_mutable_segments();
  // @@protoc_insertion_point(field_mutable:livekit.TrackCompositeEgressRequest.segments)
  return _msg;
}

// .livekit.EncodingOptionsPreset preset = 6;
inline bool TrackCompositeEgressRequest::has_preset() const {
  return options_case() == kPreset;
}
inline void TrackCompositeEgressRequest::set_has_preset() {
  _impl_._oneof_case_[1] = kPreset;
}
inline void TrackCompositeEgressRequest::clear_preset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (options_case() == kPreset) {
    _impl_.options_.preset_ = 0;
    clear_has_options();
  }
}
inline ::livekit::EncodingOptionsPreset TrackCompositeEgressRequest::preset() const {
  // @@protoc_insertion_point(field_get:livekit.TrackCompositeEgressRequest.preset)
  return _internal_preset();
}
inline void TrackCompositeEgressRequest::set_preset(::livekit::EncodingOptionsPreset value) {
  if (options_case() != kPreset) {
    clear_options();
    set_has_preset();
  }
  _impl_.options_.preset_ = value;
  // @@protoc_insertion_point(field_set:livekit.TrackCompositeEgressRequest.preset)
}
inline ::livekit::EncodingOptionsPreset TrackCompositeEgressRequest::_internal_preset() const {
  if (options_case() == kPreset) {
    return static_cast<::livekit::EncodingOptionsPreset>(_impl_.options_.preset_);
  }
  return static_cast<::livekit::EncodingOptionsPreset>(0);
}

// .livekit.EncodingOptions advanced = 7;
inline bool TrackCompositeEgressRequest::has_advanced() const {
  return options_case() == kAdvanced;
}
inline bool TrackCompositeEgressRequest::_internal_has_advanced() const {
  return options_case() == kAdvanced;
}
inline void TrackCompositeEgressRequest::set_has_advanced() {
  _impl_._oneof_case_[1] = kAdvanced;
}
inline void TrackCompositeEgressRequest::clear_advanced() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (options_case() == kAdvanced) {
    if (GetArena() == nullptr) {
      delete _impl_.options_.advanced_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.options_.advanced_);
    }
    clear_has_options();
  }
}
inline ::livekit::EncodingOptions* PROTOBUF_NULLABLE TrackCompositeEgressRequest::release_advanced() {
  // @@protoc_insertion_point(field_release:livekit.TrackCompositeEgressRequest.advanced)
  if (options_case() == kAdvanced) {
    clear_has_options();
    auto* temp = _impl_.options_.advanced_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.options_.advanced_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::EncodingOptions& TrackCompositeEgressRequest::_internal_advanced() const {
  return options_case() == kAdvanced ? *_impl_.options_.advanced_ : reinterpret_cast<::livekit::EncodingOptions&>(::livekit::_EncodingOptions_default_instance_);
}
inline const ::livekit::EncodingOptions& TrackCompositeEgressRequest::advanced() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.TrackCompositeEgressRequest.advanced)
  return _internal_advanced();
}
inline ::livekit::EncodingOptions* PROTOBUF_NULLABLE TrackCompositeEgressRequest::unsafe_arena_release_advanced() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.TrackCompositeEgressRequest.advanced)
  if (options_case() == kAdvanced) {
    clear_has_options();
    auto* temp = _impl_.options_.advanced_;
    _impl_.options_.advanced_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrackCompositeEgressRequest::unsafe_arena_set_allocated_advanced(
    ::livekit::EncodingOptions* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_options();
  if (value) {
    set_has_advanced();
    _impl_.options_.advanced_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.TrackCompositeEgressRequest.advanced)
}
inline ::livekit::EncodingOptions* PROTOBUF_NONNULL TrackCompositeEgressRequest::_internal_mutable_advanced() {
  if (options_case() != kAdvanced) {
    clear_options();
    set_has_advanced();
    _impl_.options_.advanced_ = 
        ::google::protobuf::Message::DefaultConstruct<::livekit::EncodingOptions>(GetArena());
  }
  return _impl_.options_.advanced_;
}
inline ::livekit::EncodingOptions* PROTOBUF_NONNULL TrackCompositeEgressRequest::mutable_advanced()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::EncodingOptions* _msg = _internal_mutable_advanced();
  // @@protoc_insertion_point(field_mutable:livekit.TrackCompositeEgressRequest.advanced)
  return _msg;
}

// repeated .livekit.EncodedFileOutput file_outputs = 11;
inline int TrackCompositeEgressRequest::_internal_file_outputs_size() const {
  return _internal_file_outputs().size();
}
inline int TrackCompositeEgressRequest::file_outputs_size() const {
  return _internal_file_outputs_size();
}
inline void TrackCompositeEgressRequest::clear_file_outputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.file_outputs_.Clear();
}
inline ::livekit::EncodedFileOutput* PROTOBUF_NONNULL TrackCompositeEgressRequest::mutable_file_outputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.TrackCompositeEgressRequest.file_outputs)
  return _internal_mutable_file_outputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::EncodedFileOutput>* PROTOBUF_NONNULL TrackCompositeEgressRequest::mutable_file_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.TrackCompositeEgressRequest.file_outputs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_file_outputs();
}
inline const ::livekit::EncodedFileOutput& TrackCompositeEgressRequest::file_outputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.TrackCompositeEgressRequest.file_outputs)
  return _internal_file_outputs().Get(index);
}
inline ::livekit::EncodedFileOutput* PROTOBUF_NONNULL TrackCompositeEgressRequest::add_file_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::EncodedFileOutput* _add = _internal_mutable_file_outputs()->Add();
  // @@protoc_insertion_point(field_add:livekit.TrackCompositeEgressRequest.file_outputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::EncodedFileOutput>& TrackCompositeEgressRequest::file_outputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.TrackCompositeEgressRequest.file_outputs)
  return _internal_file_outputs();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::EncodedFileOutput>&
TrackCompositeEgressRequest::_internal_file_outputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.file_outputs_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::EncodedFileOutput>* PROTOBUF_NONNULL
TrackCompositeEgressRequest::_internal_mutable_file_outputs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.file_outputs_;
}

// repeated .livekit.StreamOutput stream_outputs = 12;
inline int TrackCompositeEgressRequest::_internal_stream_outputs_size() const {
  return _internal_stream_outputs().size();
}
inline int TrackCompositeEgressRequest::stream_outputs_size() const {
  return _internal_stream_outputs_size();
}
inline void TrackCompositeEgressRequest::clear_stream_outputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stream_outputs_.Clear();
}
inline ::livekit::StreamOutput* PROTOBUF_NONNULL TrackCompositeEgressRequest::mutable_stream_outputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.TrackCompositeEgressRequest.stream_outputs)
  return _internal_mutable_stream_outputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::StreamOutput>* PROTOBUF_NONNULL TrackCompositeEgressRequest::mutable_stream_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.TrackCompositeEgressRequest.stream_outputs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_stream_outputs();
}
inline const ::livekit::StreamOutput& TrackCompositeEgressRequest::stream_outputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.TrackCompositeEgressRequest.stream_outputs)
  return _internal_stream_outputs().Get(index);
}
inline ::livekit::StreamOutput* PROTOBUF_NONNULL TrackCompositeEgressRequest::add_stream_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::StreamOutput* _add = _internal_mutable_stream_outputs()->Add();
  // @@protoc_insertion_point(field_add:livekit.TrackCompositeEgressRequest.stream_outputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::StreamOutput>& TrackCompositeEgressRequest::stream_outputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.TrackCompositeEgressRequest.stream_outputs)
  return _internal_stream_outputs();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::StreamOutput>&
TrackCompositeEgressRequest::_internal_stream_outputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stream_outputs_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::StreamOutput>* PROTOBUF_NONNULL
TrackCompositeEgressRequest::_internal_mutable_stream_outputs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.stream_outputs_;
}

// repeated .livekit.SegmentedFileOutput segment_outputs = 13;
inline int TrackCompositeEgressRequest::_internal_segment_outputs_size() const {
  return _internal_segment_outputs().size();
}
inline int TrackCompositeEgressRequest::segment_outputs_size() const {
  return _internal_segment_outputs_size();
}
inline void TrackCompositeEgressRequest::clear_segment_outputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.segment_outputs_.Clear();
}
inline ::livekit::SegmentedFileOutput* PROTOBUF_NONNULL TrackCompositeEgressRequest::mutable_segment_outputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.TrackCompositeEgressRequest.segment_outputs)
  return _internal_mutable_segment_outputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::SegmentedFileOutput>* PROTOBUF_NONNULL TrackCompositeEgressRequest::mutable_segment_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.TrackCompositeEgressRequest.segment_outputs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_segment_outputs();
}
inline const ::livekit::SegmentedFileOutput& TrackCompositeEgressRequest::segment_outputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.TrackCompositeEgressRequest.segment_outputs)
  return _internal_segment_outputs().Get(index);
}
inline ::livekit::SegmentedFileOutput* PROTOBUF_NONNULL TrackCompositeEgressRequest::add_segment_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::SegmentedFileOutput* _add = _internal_mutable_segment_outputs()->Add();
  // @@protoc_insertion_point(field_add:livekit.TrackCompositeEgressRequest.segment_outputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::SegmentedFileOutput>& TrackCompositeEgressRequest::segment_outputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.TrackCompositeEgressRequest.segment_outputs)
  return _internal_segment_outputs();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::SegmentedFileOutput>&
TrackCompositeEgressRequest::_internal_segment_outputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.segment_outputs_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::SegmentedFileOutput>* PROTOBUF_NONNULL
TrackCompositeEgressRequest::_internal_mutable_segment_outputs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.segment_outputs_;
}

// repeated .livekit.ImageOutput image_outputs = 14;
inline int TrackCompositeEgressRequest::_internal_image_outputs_size() const {
  return _internal_image_outputs().size();
}
inline int TrackCompositeEgressRequest::image_outputs_size() const {
  return _internal_image_outputs_size();
}
inline void TrackCompositeEgressRequest::clear_image_outputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.image_outputs_.Clear();
}
inline ::livekit::ImageOutput* PROTOBUF_NONNULL TrackCompositeEgressRequest::mutable_image_outputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.TrackCompositeEgressRequest.image_outputs)
  return _internal_mutable_image_outputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::ImageOutput>* PROTOBUF_NONNULL TrackCompositeEgressRequest::mutable_image_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.TrackCompositeEgressRequest.image_outputs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_image_outputs();
}
inline const ::livekit::ImageOutput& TrackCompositeEgressRequest::image_outputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.TrackCompositeEgressRequest.image_outputs)
  return _internal_image_outputs().Get(index);
}
inline ::livekit::ImageOutput* PROTOBUF_NONNULL TrackCompositeEgressRequest::add_image_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::ImageOutput* _add = _internal_mutable_image_outputs()->Add();
  // @@protoc_insertion_point(field_add:livekit.TrackCompositeEgressRequest.image_outputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::ImageOutput>& TrackCompositeEgressRequest::image_outputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.TrackCompositeEgressRequest.image_outputs)
  return _internal_image_outputs();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::ImageOutput>&
TrackCompositeEgressRequest::_internal_image_outputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.image_outputs_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::ImageOutput>* PROTOBUF_NONNULL
TrackCompositeEgressRequest::_internal_mutable_image_outputs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.image_outputs_;
}

inline bool TrackCompositeEgressRequest::has_output() const {
  return output_case() != OUTPUT_NOT_SET;
}
inline void TrackCompositeEgressRequest::clear_has_output() {
  _impl_._oneof_case_[0] = OUTPUT_NOT_SET;
}
inline bool TrackCompositeEgressRequest::has_options() const {
  return options_case() != OPTIONS_NOT_SET;
}
inline void TrackCompositeEgressRequest::clear_has_options() {
  _impl_._oneof_case_[1] = OPTIONS_NOT_SET;
}
inline TrackCompositeEgressRequest::OutputCase TrackCompositeEgressRequest::output_case() const {
  return TrackCompositeEgressRequest::OutputCase(_impl_._oneof_case_[0]);
}
inline TrackCompositeEgressRequest::OptionsCase TrackCompositeEgressRequest::options_case() const {
  return TrackCompositeEgressRequest::OptionsCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// TrackEgressRequest

// string room_name = 1;
inline void TrackEgressRequest::clear_room_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.room_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TrackEgressRequest::room_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.TrackEgressRequest.room_name)
  return _internal_room_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void TrackEgressRequest::set_room_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.room_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.TrackEgressRequest.room_name)
}
inline std::string* PROTOBUF_NONNULL TrackEgressRequest::mutable_room_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_room_name();
  // @@protoc_insertion_point(field_mutable:livekit.TrackEgressRequest.room_name)
  return _s;
}
inline const std::string& TrackEgressRequest::_internal_room_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.room_name_.Get();
}
inline void TrackEgressRequest::_internal_set_room_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.room_name_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL TrackEgressRequest::_internal_mutable_room_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.room_name_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE TrackEgressRequest::release_room_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.TrackEgressRequest.room_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.room_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.room_name_.Set("", GetArena());
  }
  return released;
}
inline void TrackEgressRequest::set_allocated_room_name(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.room_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.room_name_.IsDefault()) {
    _impl_.room_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.TrackEgressRequest.room_name)
}

// string track_id = 2;
inline void TrackEgressRequest::clear_track_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.track_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TrackEgressRequest::track_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.TrackEgressRequest.track_id)
  return _internal_track_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void TrackEgressRequest::set_track_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.track_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.TrackEgressRequest.track_id)
}
inline std::string* PROTOBUF_NONNULL TrackEgressRequest::mutable_track_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_track_id();
  // @@protoc_insertion_point(field_mutable:livekit.TrackEgressRequest.track_id)
  return _s;
}
inline const std::string& TrackEgressRequest::_internal_track_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.track_id_.Get();
}
inline void TrackEgressRequest::_internal_set_track_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.track_id_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL TrackEgressRequest::_internal_mutable_track_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.track_id_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE TrackEgressRequest::release_track_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.TrackEgressRequest.track_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.track_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.track_id_.Set("", GetArena());
  }
  return released;
}
inline void TrackEgressRequest::set_allocated_track_id(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.track_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.track_id_.IsDefault()) {
    _impl_.track_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.TrackEgressRequest.track_id)
}

// .livekit.DirectFileOutput file = 3;
inline bool TrackEgressRequest::has_file() const {
  return output_case() == kFile;
}
inline bool TrackEgressRequest::_internal_has_file() const {
  return output_case() == kFile;
}
inline void TrackEgressRequest::set_has_file() {
  _impl_._oneof_case_[0] = kFile;
}
inline void TrackEgressRequest::clear_file() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (output_case() == kFile) {
    if (GetArena() == nullptr) {
      delete _impl_.output_.file_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.output_.file_);
    }
    clear_has_output();
  }
}
inline ::livekit::DirectFileOutput* PROTOBUF_NULLABLE TrackEgressRequest::release_file() {
  // @@protoc_insertion_point(field_release:livekit.TrackEgressRequest.file)
  if (output_case() == kFile) {
    clear_has_output();
    auto* temp = _impl_.output_.file_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.file_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::DirectFileOutput& TrackEgressRequest::_internal_file() const {
  return output_case() == kFile ? *_impl_.output_.file_ : reinterpret_cast<::livekit::DirectFileOutput&>(::livekit::_DirectFileOutput_default_instance_);
}
inline const ::livekit::DirectFileOutput& TrackEgressRequest::file() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.TrackEgressRequest.file)
  return _internal_file();
}
inline ::livekit::DirectFileOutput* PROTOBUF_NULLABLE TrackEgressRequest::unsafe_arena_release_file() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.TrackEgressRequest.file)
  if (output_case() == kFile) {
    clear_has_output();
    auto* temp = _impl_.output_.file_;
    _impl_.output_.file_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrackEgressRequest::unsafe_arena_set_allocated_file(
    ::livekit::DirectFileOutput* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_output();
  if (value) {
    set_has_file();
    _impl_.output_.file_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.TrackEgressRequest.file)
}
inline ::livekit::DirectFileOutput* PROTOBUF_NONNULL TrackEgressRequest::_internal_mutable_file() {
  if (output_case() != kFile) {
    clear_output();
    set_has_file();
    _impl_.output_.file_ = 
        ::google::protobuf::Message::DefaultConstruct<::livekit::DirectFileOutput>(GetArena());
  }
  return _impl_.output_.file_;
}
inline ::livekit::DirectFileOutput* PROTOBUF_NONNULL TrackEgressRequest::mutable_file()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::DirectFileOutput* _msg = _internal_mutable_file();
  // @@protoc_insertion_point(field_mutable:livekit.TrackEgressRequest.file)
  return _msg;
}

// string websocket_url = 4;
inline bool TrackEgressRequest::has_websocket_url() const {
  return output_case() == kWebsocketUrl;
}
inline void TrackEgressRequest::set_has_websocket_url() {
  _impl_._oneof_case_[0] = kWebsocketUrl;
}
inline void TrackEgressRequest::clear_websocket_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (output_case() == kWebsocketUrl) {
    _impl_.output_.websocket_url_.Destroy();
    clear_has_output();
  }
}
inline const std::string& TrackEgressRequest::websocket_url() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.TrackEgressRequest.websocket_url)
  return _internal_websocket_url();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void TrackEgressRequest::set_websocket_url(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (output_case() != kWebsocketUrl) {
    clear_output();

    set_has_websocket_url();
    _impl_.output_.websocket_url_.InitDefault();
  }
  _impl_.output_.websocket_url_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.TrackEgressRequest.websocket_url)
}
inline std::string* PROTOBUF_NONNULL TrackEgressRequest::mutable_websocket_url()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_websocket_url();
  // @@protoc_insertion_point(field_mutable:livekit.TrackEgressRequest.websocket_url)
  return _s;
}
inline const std::string& TrackEgressRequest::_internal_websocket_url() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (output_case() != kWebsocketUrl) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.output_.websocket_url_.Get();
}
inline void TrackEgressRequest::_internal_set_websocket_url(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (output_case() != kWebsocketUrl) {
    clear_output();

    set_has_websocket_url();
    _impl_.output_.websocket_url_.InitDefault();
  }
  _impl_.output_.websocket_url_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL TrackEgressRequest::_internal_mutable_websocket_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (output_case() != kWebsocketUrl) {
    clear_output();

    set_has_websocket_url();
    _impl_.output_.websocket_url_.InitDefault();
  }
  return _impl_.output_.websocket_url_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE TrackEgressRequest::release_websocket_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.TrackEgressRequest.websocket_url)
  if (output_case() != kWebsocketUrl) {
    return nullptr;
  }
  clear_has_output();
  return _impl_.output_.websocket_url_.Release();
}
inline void TrackEgressRequest::set_allocated_websocket_url(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_output()) {
    clear_output();
  }
  if (value != nullptr) {
    set_has_websocket_url();
    _impl_.output_.websocket_url_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.TrackEgressRequest.websocket_url)
}

inline bool TrackEgressRequest::has_output() const {
  return output_case() != OUTPUT_NOT_SET;
}
inline void TrackEgressRequest::clear_has_output() {
  _impl_._oneof_case_[0] = OUTPUT_NOT_SET;
}
inline TrackEgressRequest::OutputCase TrackEgressRequest::output_case() const {
  return TrackEgressRequest::OutputCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// EncodedFileOutput

// .livekit.EncodedFileType file_type = 1;
inline void EncodedFileOutput::clear_file_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.file_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::livekit::EncodedFileType EncodedFileOutput::file_type() const {
  // @@protoc_insertion_point(field_get:livekit.EncodedFileOutput.file_type)
  return _internal_file_type();
}
inline void EncodedFileOutput::set_file_type(::livekit::EncodedFileType value) {
  _internal_set_file_type(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:livekit.EncodedFileOutput.file_type)
}
inline ::livekit::EncodedFileType EncodedFileOutput::_internal_file_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::livekit::EncodedFileType>(_impl_.file_type_);
}
inline void EncodedFileOutput::_internal_set_file_type(::livekit::EncodedFileType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.file_type_ = value;
}

// string filepath = 2;
inline void EncodedFileOutput::clear_filepath() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filepath_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& EncodedFileOutput::filepath() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.EncodedFileOutput.filepath)
  return _internal_filepath();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void EncodedFileOutput::set_filepath(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.filepath_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.EncodedFileOutput.filepath)
}
inline std::string* PROTOBUF_NONNULL EncodedFileOutput::mutable_filepath()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_filepath();
  // @@protoc_insertion_point(field_mutable:livekit.EncodedFileOutput.filepath)
  return _s;
}
inline const std::string& EncodedFileOutput::_internal_filepath() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.filepath_.Get();
}
inline void EncodedFileOutput::_internal_set_filepath(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.filepath_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL EncodedFileOutput::_internal_mutable_filepath() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.filepath_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE EncodedFileOutput::release_filepath() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.EncodedFileOutput.filepath)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.filepath_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.filepath_.Set("", GetArena());
  }
  return released;
}
inline void EncodedFileOutput::set_allocated_filepath(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.filepath_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.filepath_.IsDefault()) {
    _impl_.filepath_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.EncodedFileOutput.filepath)
}

// bool disable_manifest = 6;
inline void EncodedFileOutput::clear_disable_manifest() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.disable_manifest_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool EncodedFileOutput::disable_manifest() const {
  // @@protoc_insertion_point(field_get:livekit.EncodedFileOutput.disable_manifest)
  return _internal_disable_manifest();
}
inline void EncodedFileOutput::set_disable_manifest(bool value) {
  _internal_set_disable_manifest(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:livekit.EncodedFileOutput.disable_manifest)
}
inline bool EncodedFileOutput::_internal_disable_manifest() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.disable_manifest_;
}
inline void EncodedFileOutput::_internal_set_disable_manifest(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.disable_manifest_ = value;
}

// .livekit.S3Upload s3 = 3;
inline bool EncodedFileOutput::has_s3() const {
  return output_case() == kS3;
}
inline bool EncodedFileOutput::_internal_has_s3() const {
  return output_case() == kS3;
}
inline void EncodedFileOutput::set_has_s3() {
  _impl_._oneof_case_[0] = kS3;
}
inline void EncodedFileOutput::clear_s3() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (output_case() == kS3) {
    if (GetArena() == nullptr) {
      delete _impl_.output_.s3_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.output_.s3_);
    }
    clear_has_output();
  }
}
inline ::livekit::S3Upload* PROTOBUF_NULLABLE EncodedFileOutput::release_s3() {
  // @@protoc_insertion_point(field_release:livekit.EncodedFileOutput.s3)
  if (output_case() == kS3) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::S3Upload*>(_impl_.output_.s3_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.s3_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::S3Upload& EncodedFileOutput::_internal_s3() const {
  return output_case() == kS3 ? *reinterpret_cast<::livekit::S3Upload*>(_impl_.output_.s3_) : reinterpret_cast<::livekit::S3Upload&>(::livekit::_S3Upload_default_instance_);
}
inline const ::livekit::S3Upload& EncodedFileOutput::s3() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.EncodedFileOutput.s3)
  return _internal_s3();
}
inline ::livekit::S3Upload* PROTOBUF_NULLABLE EncodedFileOutput::unsafe_arena_release_s3() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.EncodedFileOutput.s3)
  if (output_case() == kS3) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::S3Upload*>(_impl_.output_.s3_);
    _impl_.output_.s3_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EncodedFileOutput::unsafe_arena_set_allocated_s3(
    ::livekit::S3Upload* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_output();
  if (value) {
    set_has_s3();
    _impl_.output_.s3_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.EncodedFileOutput.s3)
}
inline ::livekit::S3Upload* PROTOBUF_NONNULL EncodedFileOutput::_internal_mutable_s3() {
  if (output_case() != kS3) {
    clear_output();
    set_has_s3();
    _impl_.output_.s3_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::S3Upload>(GetArena()));
  }
  return reinterpret_cast<::livekit::S3Upload*>(_impl_.output_.s3_);
}
inline ::livekit::S3Upload* PROTOBUF_NONNULL EncodedFileOutput::mutable_s3()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::S3Upload* _msg = _internal_mutable_s3();
  // @@protoc_insertion_point(field_mutable:livekit.EncodedFileOutput.s3)
  return _msg;
}

// .livekit.GCPUpload gcp = 4;
inline bool EncodedFileOutput::has_gcp() const {
  return output_case() == kGcp;
}
inline bool EncodedFileOutput::_internal_has_gcp() const {
  return output_case() == kGcp;
}
inline void EncodedFileOutput::set_has_gcp() {
  _impl_._oneof_case_[0] = kGcp;
}
inline void EncodedFileOutput::clear_gcp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (output_case() == kGcp) {
    if (GetArena() == nullptr) {
      delete _impl_.output_.gcp_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.output_.gcp_);
    }
    clear_has_output();
  }
}
inline ::livekit::GCPUpload* PROTOBUF_NULLABLE EncodedFileOutput::release_gcp() {
  // @@protoc_insertion_point(field_release:livekit.EncodedFileOutput.gcp)
  if (output_case() == kGcp) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::GCPUpload*>(_impl_.output_.gcp_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.gcp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::GCPUpload& EncodedFileOutput::_internal_gcp() const {
  return output_case() == kGcp ? *reinterpret_cast<::livekit::GCPUpload*>(_impl_.output_.gcp_) : reinterpret_cast<::livekit::GCPUpload&>(::livekit::_GCPUpload_default_instance_);
}
inline const ::livekit::GCPUpload& EncodedFileOutput::gcp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.EncodedFileOutput.gcp)
  return _internal_gcp();
}
inline ::livekit::GCPUpload* PROTOBUF_NULLABLE EncodedFileOutput::unsafe_arena_release_gcp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.EncodedFileOutput.gcp)
  if (output_case() == kGcp) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::GCPUpload*>(_impl_.output_.gcp_);
    _impl_.output_.gcp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EncodedFileOutput::unsafe_arena_set_allocated_gcp(
    ::livekit::GCPUpload* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_output();
  if (value) {
    set_has_gcp();
    _impl_.output_.gcp_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.EncodedFileOutput.gcp)
}
inline ::livekit::GCPUpload* PROTOBUF_NONNULL EncodedFileOutput::_internal_mutable_gcp() {
  if (output_case() != kGcp) {
    clear_output();
    set_has_gcp();
    _impl_.output_.gcp_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::GCPUpload>(GetArena()));
  }
  return reinterpret_cast<::livekit::GCPUpload*>(_impl_.output_.gcp_);
}
inline ::livekit::GCPUpload* PROTOBUF_NONNULL EncodedFileOutput::mutable_gcp()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::GCPUpload* _msg = _internal_mutable_gcp();
  // @@protoc_insertion_point(field_mutable:livekit.EncodedFileOutput.gcp)
  return _msg;
}

// .livekit.AzureBlobUpload azure = 5;
inline bool EncodedFileOutput::has_azure() const {
  return output_case() == kAzure;
}
inline bool EncodedFileOutput::_internal_has_azure() const {
  return output_case() == kAzure;
}
inline void EncodedFileOutput::set_has_azure() {
  _impl_._oneof_case_[0] = kAzure;
}
inline void EncodedFileOutput::clear_azure() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (output_case() == kAzure) {
    if (GetArena() == nullptr) {
      delete _impl_.output_.azure_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.output_.azure_);
    }
    clear_has_output();
  }
}
inline ::livekit::AzureBlobUpload* PROTOBUF_NULLABLE EncodedFileOutput::release_azure() {
  // @@protoc_insertion_point(field_release:livekit.EncodedFileOutput.azure)
  if (output_case() == kAzure) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::AzureBlobUpload*>(_impl_.output_.azure_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.azure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::AzureBlobUpload& EncodedFileOutput::_internal_azure() const {
  return output_case() == kAzure ? *reinterpret_cast<::livekit::AzureBlobUpload*>(_impl_.output_.azure_) : reinterpret_cast<::livekit::AzureBlobUpload&>(::livekit::_AzureBlobUpload_default_instance_);
}
inline const ::livekit::AzureBlobUpload& EncodedFileOutput::azure() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.EncodedFileOutput.azure)
  return _internal_azure();
}
inline ::livekit::AzureBlobUpload* PROTOBUF_NULLABLE EncodedFileOutput::unsafe_arena_release_azure() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.EncodedFileOutput.azure)
  if (output_case() == kAzure) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::AzureBlobUpload*>(_impl_.output_.azure_);
    _impl_.output_.azure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EncodedFileOutput::unsafe_arena_set_allocated_azure(
    ::livekit::AzureBlobUpload* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_output();
  if (value) {
    set_has_azure();
    _impl_.output_.azure_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.EncodedFileOutput.azure)
}
inline ::livekit::AzureBlobUpload* PROTOBUF_NONNULL EncodedFileOutput::_internal_mutable_azure() {
  if (output_case() != kAzure) {
    clear_output();
    set_has_azure();
    _impl_.output_.azure_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::AzureBlobUpload>(GetArena()));
  }
  return reinterpret_cast<::livekit::AzureBlobUpload*>(_impl_.output_.azure_);
}
inline ::livekit::AzureBlobUpload* PROTOBUF_NONNULL EncodedFileOutput::mutable_azure()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::AzureBlobUpload* _msg = _internal_mutable_azure();
  // @@protoc_insertion_point(field_mutable:livekit.EncodedFileOutput.azure)
  return _msg;
}

// .livekit.AliOSSUpload aliOSS = 7;
inline bool EncodedFileOutput::has_alioss() const {
  return output_case() == kAliOSS;
}
inline bool EncodedFileOutput::_internal_has_alioss() const {
  return output_case() == kAliOSS;
}
inline void EncodedFileOutput::set_has_alioss() {
  _impl_._oneof_case_[0] = kAliOSS;
}
inline void EncodedFileOutput::clear_alioss() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (output_case() == kAliOSS) {
    if (GetArena() == nullptr) {
      delete _impl_.output_.alioss_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.output_.alioss_);
    }
    clear_has_output();
  }
}
inline ::livekit::AliOSSUpload* PROTOBUF_NULLABLE EncodedFileOutput::release_alioss() {
  // @@protoc_insertion_point(field_release:livekit.EncodedFileOutput.aliOSS)
  if (output_case() == kAliOSS) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::AliOSSUpload*>(_impl_.output_.alioss_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.alioss_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::AliOSSUpload& EncodedFileOutput::_internal_alioss() const {
  return output_case() == kAliOSS ? *reinterpret_cast<::livekit::AliOSSUpload*>(_impl_.output_.alioss_) : reinterpret_cast<::livekit::AliOSSUpload&>(::livekit::_AliOSSUpload_default_instance_);
}
inline const ::livekit::AliOSSUpload& EncodedFileOutput::alioss() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.EncodedFileOutput.aliOSS)
  return _internal_alioss();
}
inline ::livekit::AliOSSUpload* PROTOBUF_NULLABLE EncodedFileOutput::unsafe_arena_release_alioss() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.EncodedFileOutput.aliOSS)
  if (output_case() == kAliOSS) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::AliOSSUpload*>(_impl_.output_.alioss_);
    _impl_.output_.alioss_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EncodedFileOutput::unsafe_arena_set_allocated_alioss(
    ::livekit::AliOSSUpload* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_output();
  if (value) {
    set_has_alioss();
    _impl_.output_.alioss_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.EncodedFileOutput.aliOSS)
}
inline ::livekit::AliOSSUpload* PROTOBUF_NONNULL EncodedFileOutput::_internal_mutable_alioss() {
  if (output_case() != kAliOSS) {
    clear_output();
    set_has_alioss();
    _impl_.output_.alioss_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::AliOSSUpload>(GetArena()));
  }
  return reinterpret_cast<::livekit::AliOSSUpload*>(_impl_.output_.alioss_);
}
inline ::livekit::AliOSSUpload* PROTOBUF_NONNULL EncodedFileOutput::mutable_alioss()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::AliOSSUpload* _msg = _internal_mutable_alioss();
  // @@protoc_insertion_point(field_mutable:livekit.EncodedFileOutput.aliOSS)
  return _msg;
}

inline bool EncodedFileOutput::has_output() const {
  return output_case() != OUTPUT_NOT_SET;
}
inline void EncodedFileOutput::clear_has_output() {
  _impl_._oneof_case_[0] = OUTPUT_NOT_SET;
}
inline EncodedFileOutput::OutputCase EncodedFileOutput::output_case() const {
  return EncodedFileOutput::OutputCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SegmentedFileOutput

// .livekit.SegmentedFileProtocol protocol = 1;
inline void SegmentedFileOutput::clear_protocol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.protocol_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::livekit::SegmentedFileProtocol SegmentedFileOutput::protocol() const {
  // @@protoc_insertion_point(field_get:livekit.SegmentedFileOutput.protocol)
  return _internal_protocol();
}
inline void SegmentedFileOutput::set_protocol(::livekit::SegmentedFileProtocol value) {
  _internal_set_protocol(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:livekit.SegmentedFileOutput.protocol)
}
inline ::livekit::SegmentedFileProtocol SegmentedFileOutput::_internal_protocol() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::livekit::SegmentedFileProtocol>(_impl_.protocol_);
}
inline void SegmentedFileOutput::_internal_set_protocol(::livekit::SegmentedFileProtocol value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.protocol_ = value;
}

// string filename_prefix = 2;
inline void SegmentedFileOutput::clear_filename_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filename_prefix_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SegmentedFileOutput::filename_prefix() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SegmentedFileOutput.filename_prefix)
  return _internal_filename_prefix();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SegmentedFileOutput::set_filename_prefix(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.filename_prefix_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.SegmentedFileOutput.filename_prefix)
}
inline std::string* PROTOBUF_NONNULL SegmentedFileOutput::mutable_filename_prefix()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_filename_prefix();
  // @@protoc_insertion_point(field_mutable:livekit.SegmentedFileOutput.filename_prefix)
  return _s;
}
inline const std::string& SegmentedFileOutput::_internal_filename_prefix() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.filename_prefix_.Get();
}
inline void SegmentedFileOutput::_internal_set_filename_prefix(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.filename_prefix_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL SegmentedFileOutput::_internal_mutable_filename_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.filename_prefix_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE SegmentedFileOutput::release_filename_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.SegmentedFileOutput.filename_prefix)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.filename_prefix_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.filename_prefix_.Set("", GetArena());
  }
  return released;
}
inline void SegmentedFileOutput::set_allocated_filename_prefix(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.filename_prefix_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.filename_prefix_.IsDefault()) {
    _impl_.filename_prefix_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.SegmentedFileOutput.filename_prefix)
}

// string playlist_name = 3;
inline void SegmentedFileOutput::clear_playlist_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.playlist_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SegmentedFileOutput::playlist_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SegmentedFileOutput.playlist_name)
  return _internal_playlist_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SegmentedFileOutput::set_playlist_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.playlist_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.SegmentedFileOutput.playlist_name)
}
inline std::string* PROTOBUF_NONNULL SegmentedFileOutput::mutable_playlist_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_playlist_name();
  // @@protoc_insertion_point(field_mutable:livekit.SegmentedFileOutput.playlist_name)
  return _s;
}
inline const std::string& SegmentedFileOutput::_internal_playlist_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.playlist_name_.Get();
}
inline void SegmentedFileOutput::_internal_set_playlist_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.playlist_name_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL SegmentedFileOutput::_internal_mutable_playlist_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.playlist_name_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE SegmentedFileOutput::release_playlist_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.SegmentedFileOutput.playlist_name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.playlist_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.playlist_name_.Set("", GetArena());
  }
  return released;
}
inline void SegmentedFileOutput::set_allocated_playlist_name(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.playlist_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.playlist_name_.IsDefault()) {
    _impl_.playlist_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.SegmentedFileOutput.playlist_name)
}

// string live_playlist_name = 11;
inline void SegmentedFileOutput::clear_live_playlist_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.live_playlist_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SegmentedFileOutput::live_playlist_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SegmentedFileOutput.live_playlist_name)
  return _internal_live_playlist_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SegmentedFileOutput::set_live_playlist_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.live_playlist_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.SegmentedFileOutput.live_playlist_name)
}
inline std::string* PROTOBUF_NONNULL SegmentedFileOutput::mutable_live_playlist_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_live_playlist_name();
  // @@protoc_insertion_point(field_mutable:livekit.SegmentedFileOutput.live_playlist_name)
  return _s;
}
inline const std::string& SegmentedFileOutput::_internal_live_playlist_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.live_playlist_name_.Get();
}
inline void SegmentedFileOutput::_internal_set_live_playlist_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.live_playlist_name_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL SegmentedFileOutput::_internal_mutable_live_playlist_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.live_playlist_name_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE SegmentedFileOutput::release_live_playlist_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.SegmentedFileOutput.live_playlist_name)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.live_playlist_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.live_playlist_name_.Set("", GetArena());
  }
  return released;
}
inline void SegmentedFileOutput::set_allocated_live_playlist_name(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.live_playlist_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.live_playlist_name_.IsDefault()) {
    _impl_.live_playlist_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.SegmentedFileOutput.live_playlist_name)
}

// uint32 segment_duration = 4;
inline void SegmentedFileOutput::clear_segment_duration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.segment_duration_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t SegmentedFileOutput::segment_duration() const {
  // @@protoc_insertion_point(field_get:livekit.SegmentedFileOutput.segment_duration)
  return _internal_segment_duration();
}
inline void SegmentedFileOutput::set_segment_duration(::uint32_t value) {
  _internal_set_segment_duration(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:livekit.SegmentedFileOutput.segment_duration)
}
inline ::uint32_t SegmentedFileOutput::_internal_segment_duration() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.segment_duration_;
}
inline void SegmentedFileOutput::_internal_set_segment_duration(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.segment_duration_ = value;
}

// .livekit.SegmentedFileSuffix filename_suffix = 10;
inline void SegmentedFileOutput::clear_filename_suffix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filename_suffix_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::livekit::SegmentedFileSuffix SegmentedFileOutput::filename_suffix() const {
  // @@protoc_insertion_point(field_get:livekit.SegmentedFileOutput.filename_suffix)
  return _internal_filename_suffix();
}
inline void SegmentedFileOutput::set_filename_suffix(::livekit::SegmentedFileSuffix value) {
  _internal_set_filename_suffix(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:livekit.SegmentedFileOutput.filename_suffix)
}
inline ::livekit::SegmentedFileSuffix SegmentedFileOutput::_internal_filename_suffix() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::livekit::SegmentedFileSuffix>(_impl_.filename_suffix_);
}
inline void SegmentedFileOutput::_internal_set_filename_suffix(::livekit::SegmentedFileSuffix value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filename_suffix_ = value;
}

// bool disable_manifest = 8;
inline void SegmentedFileOutput::clear_disable_manifest() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.disable_manifest_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool SegmentedFileOutput::disable_manifest() const {
  // @@protoc_insertion_point(field_get:livekit.SegmentedFileOutput.disable_manifest)
  return _internal_disable_manifest();
}
inline void SegmentedFileOutput::set_disable_manifest(bool value) {
  _internal_set_disable_manifest(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:livekit.SegmentedFileOutput.disable_manifest)
}
inline bool SegmentedFileOutput::_internal_disable_manifest() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.disable_manifest_;
}
inline void SegmentedFileOutput::_internal_set_disable_manifest(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.disable_manifest_ = value;
}

// .livekit.S3Upload s3 = 5;
inline bool SegmentedFileOutput::has_s3() const {
  return output_case() == kS3;
}
inline bool SegmentedFileOutput::_internal_has_s3() const {
  return output_case() == kS3;
}
inline void SegmentedFileOutput::set_has_s3() {
  _impl_._oneof_case_[0] = kS3;
}
inline void SegmentedFileOutput::clear_s3() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (output_case() == kS3) {
    if (GetArena() == nullptr) {
      delete _impl_.output_.s3_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.output_.s3_);
    }
    clear_has_output();
  }
}
inline ::livekit::S3Upload* PROTOBUF_NULLABLE SegmentedFileOutput::release_s3() {
  // @@protoc_insertion_point(field_release:livekit.SegmentedFileOutput.s3)
  if (output_case() == kS3) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::S3Upload*>(_impl_.output_.s3_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.s3_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::S3Upload& SegmentedFileOutput::_internal_s3() const {
  return output_case() == kS3 ? *reinterpret_cast<::livekit::S3Upload*>(_impl_.output_.s3_) : reinterpret_cast<::livekit::S3Upload&>(::livekit::_S3Upload_default_instance_);
}
inline const ::livekit::S3Upload& SegmentedFileOutput::s3() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SegmentedFileOutput.s3)
  return _internal_s3();
}
inline ::livekit::S3Upload* PROTOBUF_NULLABLE SegmentedFileOutput::unsafe_arena_release_s3() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SegmentedFileOutput.s3)
  if (output_case() == kS3) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::S3Upload*>(_impl_.output_.s3_);
    _impl_.output_.s3_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SegmentedFileOutput::unsafe_arena_set_allocated_s3(
    ::livekit::S3Upload* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_output();
  if (value) {
    set_has_s3();
    _impl_.output_.s3_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SegmentedFileOutput.s3)
}
inline ::livekit::S3Upload* PROTOBUF_NONNULL SegmentedFileOutput::_internal_mutable_s3() {
  if (output_case() != kS3) {
    clear_output();
    set_has_s3();
    _impl_.output_.s3_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::S3Upload>(GetArena()));
  }
  return reinterpret_cast<::livekit::S3Upload*>(_impl_.output_.s3_);
}
inline ::livekit::S3Upload* PROTOBUF_NONNULL SegmentedFileOutput::mutable_s3()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::S3Upload* _msg = _internal_mutable_s3();
  // @@protoc_insertion_point(field_mutable:livekit.SegmentedFileOutput.s3)
  return _msg;
}

// .livekit.GCPUpload gcp = 6;
inline bool SegmentedFileOutput::has_gcp() const {
  return output_case() == kGcp;
}
inline bool SegmentedFileOutput::_internal_has_gcp() const {
  return output_case() == kGcp;
}
inline void SegmentedFileOutput::set_has_gcp() {
  _impl_._oneof_case_[0] = kGcp;
}
inline void SegmentedFileOutput::clear_gcp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (output_case() == kGcp) {
    if (GetArena() == nullptr) {
      delete _impl_.output_.gcp_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.output_.gcp_);
    }
    clear_has_output();
  }
}
inline ::livekit::GCPUpload* PROTOBUF_NULLABLE SegmentedFileOutput::release_gcp() {
  // @@protoc_insertion_point(field_release:livekit.SegmentedFileOutput.gcp)
  if (output_case() == kGcp) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::GCPUpload*>(_impl_.output_.gcp_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.gcp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::GCPUpload& SegmentedFileOutput::_internal_gcp() const {
  return output_case() == kGcp ? *reinterpret_cast<::livekit::GCPUpload*>(_impl_.output_.gcp_) : reinterpret_cast<::livekit::GCPUpload&>(::livekit::_GCPUpload_default_instance_);
}
inline const ::livekit::GCPUpload& SegmentedFileOutput::gcp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SegmentedFileOutput.gcp)
  return _internal_gcp();
}
inline ::livekit::GCPUpload* PROTOBUF_NULLABLE SegmentedFileOutput::unsafe_arena_release_gcp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SegmentedFileOutput.gcp)
  if (output_case() == kGcp) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::GCPUpload*>(_impl_.output_.gcp_);
    _impl_.output_.gcp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SegmentedFileOutput::unsafe_arena_set_allocated_gcp(
    ::livekit::GCPUpload* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_output();
  if (value) {
    set_has_gcp();
    _impl_.output_.gcp_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SegmentedFileOutput.gcp)
}
inline ::livekit::GCPUpload* PROTOBUF_NONNULL SegmentedFileOutput::_internal_mutable_gcp() {
  if (output_case() != kGcp) {
    clear_output();
    set_has_gcp();
    _impl_.output_.gcp_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::GCPUpload>(GetArena()));
  }
  return reinterpret_cast<::livekit::GCPUpload*>(_impl_.output_.gcp_);
}
inline ::livekit::GCPUpload* PROTOBUF_NONNULL SegmentedFileOutput::mutable_gcp()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::GCPUpload* _msg = _internal_mutable_gcp();
  // @@protoc_insertion_point(field_mutable:livekit.SegmentedFileOutput.gcp)
  return _msg;
}

// .livekit.AzureBlobUpload azure = 7;
inline bool SegmentedFileOutput::has_azure() const {
  return output_case() == kAzure;
}
inline bool SegmentedFileOutput::_internal_has_azure() const {
  return output_case() == kAzure;
}
inline void SegmentedFileOutput::set_has_azure() {
  _impl_._oneof_case_[0] = kAzure;
}
inline void SegmentedFileOutput::clear_azure() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (output_case() == kAzure) {
    if (GetArena() == nullptr) {
      delete _impl_.output_.azure_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.output_.azure_);
    }
    clear_has_output();
  }
}
inline ::livekit::AzureBlobUpload* PROTOBUF_NULLABLE SegmentedFileOutput::release_azure() {
  // @@protoc_insertion_point(field_release:livekit.SegmentedFileOutput.azure)
  if (output_case() == kAzure) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::AzureBlobUpload*>(_impl_.output_.azure_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.azure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::AzureBlobUpload& SegmentedFileOutput::_internal_azure() const {
  return output_case() == kAzure ? *reinterpret_cast<::livekit::AzureBlobUpload*>(_impl_.output_.azure_) : reinterpret_cast<::livekit::AzureBlobUpload&>(::livekit::_AzureBlobUpload_default_instance_);
}
inline const ::livekit::AzureBlobUpload& SegmentedFileOutput::azure() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SegmentedFileOutput.azure)
  return _internal_azure();
}
inline ::livekit::AzureBlobUpload* PROTOBUF_NULLABLE SegmentedFileOutput::unsafe_arena_release_azure() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SegmentedFileOutput.azure)
  if (output_case() == kAzure) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::AzureBlobUpload*>(_impl_.output_.azure_);
    _impl_.output_.azure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SegmentedFileOutput::unsafe_arena_set_allocated_azure(
    ::livekit::AzureBlobUpload* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_output();
  if (value) {
    set_has_azure();
    _impl_.output_.azure_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SegmentedFileOutput.azure)
}
inline ::livekit::AzureBlobUpload* PROTOBUF_NONNULL SegmentedFileOutput::_internal_mutable_azure() {
  if (output_case() != kAzure) {
    clear_output();
    set_has_azure();
    _impl_.output_.azure_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::AzureBlobUpload>(GetArena()));
  }
  return reinterpret_cast<::livekit::AzureBlobUpload*>(_impl_.output_.azure_);
}
inline ::livekit::AzureBlobUpload* PROTOBUF_NONNULL SegmentedFileOutput::mutable_azure()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::AzureBlobUpload* _msg = _internal_mutable_azure();
  // @@protoc_insertion_point(field_mutable:livekit.SegmentedFileOutput.azure)
  return _msg;
}

// .livekit.AliOSSUpload aliOSS = 9;
inline bool SegmentedFileOutput::has_alioss() const {
  return output_case() == kAliOSS;
}
inline bool SegmentedFileOutput::_internal_has_alioss() const {
  return output_case() == kAliOSS;
}
inline void SegmentedFileOutput::set_has_alioss() {
  _impl_._oneof_case_[0] = kAliOSS;
}
inline void SegmentedFileOutput::clear_alioss() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (output_case() == kAliOSS) {
    if (GetArena() == nullptr) {
      delete _impl_.output_.alioss_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.output_.alioss_);
    }
    clear_has_output();
  }
}
inline ::livekit::AliOSSUpload* PROTOBUF_NULLABLE SegmentedFileOutput::release_alioss() {
  // @@protoc_insertion_point(field_release:livekit.SegmentedFileOutput.aliOSS)
  if (output_case() == kAliOSS) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::AliOSSUpload*>(_impl_.output_.alioss_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.alioss_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::AliOSSUpload& SegmentedFileOutput::_internal_alioss() const {
  return output_case() == kAliOSS ? *reinterpret_cast<::livekit::AliOSSUpload*>(_impl_.output_.alioss_) : reinterpret_cast<::livekit::AliOSSUpload&>(::livekit::_AliOSSUpload_default_instance_);
}
inline const ::livekit::AliOSSUpload& SegmentedFileOutput::alioss() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SegmentedFileOutput.aliOSS)
  return _internal_alioss();
}
inline ::livekit::AliOSSUpload* PROTOBUF_NULLABLE SegmentedFileOutput::unsafe_arena_release_alioss() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SegmentedFileOutput.aliOSS)
  if (output_case() == kAliOSS) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::AliOSSUpload*>(_impl_.output_.alioss_);
    _impl_.output_.alioss_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SegmentedFileOutput::unsafe_arena_set_allocated_alioss(
    ::livekit::AliOSSUpload* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_output();
  if (value) {
    set_has_alioss();
    _impl_.output_.alioss_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SegmentedFileOutput.aliOSS)
}
inline ::livekit::AliOSSUpload* PROTOBUF_NONNULL SegmentedFileOutput::_internal_mutable_alioss() {
  if (output_case() != kAliOSS) {
    clear_output();
    set_has_alioss();
    _impl_.output_.alioss_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::AliOSSUpload>(GetArena()));
  }
  return reinterpret_cast<::livekit::AliOSSUpload*>(_impl_.output_.alioss_);
}
inline ::livekit::AliOSSUpload* PROTOBUF_NONNULL SegmentedFileOutput::mutable_alioss()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::AliOSSUpload* _msg = _internal_mutable_alioss();
  // @@protoc_insertion_point(field_mutable:livekit.SegmentedFileOutput.aliOSS)
  return _msg;
}

inline bool SegmentedFileOutput::has_output() const {
  return output_case() != OUTPUT_NOT_SET;
}
inline void SegmentedFileOutput::clear_has_output() {
  _impl_._oneof_case_[0] = OUTPUT_NOT_SET;
}
inline SegmentedFileOutput::OutputCase SegmentedFileOutput::output_case() const {
  return SegmentedFileOutput::OutputCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// DirectFileOutput

// string filepath = 1;
inline void DirectFileOutput::clear_filepath() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filepath_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DirectFileOutput::filepath() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.DirectFileOutput.filepath)
  return _internal_filepath();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DirectFileOutput::set_filepath(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.filepath_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.DirectFileOutput.filepath)
}
inline std::string* PROTOBUF_NONNULL DirectFileOutput::mutable_filepath()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_filepath();
  // @@protoc_insertion_point(field_mutable:livekit.DirectFileOutput.filepath)
  return _s;
}
inline const std::string& DirectFileOutput::_internal_filepath() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.filepath_.Get();
}
inline void DirectFileOutput::_internal_set_filepath(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.filepath_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL DirectFileOutput::_internal_mutable_filepath() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.filepath_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE DirectFileOutput::release_filepath() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.DirectFileOutput.filepath)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.filepath_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.filepath_.Set("", GetArena());
  }
  return released;
}
inline void DirectFileOutput::set_allocated_filepath(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.filepath_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.filepath_.IsDefault()) {
    _impl_.filepath_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.DirectFileOutput.filepath)
}

// bool disable_manifest = 5;
inline void DirectFileOutput::clear_disable_manifest() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.disable_manifest_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool DirectFileOutput::disable_manifest() const {
  // @@protoc_insertion_point(field_get:livekit.DirectFileOutput.disable_manifest)
  return _internal_disable_manifest();
}
inline void DirectFileOutput::set_disable_manifest(bool value) {
  _internal_set_disable_manifest(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:livekit.DirectFileOutput.disable_manifest)
}
inline bool DirectFileOutput::_internal_disable_manifest() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.disable_manifest_;
}
inline void DirectFileOutput::_internal_set_disable_manifest(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.disable_manifest_ = value;
}

// .livekit.S3Upload s3 = 2;
inline bool DirectFileOutput::has_s3() const {
  return output_case() == kS3;
}
inline bool DirectFileOutput::_internal_has_s3() const {
  return output_case() == kS3;
}
inline void DirectFileOutput::set_has_s3() {
  _impl_._oneof_case_[0] = kS3;
}
inline void DirectFileOutput::clear_s3() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (output_case() == kS3) {
    if (GetArena() == nullptr) {
      delete _impl_.output_.s3_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.output_.s3_);
    }
    clear_has_output();
  }
}
inline ::livekit::S3Upload* PROTOBUF_NULLABLE DirectFileOutput::release_s3() {
  // @@protoc_insertion_point(field_release:livekit.DirectFileOutput.s3)
  if (output_case() == kS3) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::S3Upload*>(_impl_.output_.s3_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.s3_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::S3Upload& DirectFileOutput::_internal_s3() const {
  return output_case() == kS3 ? *reinterpret_cast<::livekit::S3Upload*>(_impl_.output_.s3_) : reinterpret_cast<::livekit::S3Upload&>(::livekit::_S3Upload_default_instance_);
}
inline const ::livekit::S3Upload& DirectFileOutput::s3() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.DirectFileOutput.s3)
  return _internal_s3();
}
inline ::livekit::S3Upload* PROTOBUF_NULLABLE DirectFileOutput::unsafe_arena_release_s3() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.DirectFileOutput.s3)
  if (output_case() == kS3) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::S3Upload*>(_impl_.output_.s3_);
    _impl_.output_.s3_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DirectFileOutput::unsafe_arena_set_allocated_s3(
    ::livekit::S3Upload* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_output();
  if (value) {
    set_has_s3();
    _impl_.output_.s3_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.DirectFileOutput.s3)
}
inline ::livekit::S3Upload* PROTOBUF_NONNULL DirectFileOutput::_internal_mutable_s3() {
  if (output_case() != kS3) {
    clear_output();
    set_has_s3();
    _impl_.output_.s3_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::S3Upload>(GetArena()));
  }
  return reinterpret_cast<::livekit::S3Upload*>(_impl_.output_.s3_);
}
inline ::livekit::S3Upload* PROTOBUF_NONNULL DirectFileOutput::mutable_s3()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::S3Upload* _msg = _internal_mutable_s3();
  // @@protoc_insertion_point(field_mutable:livekit.DirectFileOutput.s3)
  return _msg;
}

// .livekit.GCPUpload gcp = 3;
inline bool DirectFileOutput::has_gcp() const {
  return output_case() == kGcp;
}
inline bool DirectFileOutput::_internal_has_gcp() const {
  return output_case() == kGcp;
}
inline void DirectFileOutput::set_has_gcp() {
  _impl_._oneof_case_[0] = kGcp;
}
inline void DirectFileOutput::clear_gcp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (output_case() == kGcp) {
    if (GetArena() == nullptr) {
      delete _impl_.output_.gcp_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.output_.gcp_);
    }
    clear_has_output();
  }
}
inline ::livekit::GCPUpload* PROTOBUF_NULLABLE DirectFileOutput::release_gcp() {
  // @@protoc_insertion_point(field_release:livekit.DirectFileOutput.gcp)
  if (output_case() == kGcp) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::GCPUpload*>(_impl_.output_.gcp_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.gcp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::GCPUpload& DirectFileOutput::_internal_gcp() const {
  return output_case() == kGcp ? *reinterpret_cast<::livekit::GCPUpload*>(_impl_.output_.gcp_) : reinterpret_cast<::livekit::GCPUpload&>(::livekit::_GCPUpload_default_instance_);
}
inline const ::livekit::GCPUpload& DirectFileOutput::gcp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.DirectFileOutput.gcp)
  return _internal_gcp();
}
inline ::livekit::GCPUpload* PROTOBUF_NULLABLE DirectFileOutput::unsafe_arena_release_gcp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.DirectFileOutput.gcp)
  if (output_case() == kGcp) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::GCPUpload*>(_impl_.output_.gcp_);
    _impl_.output_.gcp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DirectFileOutput::unsafe_arena_set_allocated_gcp(
    ::livekit::GCPUpload* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_output();
  if (value) {
    set_has_gcp();
    _impl_.output_.gcp_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.DirectFileOutput.gcp)
}
inline ::livekit::GCPUpload* PROTOBUF_NONNULL DirectFileOutput::_internal_mutable_gcp() {
  if (output_case() != kGcp) {
    clear_output();
    set_has_gcp();
    _impl_.output_.gcp_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::GCPUpload>(GetArena()));
  }
  return reinterpret_cast<::livekit::GCPUpload*>(_impl_.output_.gcp_);
}
inline ::livekit::GCPUpload* PROTOBUF_NONNULL DirectFileOutput::mutable_gcp()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::GCPUpload* _msg = _internal_mutable_gcp();
  // @@protoc_insertion_point(field_mutable:livekit.DirectFileOutput.gcp)
  return _msg;
}

// .livekit.AzureBlobUpload azure = 4;
inline bool DirectFileOutput::has_azure() const {
  return output_case() == kAzure;
}
inline bool DirectFileOutput::_internal_has_azure() const {
  return output_case() == kAzure;
}
inline void DirectFileOutput::set_has_azure() {
  _impl_._oneof_case_[0] = kAzure;
}
inline void DirectFileOutput::clear_azure() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (output_case() == kAzure) {
    if (GetArena() == nullptr) {
      delete _impl_.output_.azure_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.output_.azure_);
    }
    clear_has_output();
  }
}
inline ::livekit::AzureBlobUpload* PROTOBUF_NULLABLE DirectFileOutput::release_azure() {
  // @@protoc_insertion_point(field_release:livekit.DirectFileOutput.azure)
  if (output_case() == kAzure) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::AzureBlobUpload*>(_impl_.output_.azure_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.azure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::AzureBlobUpload& DirectFileOutput::_internal_azure() const {
  return output_case() == kAzure ? *reinterpret_cast<::livekit::AzureBlobUpload*>(_impl_.output_.azure_) : reinterpret_cast<::livekit::AzureBlobUpload&>(::livekit::_AzureBlobUpload_default_instance_);
}
inline const ::livekit::AzureBlobUpload& DirectFileOutput::azure() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.DirectFileOutput.azure)
  return _internal_azure();
}
inline ::livekit::AzureBlobUpload* PROTOBUF_NULLABLE DirectFileOutput::unsafe_arena_release_azure() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.DirectFileOutput.azure)
  if (output_case() == kAzure) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::AzureBlobUpload*>(_impl_.output_.azure_);
    _impl_.output_.azure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DirectFileOutput::unsafe_arena_set_allocated_azure(
    ::livekit::AzureBlobUpload* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_output();
  if (value) {
    set_has_azure();
    _impl_.output_.azure_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.DirectFileOutput.azure)
}
inline ::livekit::AzureBlobUpload* PROTOBUF_NONNULL DirectFileOutput::_internal_mutable_azure() {
  if (output_case() != kAzure) {
    clear_output();
    set_has_azure();
    _impl_.output_.azure_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::AzureBlobUpload>(GetArena()));
  }
  return reinterpret_cast<::livekit::AzureBlobUpload*>(_impl_.output_.azure_);
}
inline ::livekit::AzureBlobUpload* PROTOBUF_NONNULL DirectFileOutput::mutable_azure()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::AzureBlobUpload* _msg = _internal_mutable_azure();
  // @@protoc_insertion_point(field_mutable:livekit.DirectFileOutput.azure)
  return _msg;
}

// .livekit.AliOSSUpload aliOSS = 6;
inline bool DirectFileOutput::has_alioss() const {
  return output_case() == kAliOSS;
}
inline bool DirectFileOutput::_internal_has_alioss() const {
  return output_case() == kAliOSS;
}
inline void DirectFileOutput::set_has_alioss() {
  _impl_._oneof_case_[0] = kAliOSS;
}
inline void DirectFileOutput::clear_alioss() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (output_case() == kAliOSS) {
    if (GetArena() == nullptr) {
      delete _impl_.output_.alioss_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.output_.alioss_);
    }
    clear_has_output();
  }
}
inline ::livekit::AliOSSUpload* PROTOBUF_NULLABLE DirectFileOutput::release_alioss() {
  // @@protoc_insertion_point(field_release:livekit.DirectFileOutput.aliOSS)
  if (output_case() == kAliOSS) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::AliOSSUpload*>(_impl_.output_.alioss_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.alioss_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::AliOSSUpload& DirectFileOutput::_internal_alioss() const {
  return output_case() == kAliOSS ? *reinterpret_cast<::livekit::AliOSSUpload*>(_impl_.output_.alioss_) : reinterpret_cast<::livekit::AliOSSUpload&>(::livekit::_AliOSSUpload_default_instance_);
}
inline const ::livekit::AliOSSUpload& DirectFileOutput::alioss() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.DirectFileOutput.aliOSS)
  return _internal_alioss();
}
inline ::livekit::AliOSSUpload* PROTOBUF_NULLABLE DirectFileOutput::unsafe_arena_release_alioss() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.DirectFileOutput.aliOSS)
  if (output_case() == kAliOSS) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::AliOSSUpload*>(_impl_.output_.alioss_);
    _impl_.output_.alioss_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DirectFileOutput::unsafe_arena_set_allocated_alioss(
    ::livekit::AliOSSUpload* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_output();
  if (value) {
    set_has_alioss();
    _impl_.output_.alioss_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.DirectFileOutput.aliOSS)
}
inline ::livekit::AliOSSUpload* PROTOBUF_NONNULL DirectFileOutput::_internal_mutable_alioss() {
  if (output_case() != kAliOSS) {
    clear_output();
    set_has_alioss();
    _impl_.output_.alioss_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::AliOSSUpload>(GetArena()));
  }
  return reinterpret_cast<::livekit::AliOSSUpload*>(_impl_.output_.alioss_);
}
inline ::livekit::AliOSSUpload* PROTOBUF_NONNULL DirectFileOutput::mutable_alioss()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::AliOSSUpload* _msg = _internal_mutable_alioss();
  // @@protoc_insertion_point(field_mutable:livekit.DirectFileOutput.aliOSS)
  return _msg;
}

inline bool DirectFileOutput::has_output() const {
  return output_case() != OUTPUT_NOT_SET;
}
inline void DirectFileOutput::clear_has_output() {
  _impl_._oneof_case_[0] = OUTPUT_NOT_SET;
}
inline DirectFileOutput::OutputCase DirectFileOutput::output_case() const {
  return DirectFileOutput::OutputCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ImageOutput

// uint32 capture_interval = 1;
inline void ImageOutput::clear_capture_interval() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.capture_interval_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t ImageOutput::capture_interval() const {
  // @@protoc_insertion_point(field_get:livekit.ImageOutput.capture_interval)
  return _internal_capture_interval();
}
inline void ImageOutput::set_capture_interval(::uint32_t value) {
  _internal_set_capture_interval(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:livekit.ImageOutput.capture_interval)
}
inline ::uint32_t ImageOutput::_internal_capture_interval() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.capture_interval_;
}
inline void ImageOutput::_internal_set_capture_interval(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.capture_interval_ = value;
}

// int32 width = 2;
inline void ImageOutput::clear_width() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t ImageOutput::width() const {
  // @@protoc_insertion_point(field_get:livekit.ImageOutput.width)
  return _internal_width();
}
inline void ImageOutput::set_width(::int32_t value) {
  _internal_set_width(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:livekit.ImageOutput.width)
}
inline ::int32_t ImageOutput::_internal_width() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.width_;
}
inline void ImageOutput::_internal_set_width(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_ = value;
}

// int32 height = 3;
inline void ImageOutput::clear_height() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t ImageOutput::height() const {
  // @@protoc_insertion_point(field_get:livekit.ImageOutput.height)
  return _internal_height();
}
inline void ImageOutput::set_height(::int32_t value) {
  _internal_set_height(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:livekit.ImageOutput.height)
}
inline ::int32_t ImageOutput::_internal_height() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.height_;
}
inline void ImageOutput::_internal_set_height(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = value;
}

// string filename_prefix = 4;
inline void ImageOutput::clear_filename_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filename_prefix_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ImageOutput::filename_prefix() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.ImageOutput.filename_prefix)
  return _internal_filename_prefix();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ImageOutput::set_filename_prefix(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.filename_prefix_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.ImageOutput.filename_prefix)
}
inline std::string* PROTOBUF_NONNULL ImageOutput::mutable_filename_prefix()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_filename_prefix();
  // @@protoc_insertion_point(field_mutable:livekit.ImageOutput.filename_prefix)
  return _s;
}
inline const std::string& ImageOutput::_internal_filename_prefix() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.filename_prefix_.Get();
}
inline void ImageOutput::_internal_set_filename_prefix(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.filename_prefix_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL ImageOutput::_internal_mutable_filename_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.filename_prefix_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE ImageOutput::release_filename_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.ImageOutput.filename_prefix)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.filename_prefix_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.filename_prefix_.Set("", GetArena());
  }
  return released;
}
inline void ImageOutput::set_allocated_filename_prefix(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.filename_prefix_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.filename_prefix_.IsDefault()) {
    _impl_.filename_prefix_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.ImageOutput.filename_prefix)
}

// .livekit.ImageFileSuffix filename_suffix = 5;
inline void ImageOutput::clear_filename_suffix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filename_suffix_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::livekit::ImageFileSuffix ImageOutput::filename_suffix() const {
  // @@protoc_insertion_point(field_get:livekit.ImageOutput.filename_suffix)
  return _internal_filename_suffix();
}
inline void ImageOutput::set_filename_suffix(::livekit::ImageFileSuffix value) {
  _internal_set_filename_suffix(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:livekit.ImageOutput.filename_suffix)
}
inline ::livekit::ImageFileSuffix ImageOutput::_internal_filename_suffix() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::livekit::ImageFileSuffix>(_impl_.filename_suffix_);
}
inline void ImageOutput::_internal_set_filename_suffix(::livekit::ImageFileSuffix value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filename_suffix_ = value;
}

// .livekit.ImageCodec image_codec = 6;
inline void ImageOutput::clear_image_codec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.image_codec_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::livekit::ImageCodec ImageOutput::image_codec() const {
  // @@protoc_insertion_point(field_get:livekit.ImageOutput.image_codec)
  return _internal_image_codec();
}
inline void ImageOutput::set_image_codec(::livekit::ImageCodec value) {
  _internal_set_image_codec(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:livekit.ImageOutput.image_codec)
}
inline ::livekit::ImageCodec ImageOutput::_internal_image_codec() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::livekit::ImageCodec>(_impl_.image_codec_);
}
inline void ImageOutput::_internal_set_image_codec(::livekit::ImageCodec value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.image_codec_ = value;
}

// bool disable_manifest = 7;
inline void ImageOutput::clear_disable_manifest() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.disable_manifest_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool ImageOutput::disable_manifest() const {
  // @@protoc_insertion_point(field_get:livekit.ImageOutput.disable_manifest)
  return _internal_disable_manifest();
}
inline void ImageOutput::set_disable_manifest(bool value) {
  _internal_set_disable_manifest(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:livekit.ImageOutput.disable_manifest)
}
inline bool ImageOutput::_internal_disable_manifest() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.disable_manifest_;
}
inline void ImageOutput::_internal_set_disable_manifest(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.disable_manifest_ = value;
}

// .livekit.S3Upload s3 = 8;
inline bool ImageOutput::has_s3() const {
  return output_case() == kS3;
}
inline bool ImageOutput::_internal_has_s3() const {
  return output_case() == kS3;
}
inline void ImageOutput::set_has_s3() {
  _impl_._oneof_case_[0] = kS3;
}
inline void ImageOutput::clear_s3() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (output_case() == kS3) {
    if (GetArena() == nullptr) {
      delete _impl_.output_.s3_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.output_.s3_);
    }
    clear_has_output();
  }
}
inline ::livekit::S3Upload* PROTOBUF_NULLABLE ImageOutput::release_s3() {
  // @@protoc_insertion_point(field_release:livekit.ImageOutput.s3)
  if (output_case() == kS3) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::S3Upload*>(_impl_.output_.s3_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.s3_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::S3Upload& ImageOutput::_internal_s3() const {
  return output_case() == kS3 ? *reinterpret_cast<::livekit::S3Upload*>(_impl_.output_.s3_) : reinterpret_cast<::livekit::S3Upload&>(::livekit::_S3Upload_default_instance_);
}
inline const ::livekit::S3Upload& ImageOutput::s3() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.ImageOutput.s3)
  return _internal_s3();
}
inline ::livekit::S3Upload* PROTOBUF_NULLABLE ImageOutput::unsafe_arena_release_s3() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.ImageOutput.s3)
  if (output_case() == kS3) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::S3Upload*>(_impl_.output_.s3_);
    _impl_.output_.s3_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ImageOutput::unsafe_arena_set_allocated_s3(
    ::livekit::S3Upload* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_output();
  if (value) {
    set_has_s3();
    _impl_.output_.s3_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.ImageOutput.s3)
}
inline ::livekit::S3Upload* PROTOBUF_NONNULL ImageOutput::_internal_mutable_s3() {
  if (output_case() != kS3) {
    clear_output();
    set_has_s3();
    _impl_.output_.s3_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::S3Upload>(GetArena()));
  }
  return reinterpret_cast<::livekit::S3Upload*>(_impl_.output_.s3_);
}
inline ::livekit::S3Upload* PROTOBUF_NONNULL ImageOutput::mutable_s3()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::S3Upload* _msg = _internal_mutable_s3();
  // @@protoc_insertion_point(field_mutable:livekit.ImageOutput.s3)
  return _msg;
}

// .livekit.GCPUpload gcp = 9;
inline bool ImageOutput::has_gcp() const {
  return output_case() == kGcp;
}
inline bool ImageOutput::_internal_has_gcp() const {
  return output_case() == kGcp;
}
inline void ImageOutput::set_has_gcp() {
  _impl_._oneof_case_[0] = kGcp;
}
inline void ImageOutput::clear_gcp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (output_case() == kGcp) {
    if (GetArena() == nullptr) {
      delete _impl_.output_.gcp_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.output_.gcp_);
    }
    clear_has_output();
  }
}
inline ::livekit::GCPUpload* PROTOBUF_NULLABLE ImageOutput::release_gcp() {
  // @@protoc_insertion_point(field_release:livekit.ImageOutput.gcp)
  if (output_case() == kGcp) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::GCPUpload*>(_impl_.output_.gcp_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.gcp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::GCPUpload& ImageOutput::_internal_gcp() const {
  return output_case() == kGcp ? *reinterpret_cast<::livekit::GCPUpload*>(_impl_.output_.gcp_) : reinterpret_cast<::livekit::GCPUpload&>(::livekit::_GCPUpload_default_instance_);
}
inline const ::livekit::GCPUpload& ImageOutput::gcp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.ImageOutput.gcp)
  return _internal_gcp();
}
inline ::livekit::GCPUpload* PROTOBUF_NULLABLE ImageOutput::unsafe_arena_release_gcp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.ImageOutput.gcp)
  if (output_case() == kGcp) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::GCPUpload*>(_impl_.output_.gcp_);
    _impl_.output_.gcp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ImageOutput::unsafe_arena_set_allocated_gcp(
    ::livekit::GCPUpload* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_output();
  if (value) {
    set_has_gcp();
    _impl_.output_.gcp_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.ImageOutput.gcp)
}
inline ::livekit::GCPUpload* PROTOBUF_NONNULL ImageOutput::_internal_mutable_gcp() {
  if (output_case() != kGcp) {
    clear_output();
    set_has_gcp();
    _impl_.output_.gcp_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::GCPUpload>(GetArena()));
  }
  return reinterpret_cast<::livekit::GCPUpload*>(_impl_.output_.gcp_);
}
inline ::livekit::GCPUpload* PROTOBUF_NONNULL ImageOutput::mutable_gcp()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::GCPUpload* _msg = _internal_mutable_gcp();
  // @@protoc_insertion_point(field_mutable:livekit.ImageOutput.gcp)
  return _msg;
}

// .livekit.AzureBlobUpload azure = 10;
inline bool ImageOutput::has_azure() const {
  return output_case() == kAzure;
}
inline bool ImageOutput::_internal_has_azure() const {
  return output_case() == kAzure;
}
inline void ImageOutput::set_has_azure() {
  _impl_._oneof_case_[0] = kAzure;
}
inline void ImageOutput::clear_azure() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (output_case() == kAzure) {
    if (GetArena() == nullptr) {
      delete _impl_.output_.azure_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.output_.azure_);
    }
    clear_has_output();
  }
}
inline ::livekit::AzureBlobUpload* PROTOBUF_NULLABLE ImageOutput::release_azure() {
  // @@protoc_insertion_point(field_release:livekit.ImageOutput.azure)
  if (output_case() == kAzure) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::AzureBlobUpload*>(_impl_.output_.azure_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.azure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::AzureBlobUpload& ImageOutput::_internal_azure() const {
  return output_case() == kAzure ? *reinterpret_cast<::livekit::AzureBlobUpload*>(_impl_.output_.azure_) : reinterpret_cast<::livekit::AzureBlobUpload&>(::livekit::_AzureBlobUpload_default_instance_);
}
inline const ::livekit::AzureBlobUpload& ImageOutput::azure() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.ImageOutput.azure)
  return _internal_azure();
}
inline ::livekit::AzureBlobUpload* PROTOBUF_NULLABLE ImageOutput::unsafe_arena_release_azure() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.ImageOutput.azure)
  if (output_case() == kAzure) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::AzureBlobUpload*>(_impl_.output_.azure_);
    _impl_.output_.azure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ImageOutput::unsafe_arena_set_allocated_azure(
    ::livekit::AzureBlobUpload* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_output();
  if (value) {
    set_has_azure();
    _impl_.output_.azure_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.ImageOutput.azure)
}
inline ::livekit::AzureBlobUpload* PROTOBUF_NONNULL ImageOutput::_internal_mutable_azure() {
  if (output_case() != kAzure) {
    clear_output();
    set_has_azure();
    _impl_.output_.azure_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::AzureBlobUpload>(GetArena()));
  }
  return reinterpret_cast<::livekit::AzureBlobUpload*>(_impl_.output_.azure_);
}
inline ::livekit::AzureBlobUpload* PROTOBUF_NONNULL ImageOutput::mutable_azure()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::AzureBlobUpload* _msg = _internal_mutable_azure();
  // @@protoc_insertion_point(field_mutable:livekit.ImageOutput.azure)
  return _msg;
}

// .livekit.AliOSSUpload aliOSS = 11;
inline bool ImageOutput::has_alioss() const {
  return output_case() == kAliOSS;
}
inline bool ImageOutput::_internal_has_alioss() const {
  return output_case() == kAliOSS;
}
inline void ImageOutput::set_has_alioss() {
  _impl_._oneof_case_[0] = kAliOSS;
}
inline void ImageOutput::clear_alioss() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (output_case() == kAliOSS) {
    if (GetArena() == nullptr) {
      delete _impl_.output_.alioss_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.output_.alioss_);
    }
    clear_has_output();
  }
}
inline ::livekit::AliOSSUpload* PROTOBUF_NULLABLE ImageOutput::release_alioss() {
  // @@protoc_insertion_point(field_release:livekit.ImageOutput.aliOSS)
  if (output_case() == kAliOSS) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::AliOSSUpload*>(_impl_.output_.alioss_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.alioss_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::AliOSSUpload& ImageOutput::_internal_alioss() const {
  return output_case() == kAliOSS ? *reinterpret_cast<::livekit::AliOSSUpload*>(_impl_.output_.alioss_) : reinterpret_cast<::livekit::AliOSSUpload&>(::livekit::_AliOSSUpload_default_instance_);
}
inline const ::livekit::AliOSSUpload& ImageOutput::alioss() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.ImageOutput.aliOSS)
  return _internal_alioss();
}
inline ::livekit::AliOSSUpload* PROTOBUF_NULLABLE ImageOutput::unsafe_arena_release_alioss() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.ImageOutput.aliOSS)
  if (output_case() == kAliOSS) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::AliOSSUpload*>(_impl_.output_.alioss_);
    _impl_.output_.alioss_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ImageOutput::unsafe_arena_set_allocated_alioss(
    ::livekit::AliOSSUpload* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_output();
  if (value) {
    set_has_alioss();
    _impl_.output_.alioss_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.ImageOutput.aliOSS)
}
inline ::livekit::AliOSSUpload* PROTOBUF_NONNULL ImageOutput::_internal_mutable_alioss() {
  if (output_case() != kAliOSS) {
    clear_output();
    set_has_alioss();
    _impl_.output_.alioss_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::AliOSSUpload>(GetArena()));
  }
  return reinterpret_cast<::livekit::AliOSSUpload*>(_impl_.output_.alioss_);
}
inline ::livekit::AliOSSUpload* PROTOBUF_NONNULL ImageOutput::mutable_alioss()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::AliOSSUpload* _msg = _internal_mutable_alioss();
  // @@protoc_insertion_point(field_mutable:livekit.ImageOutput.aliOSS)
  return _msg;
}

inline bool ImageOutput::has_output() const {
  return output_case() != OUTPUT_NOT_SET;
}
inline void ImageOutput::clear_has_output() {
  _impl_._oneof_case_[0] = OUTPUT_NOT_SET;
}
inline ImageOutput::OutputCase ImageOutput::output_case() const {
  return ImageOutput::OutputCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// S3Upload

// string access_key = 1;
inline void S3Upload::clear_access_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.access_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& S3Upload::access_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.S3Upload.access_key)
  return _internal_access_key();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void S3Upload::set_access_key(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.access_key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.S3Upload.access_key)
}
inline std::string* PROTOBUF_NONNULL S3Upload::mutable_access_key()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_access_key();
  // @@protoc_insertion_point(field_mutable:livekit.S3Upload.access_key)
  return _s;
}
inline const std::string& S3Upload::_internal_access_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.access_key_.Get();
}
inline void S3Upload::_internal_set_access_key(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.access_key_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL S3Upload::_internal_mutable_access_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.access_key_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE S3Upload::release_access_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.S3Upload.access_key)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.access_key_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.access_key_.Set("", GetArena());
  }
  return released;
}
inline void S3Upload::set_allocated_access_key(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.access_key_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.access_key_.IsDefault()) {
    _impl_.access_key_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.S3Upload.access_key)
}

// string secret = 2;
inline void S3Upload::clear_secret() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secret_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& S3Upload::secret() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.S3Upload.secret)
  return _internal_secret();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void S3Upload::set_secret(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.secret_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.S3Upload.secret)
}
inline std::string* PROTOBUF_NONNULL S3Upload::mutable_secret()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_secret();
  // @@protoc_insertion_point(field_mutable:livekit.S3Upload.secret)
  return _s;
}
inline const std::string& S3Upload::_internal_secret() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.secret_.Get();
}
inline void S3Upload::_internal_set_secret(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.secret_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL S3Upload::_internal_mutable_secret() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.secret_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE S3Upload::release_secret() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.S3Upload.secret)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.secret_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.secret_.Set("", GetArena());
  }
  return released;
}
inline void S3Upload::set_allocated_secret(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.secret_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.secret_.IsDefault()) {
    _impl_.secret_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.S3Upload.secret)
}

// string session_token = 11;
inline void S3Upload::clear_session_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& S3Upload::session_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.S3Upload.session_token)
  return _internal_session_token();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void S3Upload::set_session_token(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.session_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.S3Upload.session_token)
}
inline std::string* PROTOBUF_NONNULL S3Upload::mutable_session_token()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_session_token();
  // @@protoc_insertion_point(field_mutable:livekit.S3Upload.session_token)
  return _s;
}
inline const std::string& S3Upload::_internal_session_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.session_token_.Get();
}
inline void S3Upload::_internal_set_session_token(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.session_token_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL S3Upload::_internal_mutable_session_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.session_token_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE S3Upload::release_session_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.S3Upload.session_token)
  if ((_impl_._has_bits_[0] & 0x00000080u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* released = _impl_.session_token_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.session_token_.Set("", GetArena());
  }
  return released;
}
inline void S3Upload::set_allocated_session_token(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.session_token_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.session_token_.IsDefault()) {
    _impl_.session_token_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.S3Upload.session_token)
}

// string region = 3;
inline void S3Upload::clear_region() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.region_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& S3Upload::region() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.S3Upload.region)
  return _internal_region();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void S3Upload::set_region(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.region_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.S3Upload.region)
}
inline std::string* PROTOBUF_NONNULL S3Upload::mutable_region()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:livekit.S3Upload.region)
  return _s;
}
inline const std::string& S3Upload::_internal_region() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.region_.Get();
}
inline void S3Upload::_internal_set_region(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.region_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL S3Upload::_internal_mutable_region() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.region_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE S3Upload::release_region() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.S3Upload.region)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.region_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.region_.Set("", GetArena());
  }
  return released;
}
inline void S3Upload::set_allocated_region(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.region_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.region_.IsDefault()) {
    _impl_.region_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.S3Upload.region)
}

// string endpoint = 4;
inline void S3Upload::clear_endpoint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.endpoint_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& S3Upload::endpoint() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.S3Upload.endpoint)
  return _internal_endpoint();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void S3Upload::set_endpoint(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.endpoint_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.S3Upload.endpoint)
}
inline std::string* PROTOBUF_NONNULL S3Upload::mutable_endpoint()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_endpoint();
  // @@protoc_insertion_point(field_mutable:livekit.S3Upload.endpoint)
  return _s;
}
inline const std::string& S3Upload::_internal_endpoint() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.endpoint_.Get();
}
inline void S3Upload::_internal_set_endpoint(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.endpoint_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL S3Upload::_internal_mutable_endpoint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.endpoint_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE S3Upload::release_endpoint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.S3Upload.endpoint)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.endpoint_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.endpoint_.Set("", GetArena());
  }
  return released;
}
inline void S3Upload::set_allocated_endpoint(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.endpoint_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.endpoint_.IsDefault()) {
    _impl_.endpoint_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.S3Upload.endpoint)
}

// string bucket = 5;
inline void S3Upload::clear_bucket() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bucket_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& S3Upload::bucket() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.S3Upload.bucket)
  return _internal_bucket();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void S3Upload::set_bucket(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.bucket_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.S3Upload.bucket)
}
inline std::string* PROTOBUF_NONNULL S3Upload::mutable_bucket()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_bucket();
  // @@protoc_insertion_point(field_mutable:livekit.S3Upload.bucket)
  return _s;
}
inline const std::string& S3Upload::_internal_bucket() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bucket_.Get();
}
inline void S3Upload::_internal_set_bucket(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.bucket_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL S3Upload::_internal_mutable_bucket() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.bucket_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE S3Upload::release_bucket() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.S3Upload.bucket)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.bucket_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.bucket_.Set("", GetArena());
  }
  return released;
}
inline void S3Upload::set_allocated_bucket(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.bucket_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.bucket_.IsDefault()) {
    _impl_.bucket_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.S3Upload.bucket)
}

// bool force_path_style = 6;
inline void S3Upload::clear_force_path_style() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.force_path_style_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool S3Upload::force_path_style() const {
  // @@protoc_insertion_point(field_get:livekit.S3Upload.force_path_style)
  return _internal_force_path_style();
}
inline void S3Upload::set_force_path_style(bool value) {
  _internal_set_force_path_style(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:livekit.S3Upload.force_path_style)
}
inline bool S3Upload::_internal_force_path_style() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.force_path_style_;
}
inline void S3Upload::_internal_set_force_path_style(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.force_path_style_ = value;
}

// map<string, string> metadata = 7;
inline int S3Upload::_internal_metadata_size() const {
  return _internal_metadata().size();
}
inline int S3Upload::metadata_size() const {
  return _internal_metadata_size();
}
inline void S3Upload::clear_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& S3Upload::_internal_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& S3Upload::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:livekit.S3Upload.metadata)
  return _internal_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* PROTOBUF_NONNULL S3Upload::_internal_mutable_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* PROTOBUF_NONNULL S3Upload::mutable_metadata()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:livekit.S3Upload.metadata)
  return _internal_mutable_metadata();
}

// string tagging = 8;
inline void S3Upload::clear_tagging() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tagging_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& S3Upload::tagging() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.S3Upload.tagging)
  return _internal_tagging();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void S3Upload::set_tagging(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.tagging_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.S3Upload.tagging)
}
inline std::string* PROTOBUF_NONNULL S3Upload::mutable_tagging()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_tagging();
  // @@protoc_insertion_point(field_mutable:livekit.S3Upload.tagging)
  return _s;
}
inline const std::string& S3Upload::_internal_tagging() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tagging_.Get();
}
inline void S3Upload::_internal_set_tagging(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.tagging_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL S3Upload::_internal_mutable_tagging() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.tagging_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE S3Upload::release_tagging() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.S3Upload.tagging)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.tagging_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.tagging_.Set("", GetArena());
  }
  return released;
}
inline void S3Upload::set_allocated_tagging(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.tagging_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.tagging_.IsDefault()) {
    _impl_.tagging_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.S3Upload.tagging)
}

// string content_disposition = 9;
inline void S3Upload::clear_content_disposition() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.content_disposition_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& S3Upload::content_disposition() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.S3Upload.content_disposition)
  return _internal_content_disposition();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void S3Upload::set_content_disposition(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.content_disposition_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.S3Upload.content_disposition)
}
inline std::string* PROTOBUF_NONNULL S3Upload::mutable_content_disposition()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_content_disposition();
  // @@protoc_insertion_point(field_mutable:livekit.S3Upload.content_disposition)
  return _s;
}
inline const std::string& S3Upload::_internal_content_disposition() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.content_disposition_.Get();
}
inline void S3Upload::_internal_set_content_disposition(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.content_disposition_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL S3Upload::_internal_mutable_content_disposition() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.content_disposition_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE S3Upload::release_content_disposition() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.S3Upload.content_disposition)
  if ((_impl_._has_bits_[0] & 0x00000040u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* released = _impl_.content_disposition_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.content_disposition_.Set("", GetArena());
  }
  return released;
}
inline void S3Upload::set_allocated_content_disposition(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.content_disposition_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.content_disposition_.IsDefault()) {
    _impl_.content_disposition_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.S3Upload.content_disposition)
}

// .livekit.ProxyConfig proxy = 10;
inline bool S3Upload::has_proxy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.proxy_ != nullptr);
  return value;
}
inline void S3Upload::clear_proxy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.proxy_ != nullptr) _impl_.proxy_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::livekit::ProxyConfig& S3Upload::_internal_proxy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::livekit::ProxyConfig* p = _impl_.proxy_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::ProxyConfig&>(::livekit::_ProxyConfig_default_instance_);
}
inline const ::livekit::ProxyConfig& S3Upload::proxy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.S3Upload.proxy)
  return _internal_proxy();
}
inline void S3Upload::unsafe_arena_set_allocated_proxy(
    ::livekit::ProxyConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.proxy_);
  }
  _impl_.proxy_ = reinterpret_cast<::livekit::ProxyConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.S3Upload.proxy)
}
inline ::livekit::ProxyConfig* PROTOBUF_NULLABLE S3Upload::release_proxy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::livekit::ProxyConfig* released = _impl_.proxy_;
  _impl_.proxy_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::livekit::ProxyConfig* PROTOBUF_NULLABLE S3Upload::unsafe_arena_release_proxy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.S3Upload.proxy)

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::livekit::ProxyConfig* temp = _impl_.proxy_;
  _impl_.proxy_ = nullptr;
  return temp;
}
inline ::livekit::ProxyConfig* PROTOBUF_NONNULL S3Upload::_internal_mutable_proxy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.proxy_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::livekit::ProxyConfig>(GetArena());
    _impl_.proxy_ = reinterpret_cast<::livekit::ProxyConfig*>(p);
  }
  return _impl_.proxy_;
}
inline ::livekit::ProxyConfig* PROTOBUF_NONNULL S3Upload::mutable_proxy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000100u;
  ::livekit::ProxyConfig* _msg = _internal_mutable_proxy();
  // @@protoc_insertion_point(field_mutable:livekit.S3Upload.proxy)
  return _msg;
}
inline void S3Upload::set_allocated_proxy(::livekit::ProxyConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.proxy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }

  _impl_.proxy_ = reinterpret_cast<::livekit::ProxyConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:livekit.S3Upload.proxy)
}

// -------------------------------------------------------------------

// GCPUpload

// string credentials = 1;
inline void GCPUpload::clear_credentials() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.credentials_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GCPUpload::credentials() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.GCPUpload.credentials)
  return _internal_credentials();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void GCPUpload::set_credentials(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.credentials_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.GCPUpload.credentials)
}
inline std::string* PROTOBUF_NONNULL GCPUpload::mutable_credentials()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_credentials();
  // @@protoc_insertion_point(field_mutable:livekit.GCPUpload.credentials)
  return _s;
}
inline const std::string& GCPUpload::_internal_credentials() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.credentials_.Get();
}
inline void GCPUpload::_internal_set_credentials(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.credentials_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL GCPUpload::_internal_mutable_credentials() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.credentials_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE GCPUpload::release_credentials() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.GCPUpload.credentials)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.credentials_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.credentials_.Set("", GetArena());
  }
  return released;
}
inline void GCPUpload::set_allocated_credentials(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.credentials_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.credentials_.IsDefault()) {
    _impl_.credentials_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.GCPUpload.credentials)
}

// string bucket = 2;
inline void GCPUpload::clear_bucket() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bucket_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GCPUpload::bucket() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.GCPUpload.bucket)
  return _internal_bucket();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void GCPUpload::set_bucket(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.bucket_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.GCPUpload.bucket)
}
inline std::string* PROTOBUF_NONNULL GCPUpload::mutable_bucket()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_bucket();
  // @@protoc_insertion_point(field_mutable:livekit.GCPUpload.bucket)
  return _s;
}
inline const std::string& GCPUpload::_internal_bucket() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bucket_.Get();
}
inline void GCPUpload::_internal_set_bucket(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.bucket_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL GCPUpload::_internal_mutable_bucket() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.bucket_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE GCPUpload::release_bucket() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.GCPUpload.bucket)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.bucket_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.bucket_.Set("", GetArena());
  }
  return released;
}
inline void GCPUpload::set_allocated_bucket(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.bucket_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.bucket_.IsDefault()) {
    _impl_.bucket_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.GCPUpload.bucket)
}

// .livekit.ProxyConfig proxy = 3;
inline bool GCPUpload::has_proxy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.proxy_ != nullptr);
  return value;
}
inline void GCPUpload::clear_proxy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.proxy_ != nullptr) _impl_.proxy_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::livekit::ProxyConfig& GCPUpload::_internal_proxy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::livekit::ProxyConfig* p = _impl_.proxy_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::ProxyConfig&>(::livekit::_ProxyConfig_default_instance_);
}
inline const ::livekit::ProxyConfig& GCPUpload::proxy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.GCPUpload.proxy)
  return _internal_proxy();
}
inline void GCPUpload::unsafe_arena_set_allocated_proxy(
    ::livekit::ProxyConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.proxy_);
  }
  _impl_.proxy_ = reinterpret_cast<::livekit::ProxyConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.GCPUpload.proxy)
}
inline ::livekit::ProxyConfig* PROTOBUF_NULLABLE GCPUpload::release_proxy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::livekit::ProxyConfig* released = _impl_.proxy_;
  _impl_.proxy_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::livekit::ProxyConfig* PROTOBUF_NULLABLE GCPUpload::unsafe_arena_release_proxy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.GCPUpload.proxy)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::livekit::ProxyConfig* temp = _impl_.proxy_;
  _impl_.proxy_ = nullptr;
  return temp;
}
inline ::livekit::ProxyConfig* PROTOBUF_NONNULL GCPUpload::_internal_mutable_proxy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.proxy_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::livekit::ProxyConfig>(GetArena());
    _impl_.proxy_ = reinterpret_cast<::livekit::ProxyConfig*>(p);
  }
  return _impl_.proxy_;
}
inline ::livekit::ProxyConfig* PROTOBUF_NONNULL GCPUpload::mutable_proxy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::livekit::ProxyConfig* _msg = _internal_mutable_proxy();
  // @@protoc_insertion_point(field_mutable:livekit.GCPUpload.proxy)
  return _msg;
}
inline void GCPUpload::set_allocated_proxy(::livekit::ProxyConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.proxy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.proxy_ = reinterpret_cast<::livekit::ProxyConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:livekit.GCPUpload.proxy)
}

// -------------------------------------------------------------------

// AzureBlobUpload

// string account_name = 1;
inline void AzureBlobUpload::clear_account_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AzureBlobUpload::account_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.AzureBlobUpload.account_name)
  return _internal_account_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AzureBlobUpload::set_account_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.account_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.AzureBlobUpload.account_name)
}
inline std::string* PROTOBUF_NONNULL AzureBlobUpload::mutable_account_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_account_name();
  // @@protoc_insertion_point(field_mutable:livekit.AzureBlobUpload.account_name)
  return _s;
}
inline const std::string& AzureBlobUpload::_internal_account_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.account_name_.Get();
}
inline void AzureBlobUpload::_internal_set_account_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.account_name_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL AzureBlobUpload::_internal_mutable_account_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.account_name_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE AzureBlobUpload::release_account_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.AzureBlobUpload.account_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.account_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.account_name_.Set("", GetArena());
  }
  return released;
}
inline void AzureBlobUpload::set_allocated_account_name(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.account_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.account_name_.IsDefault()) {
    _impl_.account_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.AzureBlobUpload.account_name)
}

// string account_key = 2;
inline void AzureBlobUpload::clear_account_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AzureBlobUpload::account_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.AzureBlobUpload.account_key)
  return _internal_account_key();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AzureBlobUpload::set_account_key(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.account_key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.AzureBlobUpload.account_key)
}
inline std::string* PROTOBUF_NONNULL AzureBlobUpload::mutable_account_key()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_account_key();
  // @@protoc_insertion_point(field_mutable:livekit.AzureBlobUpload.account_key)
  return _s;
}
inline const std::string& AzureBlobUpload::_internal_account_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.account_key_.Get();
}
inline void AzureBlobUpload::_internal_set_account_key(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.account_key_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL AzureBlobUpload::_internal_mutable_account_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.account_key_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE AzureBlobUpload::release_account_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.AzureBlobUpload.account_key)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.account_key_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.account_key_.Set("", GetArena());
  }
  return released;
}
inline void AzureBlobUpload::set_allocated_account_key(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.account_key_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.account_key_.IsDefault()) {
    _impl_.account_key_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.AzureBlobUpload.account_key)
}

// string container_name = 3;
inline void AzureBlobUpload::clear_container_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.container_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AzureBlobUpload::container_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.AzureBlobUpload.container_name)
  return _internal_container_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AzureBlobUpload::set_container_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.container_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.AzureBlobUpload.container_name)
}
inline std::string* PROTOBUF_NONNULL AzureBlobUpload::mutable_container_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_container_name();
  // @@protoc_insertion_point(field_mutable:livekit.AzureBlobUpload.container_name)
  return _s;
}
inline const std::string& AzureBlobUpload::_internal_container_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.container_name_.Get();
}
inline void AzureBlobUpload::_internal_set_container_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.container_name_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL AzureBlobUpload::_internal_mutable_container_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.container_name_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE AzureBlobUpload::release_container_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.AzureBlobUpload.container_name)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.container_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.container_name_.Set("", GetArena());
  }
  return released;
}
inline void AzureBlobUpload::set_allocated_container_name(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.container_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.container_name_.IsDefault()) {
    _impl_.container_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.AzureBlobUpload.container_name)
}

// -------------------------------------------------------------------

// AliOSSUpload

// string access_key = 1;
inline void AliOSSUpload::clear_access_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.access_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AliOSSUpload::access_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.AliOSSUpload.access_key)
  return _internal_access_key();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AliOSSUpload::set_access_key(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.access_key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.AliOSSUpload.access_key)
}
inline std::string* PROTOBUF_NONNULL AliOSSUpload::mutable_access_key()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_access_key();
  // @@protoc_insertion_point(field_mutable:livekit.AliOSSUpload.access_key)
  return _s;
}
inline const std::string& AliOSSUpload::_internal_access_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.access_key_.Get();
}
inline void AliOSSUpload::_internal_set_access_key(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.access_key_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL AliOSSUpload::_internal_mutable_access_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.access_key_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE AliOSSUpload::release_access_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.AliOSSUpload.access_key)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.access_key_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.access_key_.Set("", GetArena());
  }
  return released;
}
inline void AliOSSUpload::set_allocated_access_key(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.access_key_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.access_key_.IsDefault()) {
    _impl_.access_key_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.AliOSSUpload.access_key)
}

// string secret = 2;
inline void AliOSSUpload::clear_secret() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secret_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AliOSSUpload::secret() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.AliOSSUpload.secret)
  return _internal_secret();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AliOSSUpload::set_secret(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.secret_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.AliOSSUpload.secret)
}
inline std::string* PROTOBUF_NONNULL AliOSSUpload::mutable_secret()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_secret();
  // @@protoc_insertion_point(field_mutable:livekit.AliOSSUpload.secret)
  return _s;
}
inline const std::string& AliOSSUpload::_internal_secret() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.secret_.Get();
}
inline void AliOSSUpload::_internal_set_secret(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.secret_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL AliOSSUpload::_internal_mutable_secret() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.secret_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE AliOSSUpload::release_secret() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.AliOSSUpload.secret)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.secret_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.secret_.Set("", GetArena());
  }
  return released;
}
inline void AliOSSUpload::set_allocated_secret(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.secret_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.secret_.IsDefault()) {
    _impl_.secret_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.AliOSSUpload.secret)
}

// string region = 3;
inline void AliOSSUpload::clear_region() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.region_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AliOSSUpload::region() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.AliOSSUpload.region)
  return _internal_region();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AliOSSUpload::set_region(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.region_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.AliOSSUpload.region)
}
inline std::string* PROTOBUF_NONNULL AliOSSUpload::mutable_region()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:livekit.AliOSSUpload.region)
  return _s;
}
inline const std::string& AliOSSUpload::_internal_region() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.region_.Get();
}
inline void AliOSSUpload::_internal_set_region(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.region_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL AliOSSUpload::_internal_mutable_region() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.region_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE AliOSSUpload::release_region() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.AliOSSUpload.region)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.region_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.region_.Set("", GetArena());
  }
  return released;
}
inline void AliOSSUpload::set_allocated_region(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.region_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.region_.IsDefault()) {
    _impl_.region_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.AliOSSUpload.region)
}

// string endpoint = 4;
inline void AliOSSUpload::clear_endpoint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.endpoint_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& AliOSSUpload::endpoint() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.AliOSSUpload.endpoint)
  return _internal_endpoint();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AliOSSUpload::set_endpoint(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.endpoint_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.AliOSSUpload.endpoint)
}
inline std::string* PROTOBUF_NONNULL AliOSSUpload::mutable_endpoint()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_endpoint();
  // @@protoc_insertion_point(field_mutable:livekit.AliOSSUpload.endpoint)
  return _s;
}
inline const std::string& AliOSSUpload::_internal_endpoint() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.endpoint_.Get();
}
inline void AliOSSUpload::_internal_set_endpoint(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.endpoint_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL AliOSSUpload::_internal_mutable_endpoint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.endpoint_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE AliOSSUpload::release_endpoint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.AliOSSUpload.endpoint)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.endpoint_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.endpoint_.Set("", GetArena());
  }
  return released;
}
inline void AliOSSUpload::set_allocated_endpoint(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.endpoint_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.endpoint_.IsDefault()) {
    _impl_.endpoint_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.AliOSSUpload.endpoint)
}

// string bucket = 5;
inline void AliOSSUpload::clear_bucket() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bucket_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& AliOSSUpload::bucket() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.AliOSSUpload.bucket)
  return _internal_bucket();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AliOSSUpload::set_bucket(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.bucket_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.AliOSSUpload.bucket)
}
inline std::string* PROTOBUF_NONNULL AliOSSUpload::mutable_bucket()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_bucket();
  // @@protoc_insertion_point(field_mutable:livekit.AliOSSUpload.bucket)
  return _s;
}
inline const std::string& AliOSSUpload::_internal_bucket() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bucket_.Get();
}
inline void AliOSSUpload::_internal_set_bucket(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.bucket_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL AliOSSUpload::_internal_mutable_bucket() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.bucket_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE AliOSSUpload::release_bucket() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.AliOSSUpload.bucket)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.bucket_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.bucket_.Set("", GetArena());
  }
  return released;
}
inline void AliOSSUpload::set_allocated_bucket(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.bucket_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.bucket_.IsDefault()) {
    _impl_.bucket_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.AliOSSUpload.bucket)
}

// -------------------------------------------------------------------

// ProxyConfig

// string url = 1;
inline void ProxyConfig::clear_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ProxyConfig::url() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.ProxyConfig.url)
  return _internal_url();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ProxyConfig::set_url(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.url_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.ProxyConfig.url)
}
inline std::string* PROTOBUF_NONNULL ProxyConfig::mutable_url()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:livekit.ProxyConfig.url)
  return _s;
}
inline const std::string& ProxyConfig::_internal_url() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.url_.Get();
}
inline void ProxyConfig::_internal_set_url(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.url_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL ProxyConfig::_internal_mutable_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.url_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE ProxyConfig::release_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.ProxyConfig.url)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.url_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.url_.Set("", GetArena());
  }
  return released;
}
inline void ProxyConfig::set_allocated_url(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.url_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.ProxyConfig.url)
}

// string username = 2;
inline void ProxyConfig::clear_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ProxyConfig::username() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.ProxyConfig.username)
  return _internal_username();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ProxyConfig::set_username(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.username_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.ProxyConfig.username)
}
inline std::string* PROTOBUF_NONNULL ProxyConfig::mutable_username()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:livekit.ProxyConfig.username)
  return _s;
}
inline const std::string& ProxyConfig::_internal_username() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.username_.Get();
}
inline void ProxyConfig::_internal_set_username(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.username_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL ProxyConfig::_internal_mutable_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.username_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE ProxyConfig::release_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.ProxyConfig.username)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.username_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.username_.Set("", GetArena());
  }
  return released;
}
inline void ProxyConfig::set_allocated_username(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.username_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.ProxyConfig.username)
}

// string password = 3;
inline void ProxyConfig::clear_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ProxyConfig::password() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.ProxyConfig.password)
  return _internal_password();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ProxyConfig::set_password(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.password_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.ProxyConfig.password)
}
inline std::string* PROTOBUF_NONNULL ProxyConfig::mutable_password()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:livekit.ProxyConfig.password)
  return _s;
}
inline const std::string& ProxyConfig::_internal_password() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.password_.Get();
}
inline void ProxyConfig::_internal_set_password(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.password_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL ProxyConfig::_internal_mutable_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.password_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE ProxyConfig::release_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.ProxyConfig.password)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.password_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.password_.Set("", GetArena());
  }
  return released;
}
inline void ProxyConfig::set_allocated_password(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.password_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.ProxyConfig.password)
}

// -------------------------------------------------------------------

// StreamOutput

// .livekit.StreamProtocol protocol = 1;
inline void StreamOutput::clear_protocol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.protocol_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::livekit::StreamProtocol StreamOutput::protocol() const {
  // @@protoc_insertion_point(field_get:livekit.StreamOutput.protocol)
  return _internal_protocol();
}
inline void StreamOutput::set_protocol(::livekit::StreamProtocol value) {
  _internal_set_protocol(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:livekit.StreamOutput.protocol)
}
inline ::livekit::StreamProtocol StreamOutput::_internal_protocol() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::livekit::StreamProtocol>(_impl_.protocol_);
}
inline void StreamOutput::_internal_set_protocol(::livekit::StreamProtocol value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.protocol_ = value;
}

// repeated string urls = 2;
inline int StreamOutput::_internal_urls_size() const {
  return _internal_urls().size();
}
inline int StreamOutput::urls_size() const {
  return _internal_urls_size();
}
inline void StreamOutput::clear_urls() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.urls_.Clear();
}
inline std::string* PROTOBUF_NONNULL StreamOutput::add_urls()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_urls()->Add();
  // @@protoc_insertion_point(field_add_mutable:livekit.StreamOutput.urls)
  return _s;
}
inline const std::string& StreamOutput::urls(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.StreamOutput.urls)
  return _internal_urls().Get(index);
}
inline std::string* PROTOBUF_NONNULL StreamOutput::mutable_urls(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.StreamOutput.urls)
  return _internal_mutable_urls()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void StreamOutput::set_urls(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_urls()->Mutable(index), std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:livekit.StreamOutput.urls)
}
template <typename Arg_, typename... Args_>
inline void StreamOutput::add_urls(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_urls(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:livekit.StreamOutput.urls)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>& StreamOutput::urls() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.StreamOutput.urls)
  return _internal_urls();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* PROTOBUF_NONNULL
StreamOutput::mutable_urls() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.StreamOutput.urls)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_urls();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
StreamOutput::_internal_urls() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.urls_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>* PROTOBUF_NONNULL
StreamOutput::_internal_mutable_urls() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.urls_;
}

// -------------------------------------------------------------------

// EncodingOptions

// int32 width = 1;
inline void EncodingOptions::clear_width() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t EncodingOptions::width() const {
  // @@protoc_insertion_point(field_get:livekit.EncodingOptions.width)
  return _internal_width();
}
inline void EncodingOptions::set_width(::int32_t value) {
  _internal_set_width(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:livekit.EncodingOptions.width)
}
inline ::int32_t EncodingOptions::_internal_width() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.width_;
}
inline void EncodingOptions::_internal_set_width(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_ = value;
}

// int32 height = 2;
inline void EncodingOptions::clear_height() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t EncodingOptions::height() const {
  // @@protoc_insertion_point(field_get:livekit.EncodingOptions.height)
  return _internal_height();
}
inline void EncodingOptions::set_height(::int32_t value) {
  _internal_set_height(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:livekit.EncodingOptions.height)
}
inline ::int32_t EncodingOptions::_internal_height() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.height_;
}
inline void EncodingOptions::_internal_set_height(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = value;
}

// int32 depth = 3;
inline void EncodingOptions::clear_depth() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.depth_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t EncodingOptions::depth() const {
  // @@protoc_insertion_point(field_get:livekit.EncodingOptions.depth)
  return _internal_depth();
}
inline void EncodingOptions::set_depth(::int32_t value) {
  _internal_set_depth(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:livekit.EncodingOptions.depth)
}
inline ::int32_t EncodingOptions::_internal_depth() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.depth_;
}
inline void EncodingOptions::_internal_set_depth(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.depth_ = value;
}

// int32 framerate = 4;
inline void EncodingOptions::clear_framerate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.framerate_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t EncodingOptions::framerate() const {
  // @@protoc_insertion_point(field_get:livekit.EncodingOptions.framerate)
  return _internal_framerate();
}
inline void EncodingOptions::set_framerate(::int32_t value) {
  _internal_set_framerate(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:livekit.EncodingOptions.framerate)
}
inline ::int32_t EncodingOptions::_internal_framerate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.framerate_;
}
inline void EncodingOptions::_internal_set_framerate(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.framerate_ = value;
}

// .livekit.AudioCodec audio_codec = 5;
inline void EncodingOptions::clear_audio_codec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.audio_codec_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::livekit::AudioCodec EncodingOptions::audio_codec() const {
  // @@protoc_insertion_point(field_get:livekit.EncodingOptions.audio_codec)
  return _internal_audio_codec();
}
inline void EncodingOptions::set_audio_codec(::livekit::AudioCodec value) {
  _internal_set_audio_codec(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:livekit.EncodingOptions.audio_codec)
}
inline ::livekit::AudioCodec EncodingOptions::_internal_audio_codec() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::livekit::AudioCodec>(_impl_.audio_codec_);
}
inline void EncodingOptions::_internal_set_audio_codec(::livekit::AudioCodec value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.audio_codec_ = value;
}

// int32 audio_bitrate = 6;
inline void EncodingOptions::clear_audio_bitrate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.audio_bitrate_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t EncodingOptions::audio_bitrate() const {
  // @@protoc_insertion_point(field_get:livekit.EncodingOptions.audio_bitrate)
  return _internal_audio_bitrate();
}
inline void EncodingOptions::set_audio_bitrate(::int32_t value) {
  _internal_set_audio_bitrate(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:livekit.EncodingOptions.audio_bitrate)
}
inline ::int32_t EncodingOptions::_internal_audio_bitrate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.audio_bitrate_;
}
inline void EncodingOptions::_internal_set_audio_bitrate(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.audio_bitrate_ = value;
}

// int32 audio_quality = 11;
inline void EncodingOptions::clear_audio_quality() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.audio_quality_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::int32_t EncodingOptions::audio_quality() const {
  // @@protoc_insertion_point(field_get:livekit.EncodingOptions.audio_quality)
  return _internal_audio_quality();
}
inline void EncodingOptions::set_audio_quality(::int32_t value) {
  _internal_set_audio_quality(value);
  _impl_._has_bits_[0] |= 0x00000400u;
  // @@protoc_insertion_point(field_set:livekit.EncodingOptions.audio_quality)
}
inline ::int32_t EncodingOptions::_internal_audio_quality() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.audio_quality_;
}
inline void EncodingOptions::_internal_set_audio_quality(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.audio_quality_ = value;
}

// int32 audio_frequency = 7;
inline void EncodingOptions::clear_audio_frequency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.audio_frequency_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int32_t EncodingOptions::audio_frequency() const {
  // @@protoc_insertion_point(field_get:livekit.EncodingOptions.audio_frequency)
  return _internal_audio_frequency();
}
inline void EncodingOptions::set_audio_frequency(::int32_t value) {
  _internal_set_audio_frequency(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:livekit.EncodingOptions.audio_frequency)
}
inline ::int32_t EncodingOptions::_internal_audio_frequency() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.audio_frequency_;
}
inline void EncodingOptions::_internal_set_audio_frequency(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.audio_frequency_ = value;
}

// .livekit.VideoCodec video_codec = 8;
inline void EncodingOptions::clear_video_codec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.video_codec_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::livekit::VideoCodec EncodingOptions::video_codec() const {
  // @@protoc_insertion_point(field_get:livekit.EncodingOptions.video_codec)
  return _internal_video_codec();
}
inline void EncodingOptions::set_video_codec(::livekit::VideoCodec value) {
  _internal_set_video_codec(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:livekit.EncodingOptions.video_codec)
}
inline ::livekit::VideoCodec EncodingOptions::_internal_video_codec() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::livekit::VideoCodec>(_impl_.video_codec_);
}
inline void EncodingOptions::_internal_set_video_codec(::livekit::VideoCodec value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.video_codec_ = value;
}

// int32 video_bitrate = 9;
inline void EncodingOptions::clear_video_bitrate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.video_bitrate_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::int32_t EncodingOptions::video_bitrate() const {
  // @@protoc_insertion_point(field_get:livekit.EncodingOptions.video_bitrate)
  return _internal_video_bitrate();
}
inline void EncodingOptions::set_video_bitrate(::int32_t value) {
  _internal_set_video_bitrate(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:livekit.EncodingOptions.video_bitrate)
}
inline ::int32_t EncodingOptions::_internal_video_bitrate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.video_bitrate_;
}
inline void EncodingOptions::_internal_set_video_bitrate(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.video_bitrate_ = value;
}

// int32 video_quality = 12;
inline void EncodingOptions::clear_video_quality() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.video_quality_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::int32_t EncodingOptions::video_quality() const {
  // @@protoc_insertion_point(field_get:livekit.EncodingOptions.video_quality)
  return _internal_video_quality();
}
inline void EncodingOptions::set_video_quality(::int32_t value) {
  _internal_set_video_quality(value);
  _impl_._has_bits_[0] |= 0x00000800u;
  // @@protoc_insertion_point(field_set:livekit.EncodingOptions.video_quality)
}
inline ::int32_t EncodingOptions::_internal_video_quality() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.video_quality_;
}
inline void EncodingOptions::_internal_set_video_quality(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.video_quality_ = value;
}

// double key_frame_interval = 10;
inline void EncodingOptions::clear_key_frame_interval() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_frame_interval_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline double EncodingOptions::key_frame_interval() const {
  // @@protoc_insertion_point(field_get:livekit.EncodingOptions.key_frame_interval)
  return _internal_key_frame_interval();
}
inline void EncodingOptions::set_key_frame_interval(double value) {
  _internal_set_key_frame_interval(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:livekit.EncodingOptions.key_frame_interval)
}
inline double EncodingOptions::_internal_key_frame_interval() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_frame_interval_;
}
inline void EncodingOptions::_internal_set_key_frame_interval(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_frame_interval_ = value;
}

// -------------------------------------------------------------------

// UpdateLayoutRequest

// string egress_id = 1;
inline void UpdateLayoutRequest::clear_egress_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.egress_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UpdateLayoutRequest::egress_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.UpdateLayoutRequest.egress_id)
  return _internal_egress_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UpdateLayoutRequest::set_egress_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.egress_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.UpdateLayoutRequest.egress_id)
}
inline std::string* PROTOBUF_NONNULL UpdateLayoutRequest::mutable_egress_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_egress_id();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateLayoutRequest.egress_id)
  return _s;
}
inline const std::string& UpdateLayoutRequest::_internal_egress_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.egress_id_.Get();
}
inline void UpdateLayoutRequest::_internal_set_egress_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.egress_id_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL UpdateLayoutRequest::_internal_mutable_egress_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.egress_id_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE UpdateLayoutRequest::release_egress_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.UpdateLayoutRequest.egress_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.egress_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.egress_id_.Set("", GetArena());
  }
  return released;
}
inline void UpdateLayoutRequest::set_allocated_egress_id(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.egress_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.egress_id_.IsDefault()) {
    _impl_.egress_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateLayoutRequest.egress_id)
}

// string layout = 2;
inline void UpdateLayoutRequest::clear_layout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.layout_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UpdateLayoutRequest::layout() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.UpdateLayoutRequest.layout)
  return _internal_layout();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UpdateLayoutRequest::set_layout(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.layout_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.UpdateLayoutRequest.layout)
}
inline std::string* PROTOBUF_NONNULL UpdateLayoutRequest::mutable_layout()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_layout();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateLayoutRequest.layout)
  return _s;
}
inline const std::string& UpdateLayoutRequest::_internal_layout() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.layout_.Get();
}
inline void UpdateLayoutRequest::_internal_set_layout(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.layout_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL UpdateLayoutRequest::_internal_mutable_layout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.layout_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE UpdateLayoutRequest::release_layout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.UpdateLayoutRequest.layout)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.layout_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.layout_.Set("", GetArena());
  }
  return released;
}
inline void UpdateLayoutRequest::set_allocated_layout(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.layout_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.layout_.IsDefault()) {
    _impl_.layout_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateLayoutRequest.layout)
}

// -------------------------------------------------------------------

// UpdateStreamRequest

// string egress_id = 1;
inline void UpdateStreamRequest::clear_egress_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.egress_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UpdateStreamRequest::egress_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.UpdateStreamRequest.egress_id)
  return _internal_egress_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UpdateStreamRequest::set_egress_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.egress_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.UpdateStreamRequest.egress_id)
}
inline std::string* PROTOBUF_NONNULL UpdateStreamRequest::mutable_egress_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_egress_id();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateStreamRequest.egress_id)
  return _s;
}
inline const std::string& UpdateStreamRequest::_internal_egress_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.egress_id_.Get();
}
inline void UpdateStreamRequest::_internal_set_egress_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.egress_id_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL UpdateStreamRequest::_internal_mutable_egress_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.egress_id_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE UpdateStreamRequest::release_egress_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.UpdateStreamRequest.egress_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.egress_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.egress_id_.Set("", GetArena());
  }
  return released;
}
inline void UpdateStreamRequest::set_allocated_egress_id(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.egress_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.egress_id_.IsDefault()) {
    _impl_.egress_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateStreamRequest.egress_id)
}

// repeated string add_output_urls = 2;
inline int UpdateStreamRequest::_internal_add_output_urls_size() const {
  return _internal_add_output_urls().size();
}
inline int UpdateStreamRequest::add_output_urls_size() const {
  return _internal_add_output_urls_size();
}
inline void UpdateStreamRequest::clear_add_output_urls() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.add_output_urls_.Clear();
}
inline std::string* PROTOBUF_NONNULL UpdateStreamRequest::add_add_output_urls()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_add_output_urls()->Add();
  // @@protoc_insertion_point(field_add_mutable:livekit.UpdateStreamRequest.add_output_urls)
  return _s;
}
inline const std::string& UpdateStreamRequest::add_output_urls(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.UpdateStreamRequest.add_output_urls)
  return _internal_add_output_urls().Get(index);
}
inline std::string* PROTOBUF_NONNULL UpdateStreamRequest::mutable_add_output_urls(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.UpdateStreamRequest.add_output_urls)
  return _internal_mutable_add_output_urls()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void UpdateStreamRequest::set_add_output_urls(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_add_output_urls()->Mutable(index), std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:livekit.UpdateStreamRequest.add_output_urls)
}
template <typename Arg_, typename... Args_>
inline void UpdateStreamRequest::add_add_output_urls(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_add_output_urls(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:livekit.UpdateStreamRequest.add_output_urls)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>& UpdateStreamRequest::add_output_urls() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.UpdateStreamRequest.add_output_urls)
  return _internal_add_output_urls();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* PROTOBUF_NONNULL
UpdateStreamRequest::mutable_add_output_urls() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.UpdateStreamRequest.add_output_urls)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_add_output_urls();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
UpdateStreamRequest::_internal_add_output_urls() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.add_output_urls_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>* PROTOBUF_NONNULL
UpdateStreamRequest::_internal_mutable_add_output_urls() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.add_output_urls_;
}

// repeated string remove_output_urls = 3;
inline int UpdateStreamRequest::_internal_remove_output_urls_size() const {
  return _internal_remove_output_urls().size();
}
inline int UpdateStreamRequest::remove_output_urls_size() const {
  return _internal_remove_output_urls_size();
}
inline void UpdateStreamRequest::clear_remove_output_urls() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.remove_output_urls_.Clear();
}
inline std::string* PROTOBUF_NONNULL UpdateStreamRequest::add_remove_output_urls()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_remove_output_urls()->Add();
  // @@protoc_insertion_point(field_add_mutable:livekit.UpdateStreamRequest.remove_output_urls)
  return _s;
}
inline const std::string& UpdateStreamRequest::remove_output_urls(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.UpdateStreamRequest.remove_output_urls)
  return _internal_remove_output_urls().Get(index);
}
inline std::string* PROTOBUF_NONNULL UpdateStreamRequest::mutable_remove_output_urls(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.UpdateStreamRequest.remove_output_urls)
  return _internal_mutable_remove_output_urls()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void UpdateStreamRequest::set_remove_output_urls(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_remove_output_urls()->Mutable(index), std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:livekit.UpdateStreamRequest.remove_output_urls)
}
template <typename Arg_, typename... Args_>
inline void UpdateStreamRequest::add_remove_output_urls(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_remove_output_urls(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:livekit.UpdateStreamRequest.remove_output_urls)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>& UpdateStreamRequest::remove_output_urls() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.UpdateStreamRequest.remove_output_urls)
  return _internal_remove_output_urls();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* PROTOBUF_NONNULL
UpdateStreamRequest::mutable_remove_output_urls() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.UpdateStreamRequest.remove_output_urls)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_remove_output_urls();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
UpdateStreamRequest::_internal_remove_output_urls() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.remove_output_urls_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>* PROTOBUF_NONNULL
UpdateStreamRequest::_internal_mutable_remove_output_urls() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.remove_output_urls_;
}

// -------------------------------------------------------------------

// ListEgressRequest

// string room_name = 1;
inline void ListEgressRequest::clear_room_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.room_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ListEgressRequest::room_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.ListEgressRequest.room_name)
  return _internal_room_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ListEgressRequest::set_room_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.room_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.ListEgressRequest.room_name)
}
inline std::string* PROTOBUF_NONNULL ListEgressRequest::mutable_room_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_room_name();
  // @@protoc_insertion_point(field_mutable:livekit.ListEgressRequest.room_name)
  return _s;
}
inline const std::string& ListEgressRequest::_internal_room_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.room_name_.Get();
}
inline void ListEgressRequest::_internal_set_room_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.room_name_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL ListEgressRequest::_internal_mutable_room_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.room_name_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE ListEgressRequest::release_room_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.ListEgressRequest.room_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.room_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.room_name_.Set("", GetArena());
  }
  return released;
}
inline void ListEgressRequest::set_allocated_room_name(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.room_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.room_name_.IsDefault()) {
    _impl_.room_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.ListEgressRequest.room_name)
}

// string egress_id = 2;
inline void ListEgressRequest::clear_egress_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.egress_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ListEgressRequest::egress_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.ListEgressRequest.egress_id)
  return _internal_egress_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ListEgressRequest::set_egress_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.egress_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.ListEgressRequest.egress_id)
}
inline std::string* PROTOBUF_NONNULL ListEgressRequest::mutable_egress_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_egress_id();
  // @@protoc_insertion_point(field_mutable:livekit.ListEgressRequest.egress_id)
  return _s;
}
inline const std::string& ListEgressRequest::_internal_egress_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.egress_id_.Get();
}
inline void ListEgressRequest::_internal_set_egress_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.egress_id_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL ListEgressRequest::_internal_mutable_egress_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.egress_id_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE ListEgressRequest::release_egress_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.ListEgressRequest.egress_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.egress_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.egress_id_.Set("", GetArena());
  }
  return released;
}
inline void ListEgressRequest::set_allocated_egress_id(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.egress_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.egress_id_.IsDefault()) {
    _impl_.egress_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.ListEgressRequest.egress_id)
}

// bool active = 3;
inline void ListEgressRequest::clear_active() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.active_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool ListEgressRequest::active() const {
  // @@protoc_insertion_point(field_get:livekit.ListEgressRequest.active)
  return _internal_active();
}
inline void ListEgressRequest::set_active(bool value) {
  _internal_set_active(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:livekit.ListEgressRequest.active)
}
inline bool ListEgressRequest::_internal_active() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.active_;
}
inline void ListEgressRequest::_internal_set_active(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.active_ = value;
}

// -------------------------------------------------------------------

// ListEgressResponse

// repeated .livekit.EgressInfo items = 1;
inline int ListEgressResponse::_internal_items_size() const {
  return _internal_items().size();
}
inline int ListEgressResponse::items_size() const {
  return _internal_items_size();
}
inline void ListEgressResponse::clear_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.items_.Clear();
}
inline ::livekit::EgressInfo* PROTOBUF_NONNULL ListEgressResponse::mutable_items(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.ListEgressResponse.items)
  return _internal_mutable_items()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::EgressInfo>* PROTOBUF_NONNULL ListEgressResponse::mutable_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.ListEgressResponse.items)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_items();
}
inline const ::livekit::EgressInfo& ListEgressResponse::items(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.ListEgressResponse.items)
  return _internal_items().Get(index);
}
inline ::livekit::EgressInfo* PROTOBUF_NONNULL ListEgressResponse::add_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::EgressInfo* _add = _internal_mutable_items()->Add();
  // @@protoc_insertion_point(field_add:livekit.ListEgressResponse.items)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::EgressInfo>& ListEgressResponse::items() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.ListEgressResponse.items)
  return _internal_items();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::EgressInfo>&
ListEgressResponse::_internal_items() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.items_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::EgressInfo>* PROTOBUF_NONNULL
ListEgressResponse::_internal_mutable_items() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.items_;
}

// -------------------------------------------------------------------

// StopEgressRequest

// string egress_id = 1;
inline void StopEgressRequest::clear_egress_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.egress_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StopEgressRequest::egress_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.StopEgressRequest.egress_id)
  return _internal_egress_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void StopEgressRequest::set_egress_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.egress_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.StopEgressRequest.egress_id)
}
inline std::string* PROTOBUF_NONNULL StopEgressRequest::mutable_egress_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_egress_id();
  // @@protoc_insertion_point(field_mutable:livekit.StopEgressRequest.egress_id)
  return _s;
}
inline const std::string& StopEgressRequest::_internal_egress_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.egress_id_.Get();
}
inline void StopEgressRequest::_internal_set_egress_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.egress_id_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL StopEgressRequest::_internal_mutable_egress_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.egress_id_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE StopEgressRequest::release_egress_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.StopEgressRequest.egress_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.egress_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.egress_id_.Set("", GetArena());
  }
  return released;
}
inline void StopEgressRequest::set_allocated_egress_id(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.egress_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.egress_id_.IsDefault()) {
    _impl_.egress_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.StopEgressRequest.egress_id)
}

// -------------------------------------------------------------------

// EgressInfo

// string egress_id = 1;
inline void EgressInfo::clear_egress_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.egress_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& EgressInfo::egress_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.egress_id)
  return _internal_egress_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void EgressInfo::set_egress_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.egress_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.EgressInfo.egress_id)
}
inline std::string* PROTOBUF_NONNULL EgressInfo::mutable_egress_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_egress_id();
  // @@protoc_insertion_point(field_mutable:livekit.EgressInfo.egress_id)
  return _s;
}
inline const std::string& EgressInfo::_internal_egress_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.egress_id_.Get();
}
inline void EgressInfo::_internal_set_egress_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.egress_id_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL EgressInfo::_internal_mutable_egress_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.egress_id_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE EgressInfo::release_egress_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.EgressInfo.egress_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.egress_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.egress_id_.Set("", GetArena());
  }
  return released;
}
inline void EgressInfo::set_allocated_egress_id(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.egress_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.egress_id_.IsDefault()) {
    _impl_.egress_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.EgressInfo.egress_id)
}

// string room_id = 2;
inline void EgressInfo::clear_room_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.room_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& EgressInfo::room_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.room_id)
  return _internal_room_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void EgressInfo::set_room_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.room_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.EgressInfo.room_id)
}
inline std::string* PROTOBUF_NONNULL EgressInfo::mutable_room_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_room_id();
  // @@protoc_insertion_point(field_mutable:livekit.EgressInfo.room_id)
  return _s;
}
inline const std::string& EgressInfo::_internal_room_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.room_id_.Get();
}
inline void EgressInfo::_internal_set_room_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.room_id_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL EgressInfo::_internal_mutable_room_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.room_id_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE EgressInfo::release_room_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.EgressInfo.room_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.room_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.room_id_.Set("", GetArena());
  }
  return released;
}
inline void EgressInfo::set_allocated_room_id(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.room_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.room_id_.IsDefault()) {
    _impl_.room_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.EgressInfo.room_id)
}

// string room_name = 13;
inline void EgressInfo::clear_room_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.room_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& EgressInfo::room_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.room_name)
  return _internal_room_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void EgressInfo::set_room_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.room_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.EgressInfo.room_name)
}
inline std::string* PROTOBUF_NONNULL EgressInfo::mutable_room_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_room_name();
  // @@protoc_insertion_point(field_mutable:livekit.EgressInfo.room_name)
  return _s;
}
inline const std::string& EgressInfo::_internal_room_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.room_name_.Get();
}
inline void EgressInfo::_internal_set_room_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.room_name_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL EgressInfo::_internal_mutable_room_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.room_name_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE EgressInfo::release_room_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.EgressInfo.room_name)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.room_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.room_name_.Set("", GetArena());
  }
  return released;
}
inline void EgressInfo::set_allocated_room_name(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.room_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.room_name_.IsDefault()) {
    _impl_.room_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.EgressInfo.room_name)
}

// .livekit.EgressSourceType source_type = 26;
inline void EgressInfo::clear_source_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::livekit::EgressSourceType EgressInfo::source_type() const {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.source_type)
  return _internal_source_type();
}
inline void EgressInfo::set_source_type(::livekit::EgressSourceType value) {
  _internal_set_source_type(value);
  _impl_._has_bits_[0] |= 0x00001000u;
  // @@protoc_insertion_point(field_set:livekit.EgressInfo.source_type)
}
inline ::livekit::EgressSourceType EgressInfo::_internal_source_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::livekit::EgressSourceType>(_impl_.source_type_);
}
inline void EgressInfo::_internal_set_source_type(::livekit::EgressSourceType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_type_ = value;
}

// .livekit.EgressStatus status = 3;
inline void EgressInfo::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::livekit::EgressStatus EgressInfo::status() const {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.status)
  return _internal_status();
}
inline void EgressInfo::set_status(::livekit::EgressStatus value) {
  _internal_set_status(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:livekit.EgressInfo.status)
}
inline ::livekit::EgressStatus EgressInfo::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::livekit::EgressStatus>(_impl_.status_);
}
inline void EgressInfo::_internal_set_status(::livekit::EgressStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// int64 started_at = 10;
inline void EgressInfo::clear_started_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.started_at_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int64_t EgressInfo::started_at() const {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.started_at)
  return _internal_started_at();
}
inline void EgressInfo::set_started_at(::int64_t value) {
  _internal_set_started_at(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:livekit.EgressInfo.started_at)
}
inline ::int64_t EgressInfo::_internal_started_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.started_at_;
}
inline void EgressInfo::_internal_set_started_at(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.started_at_ = value;
}

// int64 ended_at = 11;
inline void EgressInfo::clear_ended_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ended_at_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::int64_t EgressInfo::ended_at() const {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.ended_at)
  return _internal_ended_at();
}
inline void EgressInfo::set_ended_at(::int64_t value) {
  _internal_set_ended_at(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:livekit.EgressInfo.ended_at)
}
inline ::int64_t EgressInfo::_internal_ended_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ended_at_;
}
inline void EgressInfo::_internal_set_ended_at(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ended_at_ = value;
}

// int64 updated_at = 18;
inline void EgressInfo::clear_updated_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.updated_at_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::int64_t EgressInfo::updated_at() const {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.updated_at)
  return _internal_updated_at();
}
inline void EgressInfo::set_updated_at(::int64_t value) {
  _internal_set_updated_at(value);
  _impl_._has_bits_[0] |= 0x00000400u;
  // @@protoc_insertion_point(field_set:livekit.EgressInfo.updated_at)
}
inline ::int64_t EgressInfo::_internal_updated_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.updated_at_;
}
inline void EgressInfo::_internal_set_updated_at(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.updated_at_ = value;
}

// string details = 21;
inline void EgressInfo::clear_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.details_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& EgressInfo::details() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.details)
  return _internal_details();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void EgressInfo::set_details(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.details_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.EgressInfo.details)
}
inline std::string* PROTOBUF_NONNULL EgressInfo::mutable_details()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_details();
  // @@protoc_insertion_point(field_mutable:livekit.EgressInfo.details)
  return _s;
}
inline const std::string& EgressInfo::_internal_details() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.details_.Get();
}
inline void EgressInfo::_internal_set_details(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.details_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL EgressInfo::_internal_mutable_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.details_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE EgressInfo::release_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.EgressInfo.details)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.details_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.details_.Set("", GetArena());
  }
  return released;
}
inline void EgressInfo::set_allocated_details(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.details_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.details_.IsDefault()) {
    _impl_.details_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.EgressInfo.details)
}

// string error = 9;
inline void EgressInfo::clear_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& EgressInfo::error() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.error)
  return _internal_error();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void EgressInfo::set_error(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.error_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.EgressInfo.error)
}
inline std::string* PROTOBUF_NONNULL EgressInfo::mutable_error()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:livekit.EgressInfo.error)
  return _s;
}
inline const std::string& EgressInfo::_internal_error() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_.Get();
}
inline void EgressInfo::_internal_set_error(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.error_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL EgressInfo::_internal_mutable_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.error_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE EgressInfo::release_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.EgressInfo.error)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.error_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.error_.Set("", GetArena());
  }
  return released;
}
inline void EgressInfo::set_allocated_error(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.error_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.EgressInfo.error)
}

// int32 error_code = 22;
inline void EgressInfo::clear_error_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_code_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::int32_t EgressInfo::error_code() const {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.error_code)
  return _internal_error_code();
}
inline void EgressInfo::set_error_code(::int32_t value) {
  _internal_set_error_code(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:livekit.EgressInfo.error_code)
}
inline ::int32_t EgressInfo::_internal_error_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_code_;
}
inline void EgressInfo::_internal_set_error_code(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_code_ = value;
}

// .livekit.RoomCompositeEgressRequest room_composite = 4;
inline bool EgressInfo::has_room_composite() const {
  return request_case() == kRoomComposite;
}
inline bool EgressInfo::_internal_has_room_composite() const {
  return request_case() == kRoomComposite;
}
inline void EgressInfo::set_has_room_composite() {
  _impl_._oneof_case_[0] = kRoomComposite;
}
inline void EgressInfo::clear_room_composite() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (request_case() == kRoomComposite) {
    if (GetArena() == nullptr) {
      delete _impl_.request_.room_composite_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.request_.room_composite_);
    }
    clear_has_request();
  }
}
inline ::livekit::RoomCompositeEgressRequest* PROTOBUF_NULLABLE EgressInfo::release_room_composite() {
  // @@protoc_insertion_point(field_release:livekit.EgressInfo.room_composite)
  if (request_case() == kRoomComposite) {
    clear_has_request();
    auto* temp = reinterpret_cast<::livekit::RoomCompositeEgressRequest*>(_impl_.request_.room_composite_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.room_composite_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::RoomCompositeEgressRequest& EgressInfo::_internal_room_composite() const {
  return request_case() == kRoomComposite ? *reinterpret_cast<::livekit::RoomCompositeEgressRequest*>(_impl_.request_.room_composite_) : reinterpret_cast<::livekit::RoomCompositeEgressRequest&>(::livekit::_RoomCompositeEgressRequest_default_instance_);
}
inline const ::livekit::RoomCompositeEgressRequest& EgressInfo::room_composite() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.room_composite)
  return _internal_room_composite();
}
inline ::livekit::RoomCompositeEgressRequest* PROTOBUF_NULLABLE EgressInfo::unsafe_arena_release_room_composite() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.EgressInfo.room_composite)
  if (request_case() == kRoomComposite) {
    clear_has_request();
    auto* temp = reinterpret_cast<::livekit::RoomCompositeEgressRequest*>(_impl_.request_.room_composite_);
    _impl_.request_.room_composite_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EgressInfo::unsafe_arena_set_allocated_room_composite(
    ::livekit::RoomCompositeEgressRequest* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request();
  if (value) {
    set_has_room_composite();
    _impl_.request_.room_composite_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.EgressInfo.room_composite)
}
inline ::livekit::RoomCompositeEgressRequest* PROTOBUF_NONNULL EgressInfo::_internal_mutable_room_composite() {
  if (request_case() != kRoomComposite) {
    clear_request();
    set_has_room_composite();
    _impl_.request_.room_composite_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::RoomCompositeEgressRequest>(GetArena()));
  }
  return reinterpret_cast<::livekit::RoomCompositeEgressRequest*>(_impl_.request_.room_composite_);
}
inline ::livekit::RoomCompositeEgressRequest* PROTOBUF_NONNULL EgressInfo::mutable_room_composite()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::RoomCompositeEgressRequest* _msg = _internal_mutable_room_composite();
  // @@protoc_insertion_point(field_mutable:livekit.EgressInfo.room_composite)
  return _msg;
}

// .livekit.WebEgressRequest web = 14;
inline bool EgressInfo::has_web() const {
  return request_case() == kWeb;
}
inline bool EgressInfo::_internal_has_web() const {
  return request_case() == kWeb;
}
inline void EgressInfo::set_has_web() {
  _impl_._oneof_case_[0] = kWeb;
}
inline void EgressInfo::clear_web() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (request_case() == kWeb) {
    if (GetArena() == nullptr) {
      delete _impl_.request_.web_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.request_.web_);
    }
    clear_has_request();
  }
}
inline ::livekit::WebEgressRequest* PROTOBUF_NULLABLE EgressInfo::release_web() {
  // @@protoc_insertion_point(field_release:livekit.EgressInfo.web)
  if (request_case() == kWeb) {
    clear_has_request();
    auto* temp = reinterpret_cast<::livekit::WebEgressRequest*>(_impl_.request_.web_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.web_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::WebEgressRequest& EgressInfo::_internal_web() const {
  return request_case() == kWeb ? *reinterpret_cast<::livekit::WebEgressRequest*>(_impl_.request_.web_) : reinterpret_cast<::livekit::WebEgressRequest&>(::livekit::_WebEgressRequest_default_instance_);
}
inline const ::livekit::WebEgressRequest& EgressInfo::web() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.web)
  return _internal_web();
}
inline ::livekit::WebEgressRequest* PROTOBUF_NULLABLE EgressInfo::unsafe_arena_release_web() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.EgressInfo.web)
  if (request_case() == kWeb) {
    clear_has_request();
    auto* temp = reinterpret_cast<::livekit::WebEgressRequest*>(_impl_.request_.web_);
    _impl_.request_.web_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EgressInfo::unsafe_arena_set_allocated_web(
    ::livekit::WebEgressRequest* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request();
  if (value) {
    set_has_web();
    _impl_.request_.web_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.EgressInfo.web)
}
inline ::livekit::WebEgressRequest* PROTOBUF_NONNULL EgressInfo::_internal_mutable_web() {
  if (request_case() != kWeb) {
    clear_request();
    set_has_web();
    _impl_.request_.web_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::WebEgressRequest>(GetArena()));
  }
  return reinterpret_cast<::livekit::WebEgressRequest*>(_impl_.request_.web_);
}
inline ::livekit::WebEgressRequest* PROTOBUF_NONNULL EgressInfo::mutable_web()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::WebEgressRequest* _msg = _internal_mutable_web();
  // @@protoc_insertion_point(field_mutable:livekit.EgressInfo.web)
  return _msg;
}

// .livekit.ParticipantEgressRequest participant = 19;
inline bool EgressInfo::has_participant() const {
  return request_case() == kParticipant;
}
inline bool EgressInfo::_internal_has_participant() const {
  return request_case() == kParticipant;
}
inline void EgressInfo::set_has_participant() {
  _impl_._oneof_case_[0] = kParticipant;
}
inline void EgressInfo::clear_participant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (request_case() == kParticipant) {
    if (GetArena() == nullptr) {
      delete _impl_.request_.participant_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.request_.participant_);
    }
    clear_has_request();
  }
}
inline ::livekit::ParticipantEgressRequest* PROTOBUF_NULLABLE EgressInfo::release_participant() {
  // @@protoc_insertion_point(field_release:livekit.EgressInfo.participant)
  if (request_case() == kParticipant) {
    clear_has_request();
    auto* temp = reinterpret_cast<::livekit::ParticipantEgressRequest*>(_impl_.request_.participant_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.participant_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::ParticipantEgressRequest& EgressInfo::_internal_participant() const {
  return request_case() == kParticipant ? *reinterpret_cast<::livekit::ParticipantEgressRequest*>(_impl_.request_.participant_) : reinterpret_cast<::livekit::ParticipantEgressRequest&>(::livekit::_ParticipantEgressRequest_default_instance_);
}
inline const ::livekit::ParticipantEgressRequest& EgressInfo::participant() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.participant)
  return _internal_participant();
}
inline ::livekit::ParticipantEgressRequest* PROTOBUF_NULLABLE EgressInfo::unsafe_arena_release_participant() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.EgressInfo.participant)
  if (request_case() == kParticipant) {
    clear_has_request();
    auto* temp = reinterpret_cast<::livekit::ParticipantEgressRequest*>(_impl_.request_.participant_);
    _impl_.request_.participant_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EgressInfo::unsafe_arena_set_allocated_participant(
    ::livekit::ParticipantEgressRequest* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request();
  if (value) {
    set_has_participant();
    _impl_.request_.participant_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.EgressInfo.participant)
}
inline ::livekit::ParticipantEgressRequest* PROTOBUF_NONNULL EgressInfo::_internal_mutable_participant() {
  if (request_case() != kParticipant) {
    clear_request();
    set_has_participant();
    _impl_.request_.participant_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::ParticipantEgressRequest>(GetArena()));
  }
  return reinterpret_cast<::livekit::ParticipantEgressRequest*>(_impl_.request_.participant_);
}
inline ::livekit::ParticipantEgressRequest* PROTOBUF_NONNULL EgressInfo::mutable_participant()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::ParticipantEgressRequest* _msg = _internal_mutable_participant();
  // @@protoc_insertion_point(field_mutable:livekit.EgressInfo.participant)
  return _msg;
}

// .livekit.TrackCompositeEgressRequest track_composite = 5;
inline bool EgressInfo::has_track_composite() const {
  return request_case() == kTrackComposite;
}
inline bool EgressInfo::_internal_has_track_composite() const {
  return request_case() == kTrackComposite;
}
inline void EgressInfo::set_has_track_composite() {
  _impl_._oneof_case_[0] = kTrackComposite;
}
inline void EgressInfo::clear_track_composite() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (request_case() == kTrackComposite) {
    if (GetArena() == nullptr) {
      delete _impl_.request_.track_composite_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.request_.track_composite_);
    }
    clear_has_request();
  }
}
inline ::livekit::TrackCompositeEgressRequest* PROTOBUF_NULLABLE EgressInfo::release_track_composite() {
  // @@protoc_insertion_point(field_release:livekit.EgressInfo.track_composite)
  if (request_case() == kTrackComposite) {
    clear_has_request();
    auto* temp = reinterpret_cast<::livekit::TrackCompositeEgressRequest*>(_impl_.request_.track_composite_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.track_composite_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::TrackCompositeEgressRequest& EgressInfo::_internal_track_composite() const {
  return request_case() == kTrackComposite ? *reinterpret_cast<::livekit::TrackCompositeEgressRequest*>(_impl_.request_.track_composite_) : reinterpret_cast<::livekit::TrackCompositeEgressRequest&>(::livekit::_TrackCompositeEgressRequest_default_instance_);
}
inline const ::livekit::TrackCompositeEgressRequest& EgressInfo::track_composite() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.track_composite)
  return _internal_track_composite();
}
inline ::livekit::TrackCompositeEgressRequest* PROTOBUF_NULLABLE EgressInfo::unsafe_arena_release_track_composite() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.EgressInfo.track_composite)
  if (request_case() == kTrackComposite) {
    clear_has_request();
    auto* temp = reinterpret_cast<::livekit::TrackCompositeEgressRequest*>(_impl_.request_.track_composite_);
    _impl_.request_.track_composite_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EgressInfo::unsafe_arena_set_allocated_track_composite(
    ::livekit::TrackCompositeEgressRequest* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request();
  if (value) {
    set_has_track_composite();
    _impl_.request_.track_composite_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.EgressInfo.track_composite)
}
inline ::livekit::TrackCompositeEgressRequest* PROTOBUF_NONNULL EgressInfo::_internal_mutable_track_composite() {
  if (request_case() != kTrackComposite) {
    clear_request();
    set_has_track_composite();
    _impl_.request_.track_composite_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::TrackCompositeEgressRequest>(GetArena()));
  }
  return reinterpret_cast<::livekit::TrackCompositeEgressRequest*>(_impl_.request_.track_composite_);
}
inline ::livekit::TrackCompositeEgressRequest* PROTOBUF_NONNULL EgressInfo::mutable_track_composite()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::TrackCompositeEgressRequest* _msg = _internal_mutable_track_composite();
  // @@protoc_insertion_point(field_mutable:livekit.EgressInfo.track_composite)
  return _msg;
}

// .livekit.TrackEgressRequest track = 6;
inline bool EgressInfo::has_track() const {
  return request_case() == kTrack;
}
inline bool EgressInfo::_internal_has_track() const {
  return request_case() == kTrack;
}
inline void EgressInfo::set_has_track() {
  _impl_._oneof_case_[0] = kTrack;
}
inline void EgressInfo::clear_track() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (request_case() == kTrack) {
    if (GetArena() == nullptr) {
      delete _impl_.request_.track_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.request_.track_);
    }
    clear_has_request();
  }
}
inline ::livekit::TrackEgressRequest* PROTOBUF_NULLABLE EgressInfo::release_track() {
  // @@protoc_insertion_point(field_release:livekit.EgressInfo.track)
  if (request_case() == kTrack) {
    clear_has_request();
    auto* temp = reinterpret_cast<::livekit::TrackEgressRequest*>(_impl_.request_.track_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.track_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::TrackEgressRequest& EgressInfo::_internal_track() const {
  return request_case() == kTrack ? *reinterpret_cast<::livekit::TrackEgressRequest*>(_impl_.request_.track_) : reinterpret_cast<::livekit::TrackEgressRequest&>(::livekit::_TrackEgressRequest_default_instance_);
}
inline const ::livekit::TrackEgressRequest& EgressInfo::track() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.track)
  return _internal_track();
}
inline ::livekit::TrackEgressRequest* PROTOBUF_NULLABLE EgressInfo::unsafe_arena_release_track() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.EgressInfo.track)
  if (request_case() == kTrack) {
    clear_has_request();
    auto* temp = reinterpret_cast<::livekit::TrackEgressRequest*>(_impl_.request_.track_);
    _impl_.request_.track_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EgressInfo::unsafe_arena_set_allocated_track(
    ::livekit::TrackEgressRequest* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request();
  if (value) {
    set_has_track();
    _impl_.request_.track_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.EgressInfo.track)
}
inline ::livekit::TrackEgressRequest* PROTOBUF_NONNULL EgressInfo::_internal_mutable_track() {
  if (request_case() != kTrack) {
    clear_request();
    set_has_track();
    _impl_.request_.track_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::TrackEgressRequest>(GetArena()));
  }
  return reinterpret_cast<::livekit::TrackEgressRequest*>(_impl_.request_.track_);
}
inline ::livekit::TrackEgressRequest* PROTOBUF_NONNULL EgressInfo::mutable_track()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::TrackEgressRequest* _msg = _internal_mutable_track();
  // @@protoc_insertion_point(field_mutable:livekit.EgressInfo.track)
  return _msg;
}

// .livekit.StreamInfoList stream = 7 [deprecated = true];
inline bool EgressInfo::has_stream() const {
  return result_case() == kStream;
}
inline bool EgressInfo::_internal_has_stream() const {
  return result_case() == kStream;
}
inline void EgressInfo::set_has_stream() {
  _impl_._oneof_case_[1] = kStream;
}
inline void EgressInfo::clear_stream() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (result_case() == kStream) {
    if (GetArena() == nullptr) {
      delete _impl_.result_.stream_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.result_.stream_);
    }
    clear_has_result();
  }
}
inline ::livekit::StreamInfoList* PROTOBUF_NULLABLE EgressInfo::release_stream() {
  // @@protoc_insertion_point(field_release:livekit.EgressInfo.stream)
  if (result_case() == kStream) {
    clear_has_result();
    auto* temp = reinterpret_cast<::livekit::StreamInfoList*>(_impl_.result_.stream_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.result_.stream_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::StreamInfoList& EgressInfo::_internal_stream() const {
  return result_case() == kStream ? *reinterpret_cast<::livekit::StreamInfoList*>(_impl_.result_.stream_) : reinterpret_cast<::livekit::StreamInfoList&>(::livekit::_StreamInfoList_default_instance_);
}
inline const ::livekit::StreamInfoList& EgressInfo::stream() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.stream)
  return _internal_stream();
}
inline ::livekit::StreamInfoList* PROTOBUF_NULLABLE EgressInfo::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.EgressInfo.stream)
  if (result_case() == kStream) {
    clear_has_result();
    auto* temp = reinterpret_cast<::livekit::StreamInfoList*>(_impl_.result_.stream_);
    _impl_.result_.stream_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EgressInfo::unsafe_arena_set_allocated_stream(
    ::livekit::StreamInfoList* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_result();
  if (value) {
    set_has_stream();
    _impl_.result_.stream_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.EgressInfo.stream)
}
inline ::livekit::StreamInfoList* PROTOBUF_NONNULL EgressInfo::_internal_mutable_stream() {
  if (result_case() != kStream) {
    clear_result();
    set_has_stream();
    _impl_.result_.stream_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::StreamInfoList>(GetArena()));
  }
  return reinterpret_cast<::livekit::StreamInfoList*>(_impl_.result_.stream_);
}
inline ::livekit::StreamInfoList* PROTOBUF_NONNULL EgressInfo::mutable_stream()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::StreamInfoList* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:livekit.EgressInfo.stream)
  return _msg;
}

// .livekit.FileInfo file = 8 [deprecated = true];
inline bool EgressInfo::has_file() const {
  return result_case() == kFile;
}
inline bool EgressInfo::_internal_has_file() const {
  return result_case() == kFile;
}
inline void EgressInfo::set_has_file() {
  _impl_._oneof_case_[1] = kFile;
}
inline void EgressInfo::clear_file() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (result_case() == kFile) {
    if (GetArena() == nullptr) {
      delete _impl_.result_.file_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.result_.file_);
    }
    clear_has_result();
  }
}
inline ::livekit::FileInfo* PROTOBUF_NULLABLE EgressInfo::release_file() {
  // @@protoc_insertion_point(field_release:livekit.EgressInfo.file)
  if (result_case() == kFile) {
    clear_has_result();
    auto* temp = reinterpret_cast<::livekit::FileInfo*>(_impl_.result_.file_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.result_.file_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::FileInfo& EgressInfo::_internal_file() const {
  return result_case() == kFile ? *reinterpret_cast<::livekit::FileInfo*>(_impl_.result_.file_) : reinterpret_cast<::livekit::FileInfo&>(::livekit::_FileInfo_default_instance_);
}
inline const ::livekit::FileInfo& EgressInfo::file() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.file)
  return _internal_file();
}
inline ::livekit::FileInfo* PROTOBUF_NULLABLE EgressInfo::unsafe_arena_release_file() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.EgressInfo.file)
  if (result_case() == kFile) {
    clear_has_result();
    auto* temp = reinterpret_cast<::livekit::FileInfo*>(_impl_.result_.file_);
    _impl_.result_.file_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EgressInfo::unsafe_arena_set_allocated_file(
    ::livekit::FileInfo* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_result();
  if (value) {
    set_has_file();
    _impl_.result_.file_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.EgressInfo.file)
}
inline ::livekit::FileInfo* PROTOBUF_NONNULL EgressInfo::_internal_mutable_file() {
  if (result_case() != kFile) {
    clear_result();
    set_has_file();
    _impl_.result_.file_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::FileInfo>(GetArena()));
  }
  return reinterpret_cast<::livekit::FileInfo*>(_impl_.result_.file_);
}
inline ::livekit::FileInfo* PROTOBUF_NONNULL EgressInfo::mutable_file()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::FileInfo* _msg = _internal_mutable_file();
  // @@protoc_insertion_point(field_mutable:livekit.EgressInfo.file)
  return _msg;
}

// .livekit.SegmentsInfo segments = 12 [deprecated = true];
inline bool EgressInfo::has_segments() const {
  return result_case() == kSegments;
}
inline bool EgressInfo::_internal_has_segments() const {
  return result_case() == kSegments;
}
inline void EgressInfo::set_has_segments() {
  _impl_._oneof_case_[1] = kSegments;
}
inline void EgressInfo::clear_segments() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (result_case() == kSegments) {
    if (GetArena() == nullptr) {
      delete _impl_.result_.segments_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.result_.segments_);
    }
    clear_has_result();
  }
}
inline ::livekit::SegmentsInfo* PROTOBUF_NULLABLE EgressInfo::release_segments() {
  // @@protoc_insertion_point(field_release:livekit.EgressInfo.segments)
  if (result_case() == kSegments) {
    clear_has_result();
    auto* temp = reinterpret_cast<::livekit::SegmentsInfo*>(_impl_.result_.segments_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.result_.segments_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::SegmentsInfo& EgressInfo::_internal_segments() const {
  return result_case() == kSegments ? *reinterpret_cast<::livekit::SegmentsInfo*>(_impl_.result_.segments_) : reinterpret_cast<::livekit::SegmentsInfo&>(::livekit::_SegmentsInfo_default_instance_);
}
inline const ::livekit::SegmentsInfo& EgressInfo::segments() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.segments)
  return _internal_segments();
}
inline ::livekit::SegmentsInfo* PROTOBUF_NULLABLE EgressInfo::unsafe_arena_release_segments() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.EgressInfo.segments)
  if (result_case() == kSegments) {
    clear_has_result();
    auto* temp = reinterpret_cast<::livekit::SegmentsInfo*>(_impl_.result_.segments_);
    _impl_.result_.segments_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EgressInfo::unsafe_arena_set_allocated_segments(
    ::livekit::SegmentsInfo* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_result();
  if (value) {
    set_has_segments();
    _impl_.result_.segments_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.EgressInfo.segments)
}
inline ::livekit::SegmentsInfo* PROTOBUF_NONNULL EgressInfo::_internal_mutable_segments() {
  if (result_case() != kSegments) {
    clear_result();
    set_has_segments();
    _impl_.result_.segments_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::SegmentsInfo>(GetArena()));
  }
  return reinterpret_cast<::livekit::SegmentsInfo*>(_impl_.result_.segments_);
}
inline ::livekit::SegmentsInfo* PROTOBUF_NONNULL EgressInfo::mutable_segments()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::SegmentsInfo* _msg = _internal_mutable_segments();
  // @@protoc_insertion_point(field_mutable:livekit.EgressInfo.segments)
  return _msg;
}

// repeated .livekit.StreamInfo stream_results = 15;
inline int EgressInfo::_internal_stream_results_size() const {
  return _internal_stream_results().size();
}
inline int EgressInfo::stream_results_size() const {
  return _internal_stream_results_size();
}
inline void EgressInfo::clear_stream_results() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stream_results_.Clear();
}
inline ::livekit::StreamInfo* PROTOBUF_NONNULL EgressInfo::mutable_stream_results(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.EgressInfo.stream_results)
  return _internal_mutable_stream_results()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::StreamInfo>* PROTOBUF_NONNULL EgressInfo::mutable_stream_results()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.EgressInfo.stream_results)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_stream_results();
}
inline const ::livekit::StreamInfo& EgressInfo::stream_results(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.stream_results)
  return _internal_stream_results().Get(index);
}
inline ::livekit::StreamInfo* PROTOBUF_NONNULL EgressInfo::add_stream_results()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::StreamInfo* _add = _internal_mutable_stream_results()->Add();
  // @@protoc_insertion_point(field_add:livekit.EgressInfo.stream_results)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::StreamInfo>& EgressInfo::stream_results() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.EgressInfo.stream_results)
  return _internal_stream_results();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::StreamInfo>&
EgressInfo::_internal_stream_results() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stream_results_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::StreamInfo>* PROTOBUF_NONNULL
EgressInfo::_internal_mutable_stream_results() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.stream_results_;
}

// repeated .livekit.FileInfo file_results = 16;
inline int EgressInfo::_internal_file_results_size() const {
  return _internal_file_results().size();
}
inline int EgressInfo::file_results_size() const {
  return _internal_file_results_size();
}
inline void EgressInfo::clear_file_results() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.file_results_.Clear();
}
inline ::livekit::FileInfo* PROTOBUF_NONNULL EgressInfo::mutable_file_results(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.EgressInfo.file_results)
  return _internal_mutable_file_results()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::FileInfo>* PROTOBUF_NONNULL EgressInfo::mutable_file_results()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.EgressInfo.file_results)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_file_results();
}
inline const ::livekit::FileInfo& EgressInfo::file_results(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.file_results)
  return _internal_file_results().Get(index);
}
inline ::livekit::FileInfo* PROTOBUF_NONNULL EgressInfo::add_file_results()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::FileInfo* _add = _internal_mutable_file_results()->Add();
  // @@protoc_insertion_point(field_add:livekit.EgressInfo.file_results)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::FileInfo>& EgressInfo::file_results() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.EgressInfo.file_results)
  return _internal_file_results();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::FileInfo>&
EgressInfo::_internal_file_results() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.file_results_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::FileInfo>* PROTOBUF_NONNULL
EgressInfo::_internal_mutable_file_results() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.file_results_;
}

// repeated .livekit.SegmentsInfo segment_results = 17;
inline int EgressInfo::_internal_segment_results_size() const {
  return _internal_segment_results().size();
}
inline int EgressInfo::segment_results_size() const {
  return _internal_segment_results_size();
}
inline void EgressInfo::clear_segment_results() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.segment_results_.Clear();
}
inline ::livekit::SegmentsInfo* PROTOBUF_NONNULL EgressInfo::mutable_segment_results(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.EgressInfo.segment_results)
  return _internal_mutable_segment_results()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::SegmentsInfo>* PROTOBUF_NONNULL EgressInfo::mutable_segment_results()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.EgressInfo.segment_results)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_segment_results();
}
inline const ::livekit::SegmentsInfo& EgressInfo::segment_results(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.segment_results)
  return _internal_segment_results().Get(index);
}
inline ::livekit::SegmentsInfo* PROTOBUF_NONNULL EgressInfo::add_segment_results()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::SegmentsInfo* _add = _internal_mutable_segment_results()->Add();
  // @@protoc_insertion_point(field_add:livekit.EgressInfo.segment_results)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::SegmentsInfo>& EgressInfo::segment_results() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.EgressInfo.segment_results)
  return _internal_segment_results();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::SegmentsInfo>&
EgressInfo::_internal_segment_results() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.segment_results_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::SegmentsInfo>* PROTOBUF_NONNULL
EgressInfo::_internal_mutable_segment_results() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.segment_results_;
}

// repeated .livekit.ImagesInfo image_results = 20;
inline int EgressInfo::_internal_image_results_size() const {
  return _internal_image_results().size();
}
inline int EgressInfo::image_results_size() const {
  return _internal_image_results_size();
}
inline void EgressInfo::clear_image_results() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.image_results_.Clear();
}
inline ::livekit::ImagesInfo* PROTOBUF_NONNULL EgressInfo::mutable_image_results(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.EgressInfo.image_results)
  return _internal_mutable_image_results()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::ImagesInfo>* PROTOBUF_NONNULL EgressInfo::mutable_image_results()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.EgressInfo.image_results)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_image_results();
}
inline const ::livekit::ImagesInfo& EgressInfo::image_results(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.image_results)
  return _internal_image_results().Get(index);
}
inline ::livekit::ImagesInfo* PROTOBUF_NONNULL EgressInfo::add_image_results()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::ImagesInfo* _add = _internal_mutable_image_results()->Add();
  // @@protoc_insertion_point(field_add:livekit.EgressInfo.image_results)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::ImagesInfo>& EgressInfo::image_results() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.EgressInfo.image_results)
  return _internal_image_results();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::ImagesInfo>&
EgressInfo::_internal_image_results() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.image_results_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::ImagesInfo>* PROTOBUF_NONNULL
EgressInfo::_internal_mutable_image_results() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.image_results_;
}

// string manifest_location = 23;
inline void EgressInfo::clear_manifest_location() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.manifest_location_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& EgressInfo::manifest_location() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.manifest_location)
  return _internal_manifest_location();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void EgressInfo::set_manifest_location(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.manifest_location_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.EgressInfo.manifest_location)
}
inline std::string* PROTOBUF_NONNULL EgressInfo::mutable_manifest_location()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_manifest_location();
  // @@protoc_insertion_point(field_mutable:livekit.EgressInfo.manifest_location)
  return _s;
}
inline const std::string& EgressInfo::_internal_manifest_location() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.manifest_location_.Get();
}
inline void EgressInfo::_internal_set_manifest_location(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.manifest_location_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL EgressInfo::_internal_mutable_manifest_location() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.manifest_location_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE EgressInfo::release_manifest_location() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.EgressInfo.manifest_location)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.manifest_location_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.manifest_location_.Set("", GetArena());
  }
  return released;
}
inline void EgressInfo::set_allocated_manifest_location(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.manifest_location_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.manifest_location_.IsDefault()) {
    _impl_.manifest_location_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.EgressInfo.manifest_location)
}

// bool backup_storage_used = 25;
inline void EgressInfo::clear_backup_storage_used() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.backup_storage_used_ = false;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool EgressInfo::backup_storage_used() const {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.backup_storage_used)
  return _internal_backup_storage_used();
}
inline void EgressInfo::set_backup_storage_used(bool value) {
  _internal_set_backup_storage_used(value);
  _impl_._has_bits_[0] |= 0x00000800u;
  // @@protoc_insertion_point(field_set:livekit.EgressInfo.backup_storage_used)
}
inline bool EgressInfo::_internal_backup_storage_used() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.backup_storage_used_;
}
inline void EgressInfo::_internal_set_backup_storage_used(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.backup_storage_used_ = value;
}

inline bool EgressInfo::has_request() const {
  return request_case() != REQUEST_NOT_SET;
}
inline void EgressInfo::clear_has_request() {
  _impl_._oneof_case_[0] = REQUEST_NOT_SET;
}
inline bool EgressInfo::has_result() const {
  return result_case() != RESULT_NOT_SET;
}
inline void EgressInfo::clear_has_result() {
  _impl_._oneof_case_[1] = RESULT_NOT_SET;
}
inline EgressInfo::RequestCase EgressInfo::request_case() const {
  return EgressInfo::RequestCase(_impl_._oneof_case_[0]);
}
inline EgressInfo::ResultCase EgressInfo::result_case() const {
  return EgressInfo::ResultCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// StreamInfoList

// repeated .livekit.StreamInfo info = 1;
inline int StreamInfoList::_internal_info_size() const {
  return _internal_info().size();
}
inline int StreamInfoList::info_size() const {
  return _internal_info_size();
}
inline void StreamInfoList::clear_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.info_.Clear();
}
inline ::livekit::StreamInfo* PROTOBUF_NONNULL StreamInfoList::mutable_info(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.StreamInfoList.info)
  return _internal_mutable_info()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::StreamInfo>* PROTOBUF_NONNULL StreamInfoList::mutable_info()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.StreamInfoList.info)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_info();
}
inline const ::livekit::StreamInfo& StreamInfoList::info(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.StreamInfoList.info)
  return _internal_info().Get(index);
}
inline ::livekit::StreamInfo* PROTOBUF_NONNULL StreamInfoList::add_info()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::StreamInfo* _add = _internal_mutable_info()->Add();
  // @@protoc_insertion_point(field_add:livekit.StreamInfoList.info)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::StreamInfo>& StreamInfoList::info() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.StreamInfoList.info)
  return _internal_info();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::StreamInfo>&
StreamInfoList::_internal_info() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.info_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::StreamInfo>* PROTOBUF_NONNULL
StreamInfoList::_internal_mutable_info() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.info_;
}

// -------------------------------------------------------------------

// StreamInfo

// string url = 1;
inline void StreamInfo::clear_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StreamInfo::url() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.StreamInfo.url)
  return _internal_url();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void StreamInfo::set_url(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.url_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.StreamInfo.url)
}
inline std::string* PROTOBUF_NONNULL StreamInfo::mutable_url()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:livekit.StreamInfo.url)
  return _s;
}
inline const std::string& StreamInfo::_internal_url() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.url_.Get();
}
inline void StreamInfo::_internal_set_url(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.url_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL StreamInfo::_internal_mutable_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.url_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE StreamInfo::release_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.StreamInfo.url)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.url_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.url_.Set("", GetArena());
  }
  return released;
}
inline void StreamInfo::set_allocated_url(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.url_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.StreamInfo.url)
}

// int64 started_at = 2;
inline void StreamInfo::clear_started_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.started_at_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t StreamInfo::started_at() const {
  // @@protoc_insertion_point(field_get:livekit.StreamInfo.started_at)
  return _internal_started_at();
}
inline void StreamInfo::set_started_at(::int64_t value) {
  _internal_set_started_at(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:livekit.StreamInfo.started_at)
}
inline ::int64_t StreamInfo::_internal_started_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.started_at_;
}
inline void StreamInfo::_internal_set_started_at(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.started_at_ = value;
}

// int64 ended_at = 3;
inline void StreamInfo::clear_ended_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ended_at_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int64_t StreamInfo::ended_at() const {
  // @@protoc_insertion_point(field_get:livekit.StreamInfo.ended_at)
  return _internal_ended_at();
}
inline void StreamInfo::set_ended_at(::int64_t value) {
  _internal_set_ended_at(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:livekit.StreamInfo.ended_at)
}
inline ::int64_t StreamInfo::_internal_ended_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ended_at_;
}
inline void StreamInfo::_internal_set_ended_at(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ended_at_ = value;
}

// int64 duration = 4;
inline void StreamInfo::clear_duration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.duration_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int64_t StreamInfo::duration() const {
  // @@protoc_insertion_point(field_get:livekit.StreamInfo.duration)
  return _internal_duration();
}
inline void StreamInfo::set_duration(::int64_t value) {
  _internal_set_duration(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:livekit.StreamInfo.duration)
}
inline ::int64_t StreamInfo::_internal_duration() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.duration_;
}
inline void StreamInfo::_internal_set_duration(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.duration_ = value;
}

// .livekit.StreamInfo.Status status = 5;
inline void StreamInfo::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::livekit::StreamInfo_Status StreamInfo::status() const {
  // @@protoc_insertion_point(field_get:livekit.StreamInfo.status)
  return _internal_status();
}
inline void StreamInfo::set_status(::livekit::StreamInfo_Status value) {
  _internal_set_status(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:livekit.StreamInfo.status)
}
inline ::livekit::StreamInfo_Status StreamInfo::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::livekit::StreamInfo_Status>(_impl_.status_);
}
inline void StreamInfo::_internal_set_status(::livekit::StreamInfo_Status value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// string error = 6;
inline void StreamInfo::clear_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StreamInfo::error() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.StreamInfo.error)
  return _internal_error();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void StreamInfo::set_error(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.error_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.StreamInfo.error)
}
inline std::string* PROTOBUF_NONNULL StreamInfo::mutable_error()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:livekit.StreamInfo.error)
  return _s;
}
inline const std::string& StreamInfo::_internal_error() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_.Get();
}
inline void StreamInfo::_internal_set_error(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.error_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL StreamInfo::_internal_mutable_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.error_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE StreamInfo::release_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.StreamInfo.error)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.error_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.error_.Set("", GetArena());
  }
  return released;
}
inline void StreamInfo::set_allocated_error(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.error_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.StreamInfo.error)
}

// -------------------------------------------------------------------

// FileInfo

// string filename = 1;
inline void FileInfo::clear_filename() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filename_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FileInfo::filename() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.FileInfo.filename)
  return _internal_filename();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void FileInfo::set_filename(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.filename_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.FileInfo.filename)
}
inline std::string* PROTOBUF_NONNULL FileInfo::mutable_filename()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:livekit.FileInfo.filename)
  return _s;
}
inline const std::string& FileInfo::_internal_filename() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.filename_.Get();
}
inline void FileInfo::_internal_set_filename(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.filename_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL FileInfo::_internal_mutable_filename() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.filename_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE FileInfo::release_filename() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.FileInfo.filename)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.filename_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.filename_.Set("", GetArena());
  }
  return released;
}
inline void FileInfo::set_allocated_filename(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.filename_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.FileInfo.filename)
}

// int64 started_at = 2;
inline void FileInfo::clear_started_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.started_at_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t FileInfo::started_at() const {
  // @@protoc_insertion_point(field_get:livekit.FileInfo.started_at)
  return _internal_started_at();
}
inline void FileInfo::set_started_at(::int64_t value) {
  _internal_set_started_at(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:livekit.FileInfo.started_at)
}
inline ::int64_t FileInfo::_internal_started_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.started_at_;
}
inline void FileInfo::_internal_set_started_at(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.started_at_ = value;
}

// int64 ended_at = 3;
inline void FileInfo::clear_ended_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ended_at_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int64_t FileInfo::ended_at() const {
  // @@protoc_insertion_point(field_get:livekit.FileInfo.ended_at)
  return _internal_ended_at();
}
inline void FileInfo::set_ended_at(::int64_t value) {
  _internal_set_ended_at(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:livekit.FileInfo.ended_at)
}
inline ::int64_t FileInfo::_internal_ended_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ended_at_;
}
inline void FileInfo::_internal_set_ended_at(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ended_at_ = value;
}

// int64 duration = 6;
inline void FileInfo::clear_duration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.duration_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int64_t FileInfo::duration() const {
  // @@protoc_insertion_point(field_get:livekit.FileInfo.duration)
  return _internal_duration();
}
inline void FileInfo::set_duration(::int64_t value) {
  _internal_set_duration(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:livekit.FileInfo.duration)
}
inline ::int64_t FileInfo::_internal_duration() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.duration_;
}
inline void FileInfo::_internal_set_duration(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.duration_ = value;
}

// int64 size = 4;
inline void FileInfo::clear_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int64_t FileInfo::size() const {
  // @@protoc_insertion_point(field_get:livekit.FileInfo.size)
  return _internal_size();
}
inline void FileInfo::set_size(::int64_t value) {
  _internal_set_size(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:livekit.FileInfo.size)
}
inline ::int64_t FileInfo::_internal_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.size_;
}
inline void FileInfo::_internal_set_size(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_ = value;
}

// string location = 5;
inline void FileInfo::clear_location() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.location_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& FileInfo::location() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.FileInfo.location)
  return _internal_location();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void FileInfo::set_location(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.location_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.FileInfo.location)
}
inline std::string* PROTOBUF_NONNULL FileInfo::mutable_location()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:livekit.FileInfo.location)
  return _s;
}
inline const std::string& FileInfo::_internal_location() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.location_.Get();
}
inline void FileInfo::_internal_set_location(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.location_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL FileInfo::_internal_mutable_location() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.location_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE FileInfo::release_location() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.FileInfo.location)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.location_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.location_.Set("", GetArena());
  }
  return released;
}
inline void FileInfo::set_allocated_location(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.location_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.location_.IsDefault()) {
    _impl_.location_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.FileInfo.location)
}

// -------------------------------------------------------------------

// SegmentsInfo

// string playlist_name = 1;
inline void SegmentsInfo::clear_playlist_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.playlist_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SegmentsInfo::playlist_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SegmentsInfo.playlist_name)
  return _internal_playlist_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SegmentsInfo::set_playlist_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.playlist_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.SegmentsInfo.playlist_name)
}
inline std::string* PROTOBUF_NONNULL SegmentsInfo::mutable_playlist_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_playlist_name();
  // @@protoc_insertion_point(field_mutable:livekit.SegmentsInfo.playlist_name)
  return _s;
}
inline const std::string& SegmentsInfo::_internal_playlist_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.playlist_name_.Get();
}
inline void SegmentsInfo::_internal_set_playlist_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.playlist_name_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL SegmentsInfo::_internal_mutable_playlist_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.playlist_name_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE SegmentsInfo::release_playlist_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.SegmentsInfo.playlist_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.playlist_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.playlist_name_.Set("", GetArena());
  }
  return released;
}
inline void SegmentsInfo::set_allocated_playlist_name(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.playlist_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.playlist_name_.IsDefault()) {
    _impl_.playlist_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.SegmentsInfo.playlist_name)
}

// string live_playlist_name = 8;
inline void SegmentsInfo::clear_live_playlist_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.live_playlist_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SegmentsInfo::live_playlist_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SegmentsInfo.live_playlist_name)
  return _internal_live_playlist_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SegmentsInfo::set_live_playlist_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.live_playlist_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.SegmentsInfo.live_playlist_name)
}
inline std::string* PROTOBUF_NONNULL SegmentsInfo::mutable_live_playlist_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_live_playlist_name();
  // @@protoc_insertion_point(field_mutable:livekit.SegmentsInfo.live_playlist_name)
  return _s;
}
inline const std::string& SegmentsInfo::_internal_live_playlist_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.live_playlist_name_.Get();
}
inline void SegmentsInfo::_internal_set_live_playlist_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.live_playlist_name_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL SegmentsInfo::_internal_mutable_live_playlist_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.live_playlist_name_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE SegmentsInfo::release_live_playlist_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.SegmentsInfo.live_playlist_name)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.live_playlist_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.live_playlist_name_.Set("", GetArena());
  }
  return released;
}
inline void SegmentsInfo::set_allocated_live_playlist_name(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.live_playlist_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.live_playlist_name_.IsDefault()) {
    _impl_.live_playlist_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.SegmentsInfo.live_playlist_name)
}

// int64 duration = 2;
inline void SegmentsInfo::clear_duration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.duration_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int64_t SegmentsInfo::duration() const {
  // @@protoc_insertion_point(field_get:livekit.SegmentsInfo.duration)
  return _internal_duration();
}
inline void SegmentsInfo::set_duration(::int64_t value) {
  _internal_set_duration(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:livekit.SegmentsInfo.duration)
}
inline ::int64_t SegmentsInfo::_internal_duration() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.duration_;
}
inline void SegmentsInfo::_internal_set_duration(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.duration_ = value;
}

// int64 size = 3;
inline void SegmentsInfo::clear_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int64_t SegmentsInfo::size() const {
  // @@protoc_insertion_point(field_get:livekit.SegmentsInfo.size)
  return _internal_size();
}
inline void SegmentsInfo::set_size(::int64_t value) {
  _internal_set_size(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:livekit.SegmentsInfo.size)
}
inline ::int64_t SegmentsInfo::_internal_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.size_;
}
inline void SegmentsInfo::_internal_set_size(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_ = value;
}

// string playlist_location = 4;
inline void SegmentsInfo::clear_playlist_location() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.playlist_location_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SegmentsInfo::playlist_location() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SegmentsInfo.playlist_location)
  return _internal_playlist_location();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SegmentsInfo::set_playlist_location(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.playlist_location_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.SegmentsInfo.playlist_location)
}
inline std::string* PROTOBUF_NONNULL SegmentsInfo::mutable_playlist_location()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_playlist_location();
  // @@protoc_insertion_point(field_mutable:livekit.SegmentsInfo.playlist_location)
  return _s;
}
inline const std::string& SegmentsInfo::_internal_playlist_location() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.playlist_location_.Get();
}
inline void SegmentsInfo::_internal_set_playlist_location(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.playlist_location_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL SegmentsInfo::_internal_mutable_playlist_location() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.playlist_location_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE SegmentsInfo::release_playlist_location() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.SegmentsInfo.playlist_location)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.playlist_location_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.playlist_location_.Set("", GetArena());
  }
  return released;
}
inline void SegmentsInfo::set_allocated_playlist_location(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.playlist_location_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.playlist_location_.IsDefault()) {
    _impl_.playlist_location_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.SegmentsInfo.playlist_location)
}

// string live_playlist_location = 9;
inline void SegmentsInfo::clear_live_playlist_location() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.live_playlist_location_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& SegmentsInfo::live_playlist_location() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.SegmentsInfo.live_playlist_location)
  return _internal_live_playlist_location();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SegmentsInfo::set_live_playlist_location(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.live_playlist_location_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.SegmentsInfo.live_playlist_location)
}
inline std::string* PROTOBUF_NONNULL SegmentsInfo::mutable_live_playlist_location()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_live_playlist_location();
  // @@protoc_insertion_point(field_mutable:livekit.SegmentsInfo.live_playlist_location)
  return _s;
}
inline const std::string& SegmentsInfo::_internal_live_playlist_location() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.live_playlist_location_.Get();
}
inline void SegmentsInfo::_internal_set_live_playlist_location(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.live_playlist_location_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL SegmentsInfo::_internal_mutable_live_playlist_location() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.live_playlist_location_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE SegmentsInfo::release_live_playlist_location() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.SegmentsInfo.live_playlist_location)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.live_playlist_location_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.live_playlist_location_.Set("", GetArena());
  }
  return released;
}
inline void SegmentsInfo::set_allocated_live_playlist_location(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.live_playlist_location_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.live_playlist_location_.IsDefault()) {
    _impl_.live_playlist_location_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.SegmentsInfo.live_playlist_location)
}

// int64 segment_count = 5;
inline void SegmentsInfo::clear_segment_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.segment_count_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int64_t SegmentsInfo::segment_count() const {
  // @@protoc_insertion_point(field_get:livekit.SegmentsInfo.segment_count)
  return _internal_segment_count();
}
inline void SegmentsInfo::set_segment_count(::int64_t value) {
  _internal_set_segment_count(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:livekit.SegmentsInfo.segment_count)
}
inline ::int64_t SegmentsInfo::_internal_segment_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.segment_count_;
}
inline void SegmentsInfo::_internal_set_segment_count(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.segment_count_ = value;
}

// int64 started_at = 6;
inline void SegmentsInfo::clear_started_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.started_at_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::int64_t SegmentsInfo::started_at() const {
  // @@protoc_insertion_point(field_get:livekit.SegmentsInfo.started_at)
  return _internal_started_at();
}
inline void SegmentsInfo::set_started_at(::int64_t value) {
  _internal_set_started_at(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:livekit.SegmentsInfo.started_at)
}
inline ::int64_t SegmentsInfo::_internal_started_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.started_at_;
}
inline void SegmentsInfo::_internal_set_started_at(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.started_at_ = value;
}

// int64 ended_at = 7;
inline void SegmentsInfo::clear_ended_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ended_at_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::int64_t SegmentsInfo::ended_at() const {
  // @@protoc_insertion_point(field_get:livekit.SegmentsInfo.ended_at)
  return _internal_ended_at();
}
inline void SegmentsInfo::set_ended_at(::int64_t value) {
  _internal_set_ended_at(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:livekit.SegmentsInfo.ended_at)
}
inline ::int64_t SegmentsInfo::_internal_ended_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ended_at_;
}
inline void SegmentsInfo::_internal_set_ended_at(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ended_at_ = value;
}

// -------------------------------------------------------------------

// ImagesInfo

// string filename_prefix = 4;
inline void ImagesInfo::clear_filename_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filename_prefix_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ImagesInfo::filename_prefix() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.ImagesInfo.filename_prefix)
  return _internal_filename_prefix();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ImagesInfo::set_filename_prefix(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.filename_prefix_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.ImagesInfo.filename_prefix)
}
inline std::string* PROTOBUF_NONNULL ImagesInfo::mutable_filename_prefix()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_filename_prefix();
  // @@protoc_insertion_point(field_mutable:livekit.ImagesInfo.filename_prefix)
  return _s;
}
inline const std::string& ImagesInfo::_internal_filename_prefix() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.filename_prefix_.Get();
}
inline void ImagesInfo::_internal_set_filename_prefix(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.filename_prefix_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL ImagesInfo::_internal_mutable_filename_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.filename_prefix_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE ImagesInfo::release_filename_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.ImagesInfo.filename_prefix)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.filename_prefix_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.filename_prefix_.Set("", GetArena());
  }
  return released;
}
inline void ImagesInfo::set_allocated_filename_prefix(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.filename_prefix_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.filename_prefix_.IsDefault()) {
    _impl_.filename_prefix_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.ImagesInfo.filename_prefix)
}

// int64 image_count = 1;
inline void ImagesInfo::clear_image_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.image_count_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t ImagesInfo::image_count() const {
  // @@protoc_insertion_point(field_get:livekit.ImagesInfo.image_count)
  return _internal_image_count();
}
inline void ImagesInfo::set_image_count(::int64_t value) {
  _internal_set_image_count(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:livekit.ImagesInfo.image_count)
}
inline ::int64_t ImagesInfo::_internal_image_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.image_count_;
}
inline void ImagesInfo::_internal_set_image_count(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.image_count_ = value;
}

// int64 started_at = 2;
inline void ImagesInfo::clear_started_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.started_at_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t ImagesInfo::started_at() const {
  // @@protoc_insertion_point(field_get:livekit.ImagesInfo.started_at)
  return _internal_started_at();
}
inline void ImagesInfo::set_started_at(::int64_t value) {
  _internal_set_started_at(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:livekit.ImagesInfo.started_at)
}
inline ::int64_t ImagesInfo::_internal_started_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.started_at_;
}
inline void ImagesInfo::_internal_set_started_at(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.started_at_ = value;
}

// int64 ended_at = 3;
inline void ImagesInfo::clear_ended_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ended_at_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int64_t ImagesInfo::ended_at() const {
  // @@protoc_insertion_point(field_get:livekit.ImagesInfo.ended_at)
  return _internal_ended_at();
}
inline void ImagesInfo::set_ended_at(::int64_t value) {
  _internal_set_ended_at(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:livekit.ImagesInfo.ended_at)
}
inline ::int64_t ImagesInfo::_internal_ended_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ended_at_;
}
inline void ImagesInfo::_internal_set_ended_at(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ended_at_ = value;
}

// -------------------------------------------------------------------

// AutoParticipantEgress

// .livekit.EncodingOptionsPreset preset = 1;
inline bool AutoParticipantEgress::has_preset() const {
  return options_case() == kPreset;
}
inline void AutoParticipantEgress::set_has_preset() {
  _impl_._oneof_case_[0] = kPreset;
}
inline void AutoParticipantEgress::clear_preset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (options_case() == kPreset) {
    _impl_.options_.preset_ = 0;
    clear_has_options();
  }
}
inline ::livekit::EncodingOptionsPreset AutoParticipantEgress::preset() const {
  // @@protoc_insertion_point(field_get:livekit.AutoParticipantEgress.preset)
  return _internal_preset();
}
inline void AutoParticipantEgress::set_preset(::livekit::EncodingOptionsPreset value) {
  if (options_case() != kPreset) {
    clear_options();
    set_has_preset();
  }
  _impl_.options_.preset_ = value;
  // @@protoc_insertion_point(field_set:livekit.AutoParticipantEgress.preset)
}
inline ::livekit::EncodingOptionsPreset AutoParticipantEgress::_internal_preset() const {
  if (options_case() == kPreset) {
    return static_cast<::livekit::EncodingOptionsPreset>(_impl_.options_.preset_);
  }
  return static_cast<::livekit::EncodingOptionsPreset>(0);
}

// .livekit.EncodingOptions advanced = 2;
inline bool AutoParticipantEgress::has_advanced() const {
  return options_case() == kAdvanced;
}
inline bool AutoParticipantEgress::_internal_has_advanced() const {
  return options_case() == kAdvanced;
}
inline void AutoParticipantEgress::set_has_advanced() {
  _impl_._oneof_case_[0] = kAdvanced;
}
inline void AutoParticipantEgress::clear_advanced() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (options_case() == kAdvanced) {
    if (GetArena() == nullptr) {
      delete _impl_.options_.advanced_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.options_.advanced_);
    }
    clear_has_options();
  }
}
inline ::livekit::EncodingOptions* PROTOBUF_NULLABLE AutoParticipantEgress::release_advanced() {
  // @@protoc_insertion_point(field_release:livekit.AutoParticipantEgress.advanced)
  if (options_case() == kAdvanced) {
    clear_has_options();
    auto* temp = _impl_.options_.advanced_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.options_.advanced_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::EncodingOptions& AutoParticipantEgress::_internal_advanced() const {
  return options_case() == kAdvanced ? *_impl_.options_.advanced_ : reinterpret_cast<::livekit::EncodingOptions&>(::livekit::_EncodingOptions_default_instance_);
}
inline const ::livekit::EncodingOptions& AutoParticipantEgress::advanced() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.AutoParticipantEgress.advanced)
  return _internal_advanced();
}
inline ::livekit::EncodingOptions* PROTOBUF_NULLABLE AutoParticipantEgress::unsafe_arena_release_advanced() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.AutoParticipantEgress.advanced)
  if (options_case() == kAdvanced) {
    clear_has_options();
    auto* temp = _impl_.options_.advanced_;
    _impl_.options_.advanced_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AutoParticipantEgress::unsafe_arena_set_allocated_advanced(
    ::livekit::EncodingOptions* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_options();
  if (value) {
    set_has_advanced();
    _impl_.options_.advanced_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.AutoParticipantEgress.advanced)
}
inline ::livekit::EncodingOptions* PROTOBUF_NONNULL AutoParticipantEgress::_internal_mutable_advanced() {
  if (options_case() != kAdvanced) {
    clear_options();
    set_has_advanced();
    _impl_.options_.advanced_ = 
        ::google::protobuf::Message::DefaultConstruct<::livekit::EncodingOptions>(GetArena());
  }
  return _impl_.options_.advanced_;
}
inline ::livekit::EncodingOptions* PROTOBUF_NONNULL AutoParticipantEgress::mutable_advanced()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::EncodingOptions* _msg = _internal_mutable_advanced();
  // @@protoc_insertion_point(field_mutable:livekit.AutoParticipantEgress.advanced)
  return _msg;
}

// repeated .livekit.EncodedFileOutput file_outputs = 3;
inline int AutoParticipantEgress::_internal_file_outputs_size() const {
  return _internal_file_outputs().size();
}
inline int AutoParticipantEgress::file_outputs_size() const {
  return _internal_file_outputs_size();
}
inline void AutoParticipantEgress::clear_file_outputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.file_outputs_.Clear();
}
inline ::livekit::EncodedFileOutput* PROTOBUF_NONNULL AutoParticipantEgress::mutable_file_outputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.AutoParticipantEgress.file_outputs)
  return _internal_mutable_file_outputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::EncodedFileOutput>* PROTOBUF_NONNULL AutoParticipantEgress::mutable_file_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.AutoParticipantEgress.file_outputs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_file_outputs();
}
inline const ::livekit::EncodedFileOutput& AutoParticipantEgress::file_outputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.AutoParticipantEgress.file_outputs)
  return _internal_file_outputs().Get(index);
}
inline ::livekit::EncodedFileOutput* PROTOBUF_NONNULL AutoParticipantEgress::add_file_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::EncodedFileOutput* _add = _internal_mutable_file_outputs()->Add();
  // @@protoc_insertion_point(field_add:livekit.AutoParticipantEgress.file_outputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::EncodedFileOutput>& AutoParticipantEgress::file_outputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.AutoParticipantEgress.file_outputs)
  return _internal_file_outputs();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::EncodedFileOutput>&
AutoParticipantEgress::_internal_file_outputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.file_outputs_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::EncodedFileOutput>* PROTOBUF_NONNULL
AutoParticipantEgress::_internal_mutable_file_outputs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.file_outputs_;
}

// repeated .livekit.SegmentedFileOutput segment_outputs = 4;
inline int AutoParticipantEgress::_internal_segment_outputs_size() const {
  return _internal_segment_outputs().size();
}
inline int AutoParticipantEgress::segment_outputs_size() const {
  return _internal_segment_outputs_size();
}
inline void AutoParticipantEgress::clear_segment_outputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.segment_outputs_.Clear();
}
inline ::livekit::SegmentedFileOutput* PROTOBUF_NONNULL AutoParticipantEgress::mutable_segment_outputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.AutoParticipantEgress.segment_outputs)
  return _internal_mutable_segment_outputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::SegmentedFileOutput>* PROTOBUF_NONNULL AutoParticipantEgress::mutable_segment_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.AutoParticipantEgress.segment_outputs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_segment_outputs();
}
inline const ::livekit::SegmentedFileOutput& AutoParticipantEgress::segment_outputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.AutoParticipantEgress.segment_outputs)
  return _internal_segment_outputs().Get(index);
}
inline ::livekit::SegmentedFileOutput* PROTOBUF_NONNULL AutoParticipantEgress::add_segment_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::SegmentedFileOutput* _add = _internal_mutable_segment_outputs()->Add();
  // @@protoc_insertion_point(field_add:livekit.AutoParticipantEgress.segment_outputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::SegmentedFileOutput>& AutoParticipantEgress::segment_outputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.AutoParticipantEgress.segment_outputs)
  return _internal_segment_outputs();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::SegmentedFileOutput>&
AutoParticipantEgress::_internal_segment_outputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.segment_outputs_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::SegmentedFileOutput>* PROTOBUF_NONNULL
AutoParticipantEgress::_internal_mutable_segment_outputs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.segment_outputs_;
}

inline bool AutoParticipantEgress::has_options() const {
  return options_case() != OPTIONS_NOT_SET;
}
inline void AutoParticipantEgress::clear_has_options() {
  _impl_._oneof_case_[0] = OPTIONS_NOT_SET;
}
inline AutoParticipantEgress::OptionsCase AutoParticipantEgress::options_case() const {
  return AutoParticipantEgress::OptionsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AutoTrackEgress

// string filepath = 1;
inline void AutoTrackEgress::clear_filepath() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filepath_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AutoTrackEgress::filepath() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.AutoTrackEgress.filepath)
  return _internal_filepath();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AutoTrackEgress::set_filepath(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.filepath_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.AutoTrackEgress.filepath)
}
inline std::string* PROTOBUF_NONNULL AutoTrackEgress::mutable_filepath()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_filepath();
  // @@protoc_insertion_point(field_mutable:livekit.AutoTrackEgress.filepath)
  return _s;
}
inline const std::string& AutoTrackEgress::_internal_filepath() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.filepath_.Get();
}
inline void AutoTrackEgress::_internal_set_filepath(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.filepath_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL AutoTrackEgress::_internal_mutable_filepath() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.filepath_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE AutoTrackEgress::release_filepath() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.AutoTrackEgress.filepath)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.filepath_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.filepath_.Set("", GetArena());
  }
  return released;
}
inline void AutoTrackEgress::set_allocated_filepath(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.filepath_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.filepath_.IsDefault()) {
    _impl_.filepath_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.AutoTrackEgress.filepath)
}

// bool disable_manifest = 5;
inline void AutoTrackEgress::clear_disable_manifest() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.disable_manifest_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool AutoTrackEgress::disable_manifest() const {
  // @@protoc_insertion_point(field_get:livekit.AutoTrackEgress.disable_manifest)
  return _internal_disable_manifest();
}
inline void AutoTrackEgress::set_disable_manifest(bool value) {
  _internal_set_disable_manifest(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:livekit.AutoTrackEgress.disable_manifest)
}
inline bool AutoTrackEgress::_internal_disable_manifest() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.disable_manifest_;
}
inline void AutoTrackEgress::_internal_set_disable_manifest(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.disable_manifest_ = value;
}

// .livekit.S3Upload s3 = 2;
inline bool AutoTrackEgress::has_s3() const {
  return output_case() == kS3;
}
inline bool AutoTrackEgress::_internal_has_s3() const {
  return output_case() == kS3;
}
inline void AutoTrackEgress::set_has_s3() {
  _impl_._oneof_case_[0] = kS3;
}
inline void AutoTrackEgress::clear_s3() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (output_case() == kS3) {
    if (GetArena() == nullptr) {
      delete _impl_.output_.s3_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.output_.s3_);
    }
    clear_has_output();
  }
}
inline ::livekit::S3Upload* PROTOBUF_NULLABLE AutoTrackEgress::release_s3() {
  // @@protoc_insertion_point(field_release:livekit.AutoTrackEgress.s3)
  if (output_case() == kS3) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::S3Upload*>(_impl_.output_.s3_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.s3_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::S3Upload& AutoTrackEgress::_internal_s3() const {
  return output_case() == kS3 ? *reinterpret_cast<::livekit::S3Upload*>(_impl_.output_.s3_) : reinterpret_cast<::livekit::S3Upload&>(::livekit::_S3Upload_default_instance_);
}
inline const ::livekit::S3Upload& AutoTrackEgress::s3() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.AutoTrackEgress.s3)
  return _internal_s3();
}
inline ::livekit::S3Upload* PROTOBUF_NULLABLE AutoTrackEgress::unsafe_arena_release_s3() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.AutoTrackEgress.s3)
  if (output_case() == kS3) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::S3Upload*>(_impl_.output_.s3_);
    _impl_.output_.s3_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AutoTrackEgress::unsafe_arena_set_allocated_s3(
    ::livekit::S3Upload* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_output();
  if (value) {
    set_has_s3();
    _impl_.output_.s3_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.AutoTrackEgress.s3)
}
inline ::livekit::S3Upload* PROTOBUF_NONNULL AutoTrackEgress::_internal_mutable_s3() {
  if (output_case() != kS3) {
    clear_output();
    set_has_s3();
    _impl_.output_.s3_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::S3Upload>(GetArena()));
  }
  return reinterpret_cast<::livekit::S3Upload*>(_impl_.output_.s3_);
}
inline ::livekit::S3Upload* PROTOBUF_NONNULL AutoTrackEgress::mutable_s3()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::S3Upload* _msg = _internal_mutable_s3();
  // @@protoc_insertion_point(field_mutable:livekit.AutoTrackEgress.s3)
  return _msg;
}

// .livekit.GCPUpload gcp = 3;
inline bool AutoTrackEgress::has_gcp() const {
  return output_case() == kGcp;
}
inline bool AutoTrackEgress::_internal_has_gcp() const {
  return output_case() == kGcp;
}
inline void AutoTrackEgress::set_has_gcp() {
  _impl_._oneof_case_[0] = kGcp;
}
inline void AutoTrackEgress::clear_gcp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (output_case() == kGcp) {
    if (GetArena() == nullptr) {
      delete _impl_.output_.gcp_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.output_.gcp_);
    }
    clear_has_output();
  }
}
inline ::livekit::GCPUpload* PROTOBUF_NULLABLE AutoTrackEgress::release_gcp() {
  // @@protoc_insertion_point(field_release:livekit.AutoTrackEgress.gcp)
  if (output_case() == kGcp) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::GCPUpload*>(_impl_.output_.gcp_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.gcp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::GCPUpload& AutoTrackEgress::_internal_gcp() const {
  return output_case() == kGcp ? *reinterpret_cast<::livekit::GCPUpload*>(_impl_.output_.gcp_) : reinterpret_cast<::livekit::GCPUpload&>(::livekit::_GCPUpload_default_instance_);
}
inline const ::livekit::GCPUpload& AutoTrackEgress::gcp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.AutoTrackEgress.gcp)
  return _internal_gcp();
}
inline ::livekit::GCPUpload* PROTOBUF_NULLABLE AutoTrackEgress::unsafe_arena_release_gcp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.AutoTrackEgress.gcp)
  if (output_case() == kGcp) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::GCPUpload*>(_impl_.output_.gcp_);
    _impl_.output_.gcp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AutoTrackEgress::unsafe_arena_set_allocated_gcp(
    ::livekit::GCPUpload* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_output();
  if (value) {
    set_has_gcp();
    _impl_.output_.gcp_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.AutoTrackEgress.gcp)
}
inline ::livekit::GCPUpload* PROTOBUF_NONNULL AutoTrackEgress::_internal_mutable_gcp() {
  if (output_case() != kGcp) {
    clear_output();
    set_has_gcp();
    _impl_.output_.gcp_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::GCPUpload>(GetArena()));
  }
  return reinterpret_cast<::livekit::GCPUpload*>(_impl_.output_.gcp_);
}
inline ::livekit::GCPUpload* PROTOBUF_NONNULL AutoTrackEgress::mutable_gcp()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::GCPUpload* _msg = _internal_mutable_gcp();
  // @@protoc_insertion_point(field_mutable:livekit.AutoTrackEgress.gcp)
  return _msg;
}

// .livekit.AzureBlobUpload azure = 4;
inline bool AutoTrackEgress::has_azure() const {
  return output_case() == kAzure;
}
inline bool AutoTrackEgress::_internal_has_azure() const {
  return output_case() == kAzure;
}
inline void AutoTrackEgress::set_has_azure() {
  _impl_._oneof_case_[0] = kAzure;
}
inline void AutoTrackEgress::clear_azure() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (output_case() == kAzure) {
    if (GetArena() == nullptr) {
      delete _impl_.output_.azure_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.output_.azure_);
    }
    clear_has_output();
  }
}
inline ::livekit::AzureBlobUpload* PROTOBUF_NULLABLE AutoTrackEgress::release_azure() {
  // @@protoc_insertion_point(field_release:livekit.AutoTrackEgress.azure)
  if (output_case() == kAzure) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::AzureBlobUpload*>(_impl_.output_.azure_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.azure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::AzureBlobUpload& AutoTrackEgress::_internal_azure() const {
  return output_case() == kAzure ? *reinterpret_cast<::livekit::AzureBlobUpload*>(_impl_.output_.azure_) : reinterpret_cast<::livekit::AzureBlobUpload&>(::livekit::_AzureBlobUpload_default_instance_);
}
inline const ::livekit::AzureBlobUpload& AutoTrackEgress::azure() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.AutoTrackEgress.azure)
  return _internal_azure();
}
inline ::livekit::AzureBlobUpload* PROTOBUF_NULLABLE AutoTrackEgress::unsafe_arena_release_azure() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.AutoTrackEgress.azure)
  if (output_case() == kAzure) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::AzureBlobUpload*>(_impl_.output_.azure_);
    _impl_.output_.azure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AutoTrackEgress::unsafe_arena_set_allocated_azure(
    ::livekit::AzureBlobUpload* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_output();
  if (value) {
    set_has_azure();
    _impl_.output_.azure_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.AutoTrackEgress.azure)
}
inline ::livekit::AzureBlobUpload* PROTOBUF_NONNULL AutoTrackEgress::_internal_mutable_azure() {
  if (output_case() != kAzure) {
    clear_output();
    set_has_azure();
    _impl_.output_.azure_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::AzureBlobUpload>(GetArena()));
  }
  return reinterpret_cast<::livekit::AzureBlobUpload*>(_impl_.output_.azure_);
}
inline ::livekit::AzureBlobUpload* PROTOBUF_NONNULL AutoTrackEgress::mutable_azure()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::AzureBlobUpload* _msg = _internal_mutable_azure();
  // @@protoc_insertion_point(field_mutable:livekit.AutoTrackEgress.azure)
  return _msg;
}

// .livekit.AliOSSUpload aliOSS = 6;
inline bool AutoTrackEgress::has_alioss() const {
  return output_case() == kAliOSS;
}
inline bool AutoTrackEgress::_internal_has_alioss() const {
  return output_case() == kAliOSS;
}
inline void AutoTrackEgress::set_has_alioss() {
  _impl_._oneof_case_[0] = kAliOSS;
}
inline void AutoTrackEgress::clear_alioss() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (output_case() == kAliOSS) {
    if (GetArena() == nullptr) {
      delete _impl_.output_.alioss_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.output_.alioss_);
    }
    clear_has_output();
  }
}
inline ::livekit::AliOSSUpload* PROTOBUF_NULLABLE AutoTrackEgress::release_alioss() {
  // @@protoc_insertion_point(field_release:livekit.AutoTrackEgress.aliOSS)
  if (output_case() == kAliOSS) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::AliOSSUpload*>(_impl_.output_.alioss_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.alioss_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::AliOSSUpload& AutoTrackEgress::_internal_alioss() const {
  return output_case() == kAliOSS ? *reinterpret_cast<::livekit::AliOSSUpload*>(_impl_.output_.alioss_) : reinterpret_cast<::livekit::AliOSSUpload&>(::livekit::_AliOSSUpload_default_instance_);
}
inline const ::livekit::AliOSSUpload& AutoTrackEgress::alioss() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.AutoTrackEgress.aliOSS)
  return _internal_alioss();
}
inline ::livekit::AliOSSUpload* PROTOBUF_NULLABLE AutoTrackEgress::unsafe_arena_release_alioss() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.AutoTrackEgress.aliOSS)
  if (output_case() == kAliOSS) {
    clear_has_output();
    auto* temp = reinterpret_cast<::livekit::AliOSSUpload*>(_impl_.output_.alioss_);
    _impl_.output_.alioss_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AutoTrackEgress::unsafe_arena_set_allocated_alioss(
    ::livekit::AliOSSUpload* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_output();
  if (value) {
    set_has_alioss();
    _impl_.output_.alioss_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.AutoTrackEgress.aliOSS)
}
inline ::livekit::AliOSSUpload* PROTOBUF_NONNULL AutoTrackEgress::_internal_mutable_alioss() {
  if (output_case() != kAliOSS) {
    clear_output();
    set_has_alioss();
    _impl_.output_.alioss_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::livekit::AliOSSUpload>(GetArena()));
  }
  return reinterpret_cast<::livekit::AliOSSUpload*>(_impl_.output_.alioss_);
}
inline ::livekit::AliOSSUpload* PROTOBUF_NONNULL AutoTrackEgress::mutable_alioss()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::AliOSSUpload* _msg = _internal_mutable_alioss();
  // @@protoc_insertion_point(field_mutable:livekit.AutoTrackEgress.aliOSS)
  return _msg;
}

inline bool AutoTrackEgress::has_output() const {
  return output_case() != OUTPUT_NOT_SET;
}
inline void AutoTrackEgress::clear_has_output() {
  _impl_._oneof_case_[0] = OUTPUT_NOT_SET;
}
inline AutoTrackEgress::OutputCase AutoTrackEgress::output_case() const {
  return AutoTrackEgress::OutputCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace livekit


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::livekit::StreamInfo_Status> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::livekit::StreamInfo_Status>() {
  return ::livekit::StreamInfo_Status_descriptor();
}
template <>
struct is_proto_enum<::livekit::EncodedFileType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::livekit::EncodedFileType>() {
  return ::livekit::EncodedFileType_descriptor();
}
template <>
struct is_proto_enum<::livekit::SegmentedFileProtocol> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::livekit::SegmentedFileProtocol>() {
  return ::livekit::SegmentedFileProtocol_descriptor();
}
template <>
struct is_proto_enum<::livekit::SegmentedFileSuffix> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::livekit::SegmentedFileSuffix>() {
  return ::livekit::SegmentedFileSuffix_descriptor();
}
template <>
struct is_proto_enum<::livekit::ImageFileSuffix> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::livekit::ImageFileSuffix>() {
  return ::livekit::ImageFileSuffix_descriptor();
}
template <>
struct is_proto_enum<::livekit::StreamProtocol> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::livekit::StreamProtocol>() {
  return ::livekit::StreamProtocol_descriptor();
}
template <>
struct is_proto_enum<::livekit::AudioMixing> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::livekit::AudioMixing>() {
  return ::livekit::AudioMixing_descriptor();
}
template <>
struct is_proto_enum<::livekit::EncodingOptionsPreset> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::livekit::EncodingOptionsPreset>() {
  return ::livekit::EncodingOptionsPreset_descriptor();
}
template <>
struct is_proto_enum<::livekit::EgressStatus> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::livekit::EgressStatus>() {
  return ::livekit::EgressStatus_descriptor();
}
template <>
struct is_proto_enum<::livekit::EgressSourceType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::livekit::EgressSourceType>() {
  return ::livekit::EgressSourceType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // livekit_5fegress_2eproto_2epb_2eh
