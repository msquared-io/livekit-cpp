// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: livekit_ingress.proto
// Protobuf C++ Version: 6.30.1

#ifndef livekit_5fingress_2eproto_2epb_2eh
#define livekit_5fingress_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6030001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "livekit_models.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_livekit_5fingress_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_livekit_5fingress_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_livekit_5fingress_2eproto;
}  // extern "C"
namespace livekit {
enum IngressAudioEncodingPreset : int;
extern const uint32_t IngressAudioEncodingPreset_internal_data_[];
enum IngressInput : int;
extern const uint32_t IngressInput_internal_data_[];
enum IngressState_Status : int;
extern const uint32_t IngressState_Status_internal_data_[];
enum IngressVideoEncodingPreset : int;
extern const uint32_t IngressVideoEncodingPreset_internal_data_[];
class CreateIngressRequest;
struct CreateIngressRequestDefaultTypeInternal;
extern CreateIngressRequestDefaultTypeInternal _CreateIngressRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CreateIngressRequest_class_data_;
class DeleteIngressRequest;
struct DeleteIngressRequestDefaultTypeInternal;
extern DeleteIngressRequestDefaultTypeInternal _DeleteIngressRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DeleteIngressRequest_class_data_;
class IngressAudioEncodingOptions;
struct IngressAudioEncodingOptionsDefaultTypeInternal;
extern IngressAudioEncodingOptionsDefaultTypeInternal _IngressAudioEncodingOptions_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull IngressAudioEncodingOptions_class_data_;
class IngressAudioOptions;
struct IngressAudioOptionsDefaultTypeInternal;
extern IngressAudioOptionsDefaultTypeInternal _IngressAudioOptions_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull IngressAudioOptions_class_data_;
class IngressInfo;
struct IngressInfoDefaultTypeInternal;
extern IngressInfoDefaultTypeInternal _IngressInfo_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull IngressInfo_class_data_;
class IngressState;
struct IngressStateDefaultTypeInternal;
extern IngressStateDefaultTypeInternal _IngressState_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull IngressState_class_data_;
class IngressVideoEncodingOptions;
struct IngressVideoEncodingOptionsDefaultTypeInternal;
extern IngressVideoEncodingOptionsDefaultTypeInternal _IngressVideoEncodingOptions_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull IngressVideoEncodingOptions_class_data_;
class IngressVideoOptions;
struct IngressVideoOptionsDefaultTypeInternal;
extern IngressVideoOptionsDefaultTypeInternal _IngressVideoOptions_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull IngressVideoOptions_class_data_;
class InputAudioState;
struct InputAudioStateDefaultTypeInternal;
extern InputAudioStateDefaultTypeInternal _InputAudioState_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InputAudioState_class_data_;
class InputVideoState;
struct InputVideoStateDefaultTypeInternal;
extern InputVideoStateDefaultTypeInternal _InputVideoState_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InputVideoState_class_data_;
class ListIngressRequest;
struct ListIngressRequestDefaultTypeInternal;
extern ListIngressRequestDefaultTypeInternal _ListIngressRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ListIngressRequest_class_data_;
class ListIngressResponse;
struct ListIngressResponseDefaultTypeInternal;
extern ListIngressResponseDefaultTypeInternal _ListIngressResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ListIngressResponse_class_data_;
class UpdateIngressRequest;
struct UpdateIngressRequestDefaultTypeInternal;
extern UpdateIngressRequestDefaultTypeInternal _UpdateIngressRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UpdateIngressRequest_class_data_;
}  // namespace livekit
namespace google {
namespace protobuf {
template <>
internal::EnumTraitsT<::livekit::IngressAudioEncodingPreset_internal_data_>
    internal::EnumTraitsImpl::value<::livekit::IngressAudioEncodingPreset>;
template <>
internal::EnumTraitsT<::livekit::IngressInput_internal_data_>
    internal::EnumTraitsImpl::value<::livekit::IngressInput>;
template <>
internal::EnumTraitsT<::livekit::IngressState_Status_internal_data_>
    internal::EnumTraitsImpl::value<::livekit::IngressState_Status>;
template <>
internal::EnumTraitsT<::livekit::IngressVideoEncodingPreset_internal_data_>
    internal::EnumTraitsImpl::value<::livekit::IngressVideoEncodingPreset>;
}  // namespace protobuf
}  // namespace google

namespace livekit {
enum IngressState_Status : int {
  IngressState_Status_ENDPOINT_INACTIVE = 0,
  IngressState_Status_ENDPOINT_BUFFERING = 1,
  IngressState_Status_ENDPOINT_PUBLISHING = 2,
  IngressState_Status_ENDPOINT_ERROR = 3,
  IngressState_Status_ENDPOINT_COMPLETE = 4,
  IngressState_Status_IngressState_Status_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  IngressState_Status_IngressState_Status_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t IngressState_Status_internal_data_[];
inline constexpr IngressState_Status IngressState_Status_Status_MIN =
    static_cast<IngressState_Status>(0);
inline constexpr IngressState_Status IngressState_Status_Status_MAX =
    static_cast<IngressState_Status>(4);
inline bool IngressState_Status_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int IngressState_Status_Status_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL IngressState_Status_descriptor();
template <typename T>
const std::string& IngressState_Status_Name(T value) {
  static_assert(std::is_same<T, IngressState_Status>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Status_Name().");
  return IngressState_Status_Name(static_cast<IngressState_Status>(value));
}
template <>
inline const std::string& IngressState_Status_Name(IngressState_Status value) {
  return ::google::protobuf::internal::NameOfDenseEnum<IngressState_Status_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool IngressState_Status_Parse(
    absl::string_view name, IngressState_Status* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<IngressState_Status>(IngressState_Status_descriptor(), name,
                                           value);
}
enum IngressInput : int {
  RTMP_INPUT = 0,
  WHIP_INPUT = 1,
  URL_INPUT = 2,
  IngressInput_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  IngressInput_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t IngressInput_internal_data_[];
inline constexpr IngressInput IngressInput_MIN =
    static_cast<IngressInput>(0);
inline constexpr IngressInput IngressInput_MAX =
    static_cast<IngressInput>(2);
inline bool IngressInput_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int IngressInput_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL IngressInput_descriptor();
template <typename T>
const std::string& IngressInput_Name(T value) {
  static_assert(std::is_same<T, IngressInput>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to IngressInput_Name().");
  return IngressInput_Name(static_cast<IngressInput>(value));
}
template <>
inline const std::string& IngressInput_Name(IngressInput value) {
  return ::google::protobuf::internal::NameOfDenseEnum<IngressInput_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool IngressInput_Parse(
    absl::string_view name, IngressInput* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<IngressInput>(IngressInput_descriptor(), name,
                                           value);
}
enum IngressAudioEncodingPreset : int {
  OPUS_STEREO_96KBPS = 0,
  OPUS_MONO_64KBS = 1,
  IngressAudioEncodingPreset_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  IngressAudioEncodingPreset_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t IngressAudioEncodingPreset_internal_data_[];
inline constexpr IngressAudioEncodingPreset IngressAudioEncodingPreset_MIN =
    static_cast<IngressAudioEncodingPreset>(0);
inline constexpr IngressAudioEncodingPreset IngressAudioEncodingPreset_MAX =
    static_cast<IngressAudioEncodingPreset>(1);
inline bool IngressAudioEncodingPreset_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int IngressAudioEncodingPreset_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL IngressAudioEncodingPreset_descriptor();
template <typename T>
const std::string& IngressAudioEncodingPreset_Name(T value) {
  static_assert(std::is_same<T, IngressAudioEncodingPreset>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to IngressAudioEncodingPreset_Name().");
  return IngressAudioEncodingPreset_Name(static_cast<IngressAudioEncodingPreset>(value));
}
template <>
inline const std::string& IngressAudioEncodingPreset_Name(IngressAudioEncodingPreset value) {
  return ::google::protobuf::internal::NameOfDenseEnum<IngressAudioEncodingPreset_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool IngressAudioEncodingPreset_Parse(
    absl::string_view name, IngressAudioEncodingPreset* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<IngressAudioEncodingPreset>(IngressAudioEncodingPreset_descriptor(), name,
                                           value);
}
enum IngressVideoEncodingPreset : int {
  H264_720P_30FPS_3_LAYERS = 0,
  H264_1080P_30FPS_3_LAYERS = 1,
  H264_540P_25FPS_2_LAYERS = 2,
  H264_720P_30FPS_1_LAYER = 3,
  H264_1080P_30FPS_1_LAYER = 4,
  H264_720P_30FPS_3_LAYERS_HIGH_MOTION = 5,
  H264_1080P_30FPS_3_LAYERS_HIGH_MOTION = 6,
  H264_540P_25FPS_2_LAYERS_HIGH_MOTION = 7,
  H264_720P_30FPS_1_LAYER_HIGH_MOTION = 8,
  H264_1080P_30FPS_1_LAYER_HIGH_MOTION = 9,
  IngressVideoEncodingPreset_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  IngressVideoEncodingPreset_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t IngressVideoEncodingPreset_internal_data_[];
inline constexpr IngressVideoEncodingPreset IngressVideoEncodingPreset_MIN =
    static_cast<IngressVideoEncodingPreset>(0);
inline constexpr IngressVideoEncodingPreset IngressVideoEncodingPreset_MAX =
    static_cast<IngressVideoEncodingPreset>(9);
inline bool IngressVideoEncodingPreset_IsValid(int value) {
  return 0 <= value && value <= 9;
}
inline constexpr int IngressVideoEncodingPreset_ARRAYSIZE = 9 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL IngressVideoEncodingPreset_descriptor();
template <typename T>
const std::string& IngressVideoEncodingPreset_Name(T value) {
  static_assert(std::is_same<T, IngressVideoEncodingPreset>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to IngressVideoEncodingPreset_Name().");
  return IngressVideoEncodingPreset_Name(static_cast<IngressVideoEncodingPreset>(value));
}
template <>
inline const std::string& IngressVideoEncodingPreset_Name(IngressVideoEncodingPreset value) {
  return ::google::protobuf::internal::NameOfDenseEnum<IngressVideoEncodingPreset_descriptor, 0, 9>(
      static_cast<int>(value));
}
inline bool IngressVideoEncodingPreset_Parse(
    absl::string_view name, IngressVideoEncodingPreset* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<IngressVideoEncodingPreset>(IngressVideoEncodingPreset_descriptor(), name,
                                           value);
}

// ===================================================================


// -------------------------------------------------------------------

class ListIngressRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.ListIngressRequest) */ {
 public:
  inline ListIngressRequest() : ListIngressRequest(nullptr) {}
  ~ListIngressRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ListIngressRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ListIngressRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListIngressRequest(::google::protobuf::internal::ConstantInitialized);

  inline ListIngressRequest(const ListIngressRequest& from) : ListIngressRequest(nullptr, from) {}
  inline ListIngressRequest(ListIngressRequest&& from) noexcept
      : ListIngressRequest(nullptr, std::move(from)) {}
  inline ListIngressRequest& operator=(const ListIngressRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListIngressRequest& operator=(ListIngressRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListIngressRequest& default_instance() {
    return *reinterpret_cast<const ListIngressRequest*>(
        &_ListIngressRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(ListIngressRequest& a, ListIngressRequest& b) { a.Swap(&b); }
  inline void Swap(ListIngressRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListIngressRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListIngressRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ListIngressRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListIngressRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListIngressRequest& from) { ListIngressRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ListIngressRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.ListIngressRequest"; }

 protected:
  explicit ListIngressRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ListIngressRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ListIngressRequest& from);
  ListIngressRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ListIngressRequest&& from) noexcept
      : ListIngressRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRoomNameFieldNumber = 1,
    kIngressIdFieldNumber = 2,
  };
  // string room_name = 1;
  void clear_room_name() ;
  const std::string& room_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_room_name(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_room_name();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_room_name();
  void set_allocated_room_name(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_room_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_room_name(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_room_name();

  public:
  // string ingress_id = 2;
  void clear_ingress_id() ;
  const std::string& ingress_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ingress_id(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_ingress_id();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_ingress_id();
  void set_allocated_ingress_id(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_ingress_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_ingress_id(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_ingress_id();

  public:
  // @@protoc_insertion_point(class_scope:livekit.ListIngressRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 54,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ListIngressRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr room_name_;
    ::google::protobuf::internal::ArenaStringPtr ingress_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fingress_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ListIngressRequest_class_data_;
// -------------------------------------------------------------------

class InputVideoState final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.InputVideoState) */ {
 public:
  inline InputVideoState() : InputVideoState(nullptr) {}
  ~InputVideoState() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InputVideoState* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InputVideoState));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InputVideoState(::google::protobuf::internal::ConstantInitialized);

  inline InputVideoState(const InputVideoState& from) : InputVideoState(nullptr, from) {}
  inline InputVideoState(InputVideoState&& from) noexcept
      : InputVideoState(nullptr, std::move(from)) {}
  inline InputVideoState& operator=(const InputVideoState& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputVideoState& operator=(InputVideoState&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InputVideoState& default_instance() {
    return *reinterpret_cast<const InputVideoState*>(
        &_InputVideoState_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(InputVideoState& a, InputVideoState& b) { a.Swap(&b); }
  inline void Swap(InputVideoState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InputVideoState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InputVideoState* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<InputVideoState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InputVideoState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InputVideoState& from) { InputVideoState::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(InputVideoState* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.InputVideoState"; }

 protected:
  explicit InputVideoState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InputVideoState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InputVideoState& from);
  InputVideoState(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InputVideoState&& from) noexcept
      : InputVideoState(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMimeTypeFieldNumber = 1,
    kAverageBitrateFieldNumber = 2,
    kWidthFieldNumber = 3,
    kFramerateFieldNumber = 5,
    kHeightFieldNumber = 4,
  };
  // string mime_type = 1;
  void clear_mime_type() ;
  const std::string& mime_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mime_type(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_mime_type();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_mime_type();
  void set_allocated_mime_type(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_mime_type() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_mime_type(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_mime_type();

  public:
  // uint32 average_bitrate = 2;
  void clear_average_bitrate() ;
  ::uint32_t average_bitrate() const;
  void set_average_bitrate(::uint32_t value);

  private:
  ::uint32_t _internal_average_bitrate() const;
  void _internal_set_average_bitrate(::uint32_t value);

  public:
  // uint32 width = 3;
  void clear_width() ;
  ::uint32_t width() const;
  void set_width(::uint32_t value);

  private:
  ::uint32_t _internal_width() const;
  void _internal_set_width(::uint32_t value);

  public:
  // double framerate = 5;
  void clear_framerate() ;
  double framerate() const;
  void set_framerate(double value);

  private:
  double _internal_framerate() const;
  void _internal_set_framerate(double value);

  public:
  // uint32 height = 4;
  void clear_height() ;
  ::uint32_t height() const;
  void set_height(::uint32_t value);

  private:
  ::uint32_t _internal_height() const;
  void _internal_set_height(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.InputVideoState)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   0, 41,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const InputVideoState& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr mime_type_;
    ::uint32_t average_bitrate_;
    ::uint32_t width_;
    double framerate_;
    ::uint32_t height_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fingress_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull InputVideoState_class_data_;
// -------------------------------------------------------------------

class InputAudioState final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.InputAudioState) */ {
 public:
  inline InputAudioState() : InputAudioState(nullptr) {}
  ~InputAudioState() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InputAudioState* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InputAudioState));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InputAudioState(::google::protobuf::internal::ConstantInitialized);

  inline InputAudioState(const InputAudioState& from) : InputAudioState(nullptr, from) {}
  inline InputAudioState(InputAudioState&& from) noexcept
      : InputAudioState(nullptr, std::move(from)) {}
  inline InputAudioState& operator=(const InputAudioState& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputAudioState& operator=(InputAudioState&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InputAudioState& default_instance() {
    return *reinterpret_cast<const InputAudioState*>(
        &_InputAudioState_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(InputAudioState& a, InputAudioState& b) { a.Swap(&b); }
  inline void Swap(InputAudioState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InputAudioState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InputAudioState* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<InputAudioState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InputAudioState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InputAudioState& from) { InputAudioState::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(InputAudioState* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.InputAudioState"; }

 protected:
  explicit InputAudioState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InputAudioState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InputAudioState& from);
  InputAudioState(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InputAudioState&& from) noexcept
      : InputAudioState(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMimeTypeFieldNumber = 1,
    kAverageBitrateFieldNumber = 2,
    kChannelsFieldNumber = 3,
    kSampleRateFieldNumber = 4,
  };
  // string mime_type = 1;
  void clear_mime_type() ;
  const std::string& mime_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mime_type(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_mime_type();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_mime_type();
  void set_allocated_mime_type(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_mime_type() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_mime_type(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_mime_type();

  public:
  // uint32 average_bitrate = 2;
  void clear_average_bitrate() ;
  ::uint32_t average_bitrate() const;
  void set_average_bitrate(::uint32_t value);

  private:
  ::uint32_t _internal_average_bitrate() const;
  void _internal_set_average_bitrate(::uint32_t value);

  public:
  // uint32 channels = 3;
  void clear_channels() ;
  ::uint32_t channels() const;
  void set_channels(::uint32_t value);

  private:
  ::uint32_t _internal_channels() const;
  void _internal_set_channels(::uint32_t value);

  public:
  // uint32 sample_rate = 4;
  void clear_sample_rate() ;
  ::uint32_t sample_rate() const;
  void set_sample_rate(::uint32_t value);

  private:
  ::uint32_t _internal_sample_rate() const;
  void _internal_set_sample_rate(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.InputAudioState)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 41,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const InputAudioState& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr mime_type_;
    ::uint32_t average_bitrate_;
    ::uint32_t channels_;
    ::uint32_t sample_rate_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fingress_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull InputAudioState_class_data_;
// -------------------------------------------------------------------

class IngressAudioEncodingOptions final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.IngressAudioEncodingOptions) */ {
 public:
  inline IngressAudioEncodingOptions() : IngressAudioEncodingOptions(nullptr) {}
  ~IngressAudioEncodingOptions() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(IngressAudioEncodingOptions* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(IngressAudioEncodingOptions));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR IngressAudioEncodingOptions(::google::protobuf::internal::ConstantInitialized);

  inline IngressAudioEncodingOptions(const IngressAudioEncodingOptions& from) : IngressAudioEncodingOptions(nullptr, from) {}
  inline IngressAudioEncodingOptions(IngressAudioEncodingOptions&& from) noexcept
      : IngressAudioEncodingOptions(nullptr, std::move(from)) {}
  inline IngressAudioEncodingOptions& operator=(const IngressAudioEncodingOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline IngressAudioEncodingOptions& operator=(IngressAudioEncodingOptions&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IngressAudioEncodingOptions& default_instance() {
    return *reinterpret_cast<const IngressAudioEncodingOptions*>(
        &_IngressAudioEncodingOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(IngressAudioEncodingOptions& a, IngressAudioEncodingOptions& b) { a.Swap(&b); }
  inline void Swap(IngressAudioEncodingOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IngressAudioEncodingOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IngressAudioEncodingOptions* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<IngressAudioEncodingOptions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const IngressAudioEncodingOptions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const IngressAudioEncodingOptions& from) { IngressAudioEncodingOptions::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(IngressAudioEncodingOptions* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.IngressAudioEncodingOptions"; }

 protected:
  explicit IngressAudioEncodingOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  IngressAudioEncodingOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const IngressAudioEncodingOptions& from);
  IngressAudioEncodingOptions(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, IngressAudioEncodingOptions&& from) noexcept
      : IngressAudioEncodingOptions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAudioCodecFieldNumber = 1,
    kBitrateFieldNumber = 2,
    kDisableDtxFieldNumber = 3,
    kChannelsFieldNumber = 4,
  };
  // .livekit.AudioCodec audio_codec = 1;
  void clear_audio_codec() ;
  ::livekit::AudioCodec audio_codec() const;
  void set_audio_codec(::livekit::AudioCodec value);

  private:
  ::livekit::AudioCodec _internal_audio_codec() const;
  void _internal_set_audio_codec(::livekit::AudioCodec value);

  public:
  // uint32 bitrate = 2;
  void clear_bitrate() ;
  ::uint32_t bitrate() const;
  void set_bitrate(::uint32_t value);

  private:
  ::uint32_t _internal_bitrate() const;
  void _internal_set_bitrate(::uint32_t value);

  public:
  // bool disable_dtx = 3;
  void clear_disable_dtx() ;
  bool disable_dtx() const;
  void set_disable_dtx(bool value);

  private:
  bool _internal_disable_dtx() const;
  void _internal_set_disable_dtx(bool value);

  public:
  // uint32 channels = 4;
  void clear_channels() ;
  ::uint32_t channels() const;
  void set_channels(::uint32_t value);

  private:
  ::uint32_t _internal_channels() const;
  void _internal_set_channels(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.IngressAudioEncodingOptions)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const IngressAudioEncodingOptions& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int audio_codec_;
    ::uint32_t bitrate_;
    bool disable_dtx_;
    ::uint32_t channels_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fingress_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull IngressAudioEncodingOptions_class_data_;
// -------------------------------------------------------------------

class DeleteIngressRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.DeleteIngressRequest) */ {
 public:
  inline DeleteIngressRequest() : DeleteIngressRequest(nullptr) {}
  ~DeleteIngressRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeleteIngressRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeleteIngressRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteIngressRequest(::google::protobuf::internal::ConstantInitialized);

  inline DeleteIngressRequest(const DeleteIngressRequest& from) : DeleteIngressRequest(nullptr, from) {}
  inline DeleteIngressRequest(DeleteIngressRequest&& from) noexcept
      : DeleteIngressRequest(nullptr, std::move(from)) {}
  inline DeleteIngressRequest& operator=(const DeleteIngressRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteIngressRequest& operator=(DeleteIngressRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteIngressRequest& default_instance() {
    return *reinterpret_cast<const DeleteIngressRequest*>(
        &_DeleteIngressRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(DeleteIngressRequest& a, DeleteIngressRequest& b) { a.Swap(&b); }
  inline void Swap(DeleteIngressRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteIngressRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteIngressRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeleteIngressRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteIngressRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeleteIngressRequest& from) { DeleteIngressRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeleteIngressRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.DeleteIngressRequest"; }

 protected:
  explicit DeleteIngressRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DeleteIngressRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DeleteIngressRequest& from);
  DeleteIngressRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DeleteIngressRequest&& from) noexcept
      : DeleteIngressRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIngressIdFieldNumber = 1,
  };
  // string ingress_id = 1;
  void clear_ingress_id() ;
  const std::string& ingress_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ingress_id(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_ingress_id();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_ingress_id();
  void set_allocated_ingress_id(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_ingress_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_ingress_id(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_ingress_id();

  public:
  // @@protoc_insertion_point(class_scope:livekit.DeleteIngressRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 47,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DeleteIngressRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr ingress_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fingress_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DeleteIngressRequest_class_data_;
// -------------------------------------------------------------------

class IngressVideoEncodingOptions final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.IngressVideoEncodingOptions) */ {
 public:
  inline IngressVideoEncodingOptions() : IngressVideoEncodingOptions(nullptr) {}
  ~IngressVideoEncodingOptions() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(IngressVideoEncodingOptions* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(IngressVideoEncodingOptions));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR IngressVideoEncodingOptions(::google::protobuf::internal::ConstantInitialized);

  inline IngressVideoEncodingOptions(const IngressVideoEncodingOptions& from) : IngressVideoEncodingOptions(nullptr, from) {}
  inline IngressVideoEncodingOptions(IngressVideoEncodingOptions&& from) noexcept
      : IngressVideoEncodingOptions(nullptr, std::move(from)) {}
  inline IngressVideoEncodingOptions& operator=(const IngressVideoEncodingOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline IngressVideoEncodingOptions& operator=(IngressVideoEncodingOptions&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IngressVideoEncodingOptions& default_instance() {
    return *reinterpret_cast<const IngressVideoEncodingOptions*>(
        &_IngressVideoEncodingOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(IngressVideoEncodingOptions& a, IngressVideoEncodingOptions& b) { a.Swap(&b); }
  inline void Swap(IngressVideoEncodingOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IngressVideoEncodingOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IngressVideoEncodingOptions* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<IngressVideoEncodingOptions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const IngressVideoEncodingOptions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const IngressVideoEncodingOptions& from) { IngressVideoEncodingOptions::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(IngressVideoEncodingOptions* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.IngressVideoEncodingOptions"; }

 protected:
  explicit IngressVideoEncodingOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  IngressVideoEncodingOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const IngressVideoEncodingOptions& from);
  IngressVideoEncodingOptions(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, IngressVideoEncodingOptions&& from) noexcept
      : IngressVideoEncodingOptions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLayersFieldNumber = 3,
    kFrameRateFieldNumber = 2,
    kVideoCodecFieldNumber = 1,
  };
  // repeated .livekit.VideoLayer layers = 3;
  int layers_size() const;
  private:
  int _internal_layers_size() const;

  public:
  void clear_layers() ;
  ::livekit::VideoLayer* PROTOBUF_NONNULL mutable_layers(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::VideoLayer>* PROTOBUF_NONNULL mutable_layers();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::VideoLayer>& _internal_layers() const;
  ::google::protobuf::RepeatedPtrField<::livekit::VideoLayer>* PROTOBUF_NONNULL _internal_mutable_layers();
  public:
  const ::livekit::VideoLayer& layers(int index) const;
  ::livekit::VideoLayer* PROTOBUF_NONNULL add_layers();
  const ::google::protobuf::RepeatedPtrField<::livekit::VideoLayer>& layers() const;
  // double frame_rate = 2;
  void clear_frame_rate() ;
  double frame_rate() const;
  void set_frame_rate(double value);

  private:
  double _internal_frame_rate() const;
  void _internal_set_frame_rate(double value);

  public:
  // .livekit.VideoCodec video_codec = 1;
  void clear_video_codec() ;
  ::livekit::VideoCodec video_codec() const;
  void set_video_codec(::livekit::VideoCodec value);

  private:
  ::livekit::VideoCodec _internal_video_codec() const;
  void _internal_set_video_codec(::livekit::VideoCodec value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.IngressVideoEncodingOptions)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const IngressVideoEncodingOptions& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::livekit::VideoLayer > layers_;
    double frame_rate_;
    int video_codec_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fingress_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull IngressVideoEncodingOptions_class_data_;
// -------------------------------------------------------------------

class IngressAudioOptions final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.IngressAudioOptions) */ {
 public:
  inline IngressAudioOptions() : IngressAudioOptions(nullptr) {}
  ~IngressAudioOptions() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(IngressAudioOptions* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(IngressAudioOptions));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR IngressAudioOptions(::google::protobuf::internal::ConstantInitialized);

  inline IngressAudioOptions(const IngressAudioOptions& from) : IngressAudioOptions(nullptr, from) {}
  inline IngressAudioOptions(IngressAudioOptions&& from) noexcept
      : IngressAudioOptions(nullptr, std::move(from)) {}
  inline IngressAudioOptions& operator=(const IngressAudioOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline IngressAudioOptions& operator=(IngressAudioOptions&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IngressAudioOptions& default_instance() {
    return *reinterpret_cast<const IngressAudioOptions*>(
        &_IngressAudioOptions_default_instance_);
  }
  enum EncodingOptionsCase {
    kPreset = 3,
    kOptions = 4,
    ENCODING_OPTIONS_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(IngressAudioOptions& a, IngressAudioOptions& b) { a.Swap(&b); }
  inline void Swap(IngressAudioOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IngressAudioOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IngressAudioOptions* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<IngressAudioOptions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const IngressAudioOptions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const IngressAudioOptions& from) { IngressAudioOptions::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(IngressAudioOptions* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.IngressAudioOptions"; }

 protected:
  explicit IngressAudioOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  IngressAudioOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const IngressAudioOptions& from);
  IngressAudioOptions(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, IngressAudioOptions&& from) noexcept
      : IngressAudioOptions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kSourceFieldNumber = 2,
    kPresetFieldNumber = 3,
    kOptionsFieldNumber = 4,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // .livekit.TrackSource source = 2;
  void clear_source() ;
  ::livekit::TrackSource source() const;
  void set_source(::livekit::TrackSource value);

  private:
  ::livekit::TrackSource _internal_source() const;
  void _internal_set_source(::livekit::TrackSource value);

  public:
  // .livekit.IngressAudioEncodingPreset preset = 3;
  bool has_preset() const;
  void clear_preset() ;
  ::livekit::IngressAudioEncodingPreset preset() const;
  void set_preset(::livekit::IngressAudioEncodingPreset value);

  private:
  ::livekit::IngressAudioEncodingPreset _internal_preset() const;
  void _internal_set_preset(::livekit::IngressAudioEncodingPreset value);

  public:
  // .livekit.IngressAudioEncodingOptions options = 4;
  bool has_options() const;
  private:
  bool _internal_has_options() const;

  public:
  void clear_options() ;
  const ::livekit::IngressAudioEncodingOptions& options() const;
  [[nodiscard]] ::livekit::IngressAudioEncodingOptions* PROTOBUF_NULLABLE release_options();
  ::livekit::IngressAudioEncodingOptions* PROTOBUF_NONNULL mutable_options();
  void set_allocated_options(::livekit::IngressAudioEncodingOptions* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_options(::livekit::IngressAudioEncodingOptions* PROTOBUF_NULLABLE value);
  ::livekit::IngressAudioEncodingOptions* PROTOBUF_NULLABLE unsafe_arena_release_options();

  private:
  const ::livekit::IngressAudioEncodingOptions& _internal_options() const;
  ::livekit::IngressAudioEncodingOptions* PROTOBUF_NONNULL _internal_mutable_options();

  public:
  void clear_encoding_options();
  EncodingOptionsCase encoding_options_case() const;
  // @@protoc_insertion_point(class_scope:livekit.IngressAudioOptions)
 private:
  class _Internal;
  void set_has_preset();
  void set_has_options();
  inline bool has_encoding_options() const;
  inline void clear_has_encoding_options();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 4,
                                   1, 40,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const IngressAudioOptions& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    int source_;
    union EncodingOptionsUnion {
      constexpr EncodingOptionsUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      int preset_;
      ::livekit::IngressAudioEncodingOptions* PROTOBUF_NULLABLE options_;
    } encoding_options_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fingress_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull IngressAudioOptions_class_data_;
// -------------------------------------------------------------------

class IngressVideoOptions final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.IngressVideoOptions) */ {
 public:
  inline IngressVideoOptions() : IngressVideoOptions(nullptr) {}
  ~IngressVideoOptions() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(IngressVideoOptions* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(IngressVideoOptions));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR IngressVideoOptions(::google::protobuf::internal::ConstantInitialized);

  inline IngressVideoOptions(const IngressVideoOptions& from) : IngressVideoOptions(nullptr, from) {}
  inline IngressVideoOptions(IngressVideoOptions&& from) noexcept
      : IngressVideoOptions(nullptr, std::move(from)) {}
  inline IngressVideoOptions& operator=(const IngressVideoOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline IngressVideoOptions& operator=(IngressVideoOptions&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IngressVideoOptions& default_instance() {
    return *reinterpret_cast<const IngressVideoOptions*>(
        &_IngressVideoOptions_default_instance_);
  }
  enum EncodingOptionsCase {
    kPreset = 3,
    kOptions = 4,
    ENCODING_OPTIONS_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(IngressVideoOptions& a, IngressVideoOptions& b) { a.Swap(&b); }
  inline void Swap(IngressVideoOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IngressVideoOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IngressVideoOptions* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<IngressVideoOptions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const IngressVideoOptions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const IngressVideoOptions& from) { IngressVideoOptions::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(IngressVideoOptions* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.IngressVideoOptions"; }

 protected:
  explicit IngressVideoOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  IngressVideoOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const IngressVideoOptions& from);
  IngressVideoOptions(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, IngressVideoOptions&& from) noexcept
      : IngressVideoOptions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kSourceFieldNumber = 2,
    kPresetFieldNumber = 3,
    kOptionsFieldNumber = 4,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // .livekit.TrackSource source = 2;
  void clear_source() ;
  ::livekit::TrackSource source() const;
  void set_source(::livekit::TrackSource value);

  private:
  ::livekit::TrackSource _internal_source() const;
  void _internal_set_source(::livekit::TrackSource value);

  public:
  // .livekit.IngressVideoEncodingPreset preset = 3;
  bool has_preset() const;
  void clear_preset() ;
  ::livekit::IngressVideoEncodingPreset preset() const;
  void set_preset(::livekit::IngressVideoEncodingPreset value);

  private:
  ::livekit::IngressVideoEncodingPreset _internal_preset() const;
  void _internal_set_preset(::livekit::IngressVideoEncodingPreset value);

  public:
  // .livekit.IngressVideoEncodingOptions options = 4;
  bool has_options() const;
  private:
  bool _internal_has_options() const;

  public:
  void clear_options() ;
  const ::livekit::IngressVideoEncodingOptions& options() const;
  [[nodiscard]] ::livekit::IngressVideoEncodingOptions* PROTOBUF_NULLABLE release_options();
  ::livekit::IngressVideoEncodingOptions* PROTOBUF_NONNULL mutable_options();
  void set_allocated_options(::livekit::IngressVideoEncodingOptions* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_options(::livekit::IngressVideoEncodingOptions* PROTOBUF_NULLABLE value);
  ::livekit::IngressVideoEncodingOptions* PROTOBUF_NULLABLE unsafe_arena_release_options();

  private:
  const ::livekit::IngressVideoEncodingOptions& _internal_options() const;
  ::livekit::IngressVideoEncodingOptions* PROTOBUF_NONNULL _internal_mutable_options();

  public:
  void clear_encoding_options();
  EncodingOptionsCase encoding_options_case() const;
  // @@protoc_insertion_point(class_scope:livekit.IngressVideoOptions)
 private:
  class _Internal;
  void set_has_preset();
  void set_has_options();
  inline bool has_encoding_options() const;
  inline void clear_has_encoding_options();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 4,
                                   1, 40,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const IngressVideoOptions& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    int source_;
    union EncodingOptionsUnion {
      constexpr EncodingOptionsUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      int preset_;
      ::livekit::IngressVideoEncodingOptions* PROTOBUF_NULLABLE options_;
    } encoding_options_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fingress_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull IngressVideoOptions_class_data_;
// -------------------------------------------------------------------

class UpdateIngressRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.UpdateIngressRequest) */ {
 public:
  inline UpdateIngressRequest() : UpdateIngressRequest(nullptr) {}
  ~UpdateIngressRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateIngressRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateIngressRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateIngressRequest(::google::protobuf::internal::ConstantInitialized);

  inline UpdateIngressRequest(const UpdateIngressRequest& from) : UpdateIngressRequest(nullptr, from) {}
  inline UpdateIngressRequest(UpdateIngressRequest&& from) noexcept
      : UpdateIngressRequest(nullptr, std::move(from)) {}
  inline UpdateIngressRequest& operator=(const UpdateIngressRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateIngressRequest& operator=(UpdateIngressRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateIngressRequest& default_instance() {
    return *reinterpret_cast<const UpdateIngressRequest*>(
        &_UpdateIngressRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(UpdateIngressRequest& a, UpdateIngressRequest& b) { a.Swap(&b); }
  inline void Swap(UpdateIngressRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateIngressRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateIngressRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateIngressRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateIngressRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateIngressRequest& from) { UpdateIngressRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateIngressRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.UpdateIngressRequest"; }

 protected:
  explicit UpdateIngressRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UpdateIngressRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UpdateIngressRequest& from);
  UpdateIngressRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UpdateIngressRequest&& from) noexcept
      : UpdateIngressRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIngressIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kRoomNameFieldNumber = 3,
    kParticipantIdentityFieldNumber = 4,
    kParticipantNameFieldNumber = 5,
    kParticipantMetadataFieldNumber = 9,
    kAudioFieldNumber = 6,
    kVideoFieldNumber = 7,
    kBypassTranscodingFieldNumber = 8,
    kEnableTranscodingFieldNumber = 10,
    kEnabledFieldNumber = 11,
  };
  // string ingress_id = 1;
  void clear_ingress_id() ;
  const std::string& ingress_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ingress_id(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_ingress_id();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_ingress_id();
  void set_allocated_ingress_id(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_ingress_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_ingress_id(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_ingress_id();

  public:
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // string room_name = 3;
  void clear_room_name() ;
  const std::string& room_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_room_name(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_room_name();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_room_name();
  void set_allocated_room_name(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_room_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_room_name(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_room_name();

  public:
  // string participant_identity = 4;
  void clear_participant_identity() ;
  const std::string& participant_identity() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_participant_identity(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_participant_identity();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_participant_identity();
  void set_allocated_participant_identity(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_participant_identity() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_participant_identity(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_participant_identity();

  public:
  // string participant_name = 5;
  void clear_participant_name() ;
  const std::string& participant_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_participant_name(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_participant_name();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_participant_name();
  void set_allocated_participant_name(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_participant_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_participant_name(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_participant_name();

  public:
  // string participant_metadata = 9;
  void clear_participant_metadata() ;
  const std::string& participant_metadata() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_participant_metadata(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_participant_metadata();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_participant_metadata();
  void set_allocated_participant_metadata(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_participant_metadata() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_participant_metadata(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_participant_metadata();

  public:
  // .livekit.IngressAudioOptions audio = 6;
  bool has_audio() const;
  void clear_audio() ;
  const ::livekit::IngressAudioOptions& audio() const;
  [[nodiscard]] ::livekit::IngressAudioOptions* PROTOBUF_NULLABLE release_audio();
  ::livekit::IngressAudioOptions* PROTOBUF_NONNULL mutable_audio();
  void set_allocated_audio(::livekit::IngressAudioOptions* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_audio(::livekit::IngressAudioOptions* PROTOBUF_NULLABLE value);
  ::livekit::IngressAudioOptions* PROTOBUF_NULLABLE unsafe_arena_release_audio();

  private:
  const ::livekit::IngressAudioOptions& _internal_audio() const;
  ::livekit::IngressAudioOptions* PROTOBUF_NONNULL _internal_mutable_audio();

  public:
  // .livekit.IngressVideoOptions video = 7;
  bool has_video() const;
  void clear_video() ;
  const ::livekit::IngressVideoOptions& video() const;
  [[nodiscard]] ::livekit::IngressVideoOptions* PROTOBUF_NULLABLE release_video();
  ::livekit::IngressVideoOptions* PROTOBUF_NONNULL mutable_video();
  void set_allocated_video(::livekit::IngressVideoOptions* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_video(::livekit::IngressVideoOptions* PROTOBUF_NULLABLE value);
  ::livekit::IngressVideoOptions* PROTOBUF_NULLABLE unsafe_arena_release_video();

  private:
  const ::livekit::IngressVideoOptions& _internal_video() const;
  ::livekit::IngressVideoOptions* PROTOBUF_NONNULL _internal_mutable_video();

  public:
  // optional bool bypass_transcoding = 8 [deprecated = true];
  [[deprecated]]  bool has_bypass_transcoding() const;
  [[deprecated]]  void clear_bypass_transcoding() ;
  [[deprecated]] bool bypass_transcoding() const;
  [[deprecated]] void set_bypass_transcoding(bool value);

  private:
  bool _internal_bypass_transcoding() const;
  void _internal_set_bypass_transcoding(bool value);

  public:
  // optional bool enable_transcoding = 10;
  bool has_enable_transcoding() const;
  void clear_enable_transcoding() ;
  bool enable_transcoding() const;
  void set_enable_transcoding(bool value);

  private:
  bool _internal_enable_transcoding() const;
  void _internal_set_enable_transcoding(bool value);

  public:
  // optional bool enabled = 11;
  bool has_enabled() const;
  void clear_enabled() ;
  bool enabled() const;
  void set_enabled(bool value);

  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.UpdateIngressRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 11,
                                   2, 124,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UpdateIngressRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr ingress_id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr room_name_;
    ::google::protobuf::internal::ArenaStringPtr participant_identity_;
    ::google::protobuf::internal::ArenaStringPtr participant_name_;
    ::google::protobuf::internal::ArenaStringPtr participant_metadata_;
    ::livekit::IngressAudioOptions* PROTOBUF_NULLABLE audio_;
    ::livekit::IngressVideoOptions* PROTOBUF_NULLABLE video_;
    bool bypass_transcoding_;
    bool enable_transcoding_;
    bool enabled_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fingress_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UpdateIngressRequest_class_data_;
// -------------------------------------------------------------------

class IngressState final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.IngressState) */ {
 public:
  inline IngressState() : IngressState(nullptr) {}
  ~IngressState() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(IngressState* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(IngressState));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR IngressState(::google::protobuf::internal::ConstantInitialized);

  inline IngressState(const IngressState& from) : IngressState(nullptr, from) {}
  inline IngressState(IngressState&& from) noexcept
      : IngressState(nullptr, std::move(from)) {}
  inline IngressState& operator=(const IngressState& from) {
    CopyFrom(from);
    return *this;
  }
  inline IngressState& operator=(IngressState&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IngressState& default_instance() {
    return *reinterpret_cast<const IngressState*>(
        &_IngressState_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(IngressState& a, IngressState& b) { a.Swap(&b); }
  inline void Swap(IngressState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IngressState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IngressState* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<IngressState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const IngressState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const IngressState& from) { IngressState::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(IngressState* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.IngressState"; }

 protected:
  explicit IngressState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  IngressState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const IngressState& from);
  IngressState(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, IngressState&& from) noexcept
      : IngressState(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Status = IngressState_Status;
  static constexpr Status ENDPOINT_INACTIVE = IngressState_Status_ENDPOINT_INACTIVE;
  static constexpr Status ENDPOINT_BUFFERING = IngressState_Status_ENDPOINT_BUFFERING;
  static constexpr Status ENDPOINT_PUBLISHING = IngressState_Status_ENDPOINT_PUBLISHING;
  static constexpr Status ENDPOINT_ERROR = IngressState_Status_ENDPOINT_ERROR;
  static constexpr Status ENDPOINT_COMPLETE = IngressState_Status_ENDPOINT_COMPLETE;
  static inline bool Status_IsValid(int value) {
    return IngressState_Status_IsValid(value);
  }
  static constexpr Status Status_MIN = IngressState_Status_Status_MIN;
  static constexpr Status Status_MAX = IngressState_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE = IngressState_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Status_descriptor() {
    return IngressState_Status_descriptor();
  }
  template <typename T>
  static inline const std::string& Status_Name(T value) {
    return IngressState_Status_Name(value);
  }
  static inline bool Status_Parse(
      absl::string_view name, Status* PROTOBUF_NONNULL value) {
    return IngressState_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kTracksFieldNumber = 6,
    kErrorFieldNumber = 2,
    kRoomIdFieldNumber = 5,
    kResourceIdFieldNumber = 9,
    kVideoFieldNumber = 3,
    kAudioFieldNumber = 4,
    kStartedAtFieldNumber = 7,
    kEndedAtFieldNumber = 8,
    kUpdatedAtFieldNumber = 10,
    kStatusFieldNumber = 1,
  };
  // repeated .livekit.TrackInfo tracks = 6;
  int tracks_size() const;
  private:
  int _internal_tracks_size() const;

  public:
  void clear_tracks() ;
  ::livekit::TrackInfo* PROTOBUF_NONNULL mutable_tracks(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::TrackInfo>* PROTOBUF_NONNULL mutable_tracks();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::TrackInfo>& _internal_tracks() const;
  ::google::protobuf::RepeatedPtrField<::livekit::TrackInfo>* PROTOBUF_NONNULL _internal_mutable_tracks();
  public:
  const ::livekit::TrackInfo& tracks(int index) const;
  ::livekit::TrackInfo* PROTOBUF_NONNULL add_tracks();
  const ::google::protobuf::RepeatedPtrField<::livekit::TrackInfo>& tracks() const;
  // string error = 2;
  void clear_error() ;
  const std::string& error() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_error();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_error();
  void set_allocated_error(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_error() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_error();

  public:
  // string room_id = 5;
  void clear_room_id() ;
  const std::string& room_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_room_id(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_room_id();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_room_id();
  void set_allocated_room_id(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_room_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_room_id(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_room_id();

  public:
  // string resource_id = 9;
  void clear_resource_id() ;
  const std::string& resource_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_resource_id(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_resource_id();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_resource_id();
  void set_allocated_resource_id(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_resource_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_resource_id(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_resource_id();

  public:
  // .livekit.InputVideoState video = 3;
  bool has_video() const;
  void clear_video() ;
  const ::livekit::InputVideoState& video() const;
  [[nodiscard]] ::livekit::InputVideoState* PROTOBUF_NULLABLE release_video();
  ::livekit::InputVideoState* PROTOBUF_NONNULL mutable_video();
  void set_allocated_video(::livekit::InputVideoState* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_video(::livekit::InputVideoState* PROTOBUF_NULLABLE value);
  ::livekit::InputVideoState* PROTOBUF_NULLABLE unsafe_arena_release_video();

  private:
  const ::livekit::InputVideoState& _internal_video() const;
  ::livekit::InputVideoState* PROTOBUF_NONNULL _internal_mutable_video();

  public:
  // .livekit.InputAudioState audio = 4;
  bool has_audio() const;
  void clear_audio() ;
  const ::livekit::InputAudioState& audio() const;
  [[nodiscard]] ::livekit::InputAudioState* PROTOBUF_NULLABLE release_audio();
  ::livekit::InputAudioState* PROTOBUF_NONNULL mutable_audio();
  void set_allocated_audio(::livekit::InputAudioState* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_audio(::livekit::InputAudioState* PROTOBUF_NULLABLE value);
  ::livekit::InputAudioState* PROTOBUF_NULLABLE unsafe_arena_release_audio();

  private:
  const ::livekit::InputAudioState& _internal_audio() const;
  ::livekit::InputAudioState* PROTOBUF_NONNULL _internal_mutable_audio();

  public:
  // int64 started_at = 7;
  void clear_started_at() ;
  ::int64_t started_at() const;
  void set_started_at(::int64_t value);

  private:
  ::int64_t _internal_started_at() const;
  void _internal_set_started_at(::int64_t value);

  public:
  // int64 ended_at = 8;
  void clear_ended_at() ;
  ::int64_t ended_at() const;
  void set_ended_at(::int64_t value);

  private:
  ::int64_t _internal_ended_at() const;
  void _internal_set_ended_at(::int64_t value);

  public:
  // int64 updated_at = 10;
  void clear_updated_at() ;
  ::int64_t updated_at() const;
  void set_updated_at(::int64_t value);

  private:
  ::int64_t _internal_updated_at() const;
  void _internal_set_updated_at(::int64_t value);

  public:
  // .livekit.IngressState.Status status = 1;
  void clear_status() ;
  ::livekit::IngressState_Status status() const;
  void set_status(::livekit::IngressState_Status value);

  private:
  ::livekit::IngressState_Status _internal_status() const;
  void _internal_set_status(::livekit::IngressState_Status value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.IngressState)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 10,
                                   3, 60,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const IngressState& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::livekit::TrackInfo > tracks_;
    ::google::protobuf::internal::ArenaStringPtr error_;
    ::google::protobuf::internal::ArenaStringPtr room_id_;
    ::google::protobuf::internal::ArenaStringPtr resource_id_;
    ::livekit::InputVideoState* PROTOBUF_NULLABLE video_;
    ::livekit::InputAudioState* PROTOBUF_NULLABLE audio_;
    ::int64_t started_at_;
    ::int64_t ended_at_;
    ::int64_t updated_at_;
    int status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fingress_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull IngressState_class_data_;
// -------------------------------------------------------------------

class CreateIngressRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.CreateIngressRequest) */ {
 public:
  inline CreateIngressRequest() : CreateIngressRequest(nullptr) {}
  ~CreateIngressRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CreateIngressRequest* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CreateIngressRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateIngressRequest(::google::protobuf::internal::ConstantInitialized);

  inline CreateIngressRequest(const CreateIngressRequest& from) : CreateIngressRequest(nullptr, from) {}
  inline CreateIngressRequest(CreateIngressRequest&& from) noexcept
      : CreateIngressRequest(nullptr, std::move(from)) {}
  inline CreateIngressRequest& operator=(const CreateIngressRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateIngressRequest& operator=(CreateIngressRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateIngressRequest& default_instance() {
    return *reinterpret_cast<const CreateIngressRequest*>(
        &_CreateIngressRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(CreateIngressRequest& a, CreateIngressRequest& b) { a.Swap(&b); }
  inline void Swap(CreateIngressRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateIngressRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateIngressRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CreateIngressRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateIngressRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CreateIngressRequest& from) { CreateIngressRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CreateIngressRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.CreateIngressRequest"; }

 protected:
  explicit CreateIngressRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CreateIngressRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CreateIngressRequest& from);
  CreateIngressRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CreateIngressRequest&& from) noexcept
      : CreateIngressRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 2,
    kRoomNameFieldNumber = 3,
    kParticipantIdentityFieldNumber = 4,
    kParticipantNameFieldNumber = 5,
    kUrlFieldNumber = 9,
    kParticipantMetadataFieldNumber = 10,
    kAudioFieldNumber = 6,
    kVideoFieldNumber = 7,
    kInputTypeFieldNumber = 1,
    kBypassTranscodingFieldNumber = 8,
    kEnableTranscodingFieldNumber = 11,
    kEnabledFieldNumber = 12,
  };
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // string room_name = 3;
  void clear_room_name() ;
  const std::string& room_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_room_name(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_room_name();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_room_name();
  void set_allocated_room_name(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_room_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_room_name(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_room_name();

  public:
  // string participant_identity = 4;
  void clear_participant_identity() ;
  const std::string& participant_identity() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_participant_identity(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_participant_identity();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_participant_identity();
  void set_allocated_participant_identity(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_participant_identity() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_participant_identity(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_participant_identity();

  public:
  // string participant_name = 5;
  void clear_participant_name() ;
  const std::string& participant_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_participant_name(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_participant_name();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_participant_name();
  void set_allocated_participant_name(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_participant_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_participant_name(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_participant_name();

  public:
  // string url = 9;
  void clear_url() ;
  const std::string& url() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_url(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_url();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_url();
  void set_allocated_url(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_url() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_url();

  public:
  // string participant_metadata = 10;
  void clear_participant_metadata() ;
  const std::string& participant_metadata() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_participant_metadata(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_participant_metadata();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_participant_metadata();
  void set_allocated_participant_metadata(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_participant_metadata() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_participant_metadata(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_participant_metadata();

  public:
  // .livekit.IngressAudioOptions audio = 6;
  bool has_audio() const;
  void clear_audio() ;
  const ::livekit::IngressAudioOptions& audio() const;
  [[nodiscard]] ::livekit::IngressAudioOptions* PROTOBUF_NULLABLE release_audio();
  ::livekit::IngressAudioOptions* PROTOBUF_NONNULL mutable_audio();
  void set_allocated_audio(::livekit::IngressAudioOptions* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_audio(::livekit::IngressAudioOptions* PROTOBUF_NULLABLE value);
  ::livekit::IngressAudioOptions* PROTOBUF_NULLABLE unsafe_arena_release_audio();

  private:
  const ::livekit::IngressAudioOptions& _internal_audio() const;
  ::livekit::IngressAudioOptions* PROTOBUF_NONNULL _internal_mutable_audio();

  public:
  // .livekit.IngressVideoOptions video = 7;
  bool has_video() const;
  void clear_video() ;
  const ::livekit::IngressVideoOptions& video() const;
  [[nodiscard]] ::livekit::IngressVideoOptions* PROTOBUF_NULLABLE release_video();
  ::livekit::IngressVideoOptions* PROTOBUF_NONNULL mutable_video();
  void set_allocated_video(::livekit::IngressVideoOptions* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_video(::livekit::IngressVideoOptions* PROTOBUF_NULLABLE value);
  ::livekit::IngressVideoOptions* PROTOBUF_NULLABLE unsafe_arena_release_video();

  private:
  const ::livekit::IngressVideoOptions& _internal_video() const;
  ::livekit::IngressVideoOptions* PROTOBUF_NONNULL _internal_mutable_video();

  public:
  // .livekit.IngressInput input_type = 1;
  void clear_input_type() ;
  ::livekit::IngressInput input_type() const;
  void set_input_type(::livekit::IngressInput value);

  private:
  ::livekit::IngressInput _internal_input_type() const;
  void _internal_set_input_type(::livekit::IngressInput value);

  public:
  // bool bypass_transcoding = 8 [deprecated = true];
  [[deprecated]]  void clear_bypass_transcoding() ;
  [[deprecated]] bool bypass_transcoding() const;
  [[deprecated]] void set_bypass_transcoding(bool value);

  private:
  bool _internal_bypass_transcoding() const;
  void _internal_set_bypass_transcoding(bool value);

  public:
  // optional bool enable_transcoding = 11;
  bool has_enable_transcoding() const;
  void clear_enable_transcoding() ;
  bool enable_transcoding() const;
  void set_enable_transcoding(bool value);

  private:
  bool _internal_enable_transcoding() const;
  void _internal_set_enable_transcoding(bool value);

  public:
  // optional bool enabled = 12;
  bool has_enabled() const;
  void clear_enabled() ;
  bool enabled() const;
  void set_enabled(bool value);

  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.CreateIngressRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 12,
                                   2, 117,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CreateIngressRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr room_name_;
    ::google::protobuf::internal::ArenaStringPtr participant_identity_;
    ::google::protobuf::internal::ArenaStringPtr participant_name_;
    ::google::protobuf::internal::ArenaStringPtr url_;
    ::google::protobuf::internal::ArenaStringPtr participant_metadata_;
    ::livekit::IngressAudioOptions* PROTOBUF_NULLABLE audio_;
    ::livekit::IngressVideoOptions* PROTOBUF_NULLABLE video_;
    int input_type_;
    bool bypass_transcoding_;
    bool enable_transcoding_;
    bool enabled_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fingress_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CreateIngressRequest_class_data_;
// -------------------------------------------------------------------

class IngressInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.IngressInfo) */ {
 public:
  inline IngressInfo() : IngressInfo(nullptr) {}
  ~IngressInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(IngressInfo* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(IngressInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR IngressInfo(::google::protobuf::internal::ConstantInitialized);

  inline IngressInfo(const IngressInfo& from) : IngressInfo(nullptr, from) {}
  inline IngressInfo(IngressInfo&& from) noexcept
      : IngressInfo(nullptr, std::move(from)) {}
  inline IngressInfo& operator=(const IngressInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline IngressInfo& operator=(IngressInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IngressInfo& default_instance() {
    return *reinterpret_cast<const IngressInfo*>(
        &_IngressInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(IngressInfo& a, IngressInfo& b) { a.Swap(&b); }
  inline void Swap(IngressInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IngressInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IngressInfo* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<IngressInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const IngressInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const IngressInfo& from) { IngressInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(IngressInfo* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.IngressInfo"; }

 protected:
  explicit IngressInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  IngressInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const IngressInfo& from);
  IngressInfo(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, IngressInfo&& from) noexcept
      : IngressInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIngressIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kStreamKeyFieldNumber = 3,
    kUrlFieldNumber = 4,
    kRoomNameFieldNumber = 8,
    kParticipantIdentityFieldNumber = 9,
    kParticipantNameFieldNumber = 10,
    kParticipantMetadataFieldNumber = 14,
    kAudioFieldNumber = 6,
    kVideoFieldNumber = 7,
    kStateFieldNumber = 12,
    kInputTypeFieldNumber = 5,
    kBypassTranscodingFieldNumber = 13,
    kEnableTranscodingFieldNumber = 15,
    kReusableFieldNumber = 11,
    kEnabledFieldNumber = 16,
  };
  // string ingress_id = 1;
  void clear_ingress_id() ;
  const std::string& ingress_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ingress_id(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_ingress_id();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_ingress_id();
  void set_allocated_ingress_id(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_ingress_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_ingress_id(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_ingress_id();

  public:
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // string stream_key = 3;
  void clear_stream_key() ;
  const std::string& stream_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_stream_key(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_stream_key();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_stream_key();
  void set_allocated_stream_key(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_stream_key() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_stream_key(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_stream_key();

  public:
  // string url = 4;
  void clear_url() ;
  const std::string& url() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_url(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_url();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_url();
  void set_allocated_url(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_url() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_url();

  public:
  // string room_name = 8;
  void clear_room_name() ;
  const std::string& room_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_room_name(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_room_name();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_room_name();
  void set_allocated_room_name(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_room_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_room_name(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_room_name();

  public:
  // string participant_identity = 9;
  void clear_participant_identity() ;
  const std::string& participant_identity() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_participant_identity(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_participant_identity();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_participant_identity();
  void set_allocated_participant_identity(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_participant_identity() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_participant_identity(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_participant_identity();

  public:
  // string participant_name = 10;
  void clear_participant_name() ;
  const std::string& participant_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_participant_name(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_participant_name();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_participant_name();
  void set_allocated_participant_name(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_participant_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_participant_name(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_participant_name();

  public:
  // string participant_metadata = 14;
  void clear_participant_metadata() ;
  const std::string& participant_metadata() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_participant_metadata(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_participant_metadata();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_participant_metadata();
  void set_allocated_participant_metadata(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_participant_metadata() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_participant_metadata(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_participant_metadata();

  public:
  // .livekit.IngressAudioOptions audio = 6;
  bool has_audio() const;
  void clear_audio() ;
  const ::livekit::IngressAudioOptions& audio() const;
  [[nodiscard]] ::livekit::IngressAudioOptions* PROTOBUF_NULLABLE release_audio();
  ::livekit::IngressAudioOptions* PROTOBUF_NONNULL mutable_audio();
  void set_allocated_audio(::livekit::IngressAudioOptions* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_audio(::livekit::IngressAudioOptions* PROTOBUF_NULLABLE value);
  ::livekit::IngressAudioOptions* PROTOBUF_NULLABLE unsafe_arena_release_audio();

  private:
  const ::livekit::IngressAudioOptions& _internal_audio() const;
  ::livekit::IngressAudioOptions* PROTOBUF_NONNULL _internal_mutable_audio();

  public:
  // .livekit.IngressVideoOptions video = 7;
  bool has_video() const;
  void clear_video() ;
  const ::livekit::IngressVideoOptions& video() const;
  [[nodiscard]] ::livekit::IngressVideoOptions* PROTOBUF_NULLABLE release_video();
  ::livekit::IngressVideoOptions* PROTOBUF_NONNULL mutable_video();
  void set_allocated_video(::livekit::IngressVideoOptions* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_video(::livekit::IngressVideoOptions* PROTOBUF_NULLABLE value);
  ::livekit::IngressVideoOptions* PROTOBUF_NULLABLE unsafe_arena_release_video();

  private:
  const ::livekit::IngressVideoOptions& _internal_video() const;
  ::livekit::IngressVideoOptions* PROTOBUF_NONNULL _internal_mutable_video();

  public:
  // .livekit.IngressState state = 12;
  bool has_state() const;
  void clear_state() ;
  const ::livekit::IngressState& state() const;
  [[nodiscard]] ::livekit::IngressState* PROTOBUF_NULLABLE release_state();
  ::livekit::IngressState* PROTOBUF_NONNULL mutable_state();
  void set_allocated_state(::livekit::IngressState* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_state(::livekit::IngressState* PROTOBUF_NULLABLE value);
  ::livekit::IngressState* PROTOBUF_NULLABLE unsafe_arena_release_state();

  private:
  const ::livekit::IngressState& _internal_state() const;
  ::livekit::IngressState* PROTOBUF_NONNULL _internal_mutable_state();

  public:
  // .livekit.IngressInput input_type = 5;
  void clear_input_type() ;
  ::livekit::IngressInput input_type() const;
  void set_input_type(::livekit::IngressInput value);

  private:
  ::livekit::IngressInput _internal_input_type() const;
  void _internal_set_input_type(::livekit::IngressInput value);

  public:
  // bool bypass_transcoding = 13 [deprecated = true];
  [[deprecated]]  void clear_bypass_transcoding() ;
  [[deprecated]] bool bypass_transcoding() const;
  [[deprecated]] void set_bypass_transcoding(bool value);

  private:
  bool _internal_bypass_transcoding() const;
  void _internal_set_bypass_transcoding(bool value);

  public:
  // optional bool enable_transcoding = 15;
  bool has_enable_transcoding() const;
  void clear_enable_transcoding() ;
  bool enable_transcoding() const;
  void set_enable_transcoding(bool value);

  private:
  bool _internal_enable_transcoding() const;
  void _internal_set_enable_transcoding(bool value);

  public:
  // bool reusable = 11;
  void clear_reusable() ;
  bool reusable() const;
  void set_reusable(bool value);

  private:
  bool _internal_reusable() const;
  void _internal_set_reusable(bool value);

  public:
  // optional bool enabled = 16;
  bool has_enabled() const;
  void clear_enabled() ;
  bool enabled() const;
  void set_enabled(bool value);

  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);

  public:
  // @@protoc_insertion_point(class_scope:livekit.IngressInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 16,
                                   3, 136,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const IngressInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr ingress_id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr stream_key_;
    ::google::protobuf::internal::ArenaStringPtr url_;
    ::google::protobuf::internal::ArenaStringPtr room_name_;
    ::google::protobuf::internal::ArenaStringPtr participant_identity_;
    ::google::protobuf::internal::ArenaStringPtr participant_name_;
    ::google::protobuf::internal::ArenaStringPtr participant_metadata_;
    ::livekit::IngressAudioOptions* PROTOBUF_NULLABLE audio_;
    ::livekit::IngressVideoOptions* PROTOBUF_NULLABLE video_;
    ::livekit::IngressState* PROTOBUF_NULLABLE state_;
    int input_type_;
    bool bypass_transcoding_;
    bool enable_transcoding_;
    bool reusable_;
    bool enabled_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fingress_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull IngressInfo_class_data_;
// -------------------------------------------------------------------

class ListIngressResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:livekit.ListIngressResponse) */ {
 public:
  inline ListIngressResponse() : ListIngressResponse(nullptr) {}
  ~ListIngressResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ListIngressResponse* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ListIngressResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListIngressResponse(::google::protobuf::internal::ConstantInitialized);

  inline ListIngressResponse(const ListIngressResponse& from) : ListIngressResponse(nullptr, from) {}
  inline ListIngressResponse(ListIngressResponse&& from) noexcept
      : ListIngressResponse(nullptr, std::move(from)) {}
  inline ListIngressResponse& operator=(const ListIngressResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListIngressResponse& operator=(ListIngressResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListIngressResponse& default_instance() {
    return *reinterpret_cast<const ListIngressResponse*>(
        &_ListIngressResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(ListIngressResponse& a, ListIngressResponse& b) { a.Swap(&b); }
  inline void Swap(ListIngressResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListIngressResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListIngressResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ListIngressResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListIngressResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListIngressResponse& from) { ListIngressResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ListIngressResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "livekit.ListIngressResponse"; }

 protected:
  explicit ListIngressResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ListIngressResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ListIngressResponse& from);
  ListIngressResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ListIngressResponse&& from) noexcept
      : ListIngressResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .livekit.IngressInfo items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::livekit::IngressInfo* PROTOBUF_NONNULL mutable_items(int index);
  ::google::protobuf::RepeatedPtrField<::livekit::IngressInfo>* PROTOBUF_NONNULL mutable_items();

  private:
  const ::google::protobuf::RepeatedPtrField<::livekit::IngressInfo>& _internal_items() const;
  ::google::protobuf::RepeatedPtrField<::livekit::IngressInfo>* PROTOBUF_NONNULL _internal_mutable_items();
  public:
  const ::livekit::IngressInfo& items(int index) const;
  ::livekit::IngressInfo* PROTOBUF_NONNULL add_items();
  const ::google::protobuf::RepeatedPtrField<::livekit::IngressInfo>& items() const;
  // @@protoc_insertion_point(class_scope:livekit.ListIngressResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ListIngressResponse& from_msg);
    ::google::protobuf::RepeatedPtrField< ::livekit::IngressInfo > items_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fingress_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ListIngressResponse_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// CreateIngressRequest

// .livekit.IngressInput input_type = 1;
inline void CreateIngressRequest::clear_input_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::livekit::IngressInput CreateIngressRequest::input_type() const {
  // @@protoc_insertion_point(field_get:livekit.CreateIngressRequest.input_type)
  return _internal_input_type();
}
inline void CreateIngressRequest::set_input_type(::livekit::IngressInput value) {
  _internal_set_input_type(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:livekit.CreateIngressRequest.input_type)
}
inline ::livekit::IngressInput CreateIngressRequest::_internal_input_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::livekit::IngressInput>(_impl_.input_type_);
}
inline void CreateIngressRequest::_internal_set_input_type(::livekit::IngressInput value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input_type_ = value;
}

// string url = 9;
inline void CreateIngressRequest::clear_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CreateIngressRequest::url() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.CreateIngressRequest.url)
  return _internal_url();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CreateIngressRequest::set_url(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.url_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.CreateIngressRequest.url)
}
inline std::string* PROTOBUF_NONNULL CreateIngressRequest::mutable_url()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:livekit.CreateIngressRequest.url)
  return _s;
}
inline const std::string& CreateIngressRequest::_internal_url() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.url_.Get();
}
inline void CreateIngressRequest::_internal_set_url(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.url_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL CreateIngressRequest::_internal_mutable_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.url_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE CreateIngressRequest::release_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.CreateIngressRequest.url)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.url_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.url_.Set("", GetArena());
  }
  return released;
}
inline void CreateIngressRequest::set_allocated_url(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.url_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.CreateIngressRequest.url)
}

// string name = 2;
inline void CreateIngressRequest::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CreateIngressRequest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.CreateIngressRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CreateIngressRequest::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.CreateIngressRequest.name)
}
inline std::string* PROTOBUF_NONNULL CreateIngressRequest::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:livekit.CreateIngressRequest.name)
  return _s;
}
inline const std::string& CreateIngressRequest::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void CreateIngressRequest::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL CreateIngressRequest::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE CreateIngressRequest::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.CreateIngressRequest.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void CreateIngressRequest::set_allocated_name(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.CreateIngressRequest.name)
}

// string room_name = 3;
inline void CreateIngressRequest::clear_room_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.room_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CreateIngressRequest::room_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.CreateIngressRequest.room_name)
  return _internal_room_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CreateIngressRequest::set_room_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.room_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.CreateIngressRequest.room_name)
}
inline std::string* PROTOBUF_NONNULL CreateIngressRequest::mutable_room_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_room_name();
  // @@protoc_insertion_point(field_mutable:livekit.CreateIngressRequest.room_name)
  return _s;
}
inline const std::string& CreateIngressRequest::_internal_room_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.room_name_.Get();
}
inline void CreateIngressRequest::_internal_set_room_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.room_name_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL CreateIngressRequest::_internal_mutable_room_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.room_name_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE CreateIngressRequest::release_room_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.CreateIngressRequest.room_name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.room_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.room_name_.Set("", GetArena());
  }
  return released;
}
inline void CreateIngressRequest::set_allocated_room_name(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.room_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.room_name_.IsDefault()) {
    _impl_.room_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.CreateIngressRequest.room_name)
}

// string participant_identity = 4;
inline void CreateIngressRequest::clear_participant_identity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.participant_identity_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CreateIngressRequest::participant_identity() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.CreateIngressRequest.participant_identity)
  return _internal_participant_identity();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CreateIngressRequest::set_participant_identity(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.participant_identity_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.CreateIngressRequest.participant_identity)
}
inline std::string* PROTOBUF_NONNULL CreateIngressRequest::mutable_participant_identity()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_participant_identity();
  // @@protoc_insertion_point(field_mutable:livekit.CreateIngressRequest.participant_identity)
  return _s;
}
inline const std::string& CreateIngressRequest::_internal_participant_identity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.participant_identity_.Get();
}
inline void CreateIngressRequest::_internal_set_participant_identity(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.participant_identity_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL CreateIngressRequest::_internal_mutable_participant_identity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.participant_identity_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE CreateIngressRequest::release_participant_identity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.CreateIngressRequest.participant_identity)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.participant_identity_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.participant_identity_.Set("", GetArena());
  }
  return released;
}
inline void CreateIngressRequest::set_allocated_participant_identity(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.participant_identity_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.CreateIngressRequest.participant_identity)
}

// string participant_name = 5;
inline void CreateIngressRequest::clear_participant_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.participant_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CreateIngressRequest::participant_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.CreateIngressRequest.participant_name)
  return _internal_participant_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CreateIngressRequest::set_participant_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.participant_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.CreateIngressRequest.participant_name)
}
inline std::string* PROTOBUF_NONNULL CreateIngressRequest::mutable_participant_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_participant_name();
  // @@protoc_insertion_point(field_mutable:livekit.CreateIngressRequest.participant_name)
  return _s;
}
inline const std::string& CreateIngressRequest::_internal_participant_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.participant_name_.Get();
}
inline void CreateIngressRequest::_internal_set_participant_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.participant_name_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL CreateIngressRequest::_internal_mutable_participant_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.participant_name_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE CreateIngressRequest::release_participant_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.CreateIngressRequest.participant_name)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.participant_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.participant_name_.Set("", GetArena());
  }
  return released;
}
inline void CreateIngressRequest::set_allocated_participant_name(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.participant_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.participant_name_.IsDefault()) {
    _impl_.participant_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.CreateIngressRequest.participant_name)
}

// string participant_metadata = 10;
inline void CreateIngressRequest::clear_participant_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.participant_metadata_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& CreateIngressRequest::participant_metadata() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.CreateIngressRequest.participant_metadata)
  return _internal_participant_metadata();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CreateIngressRequest::set_participant_metadata(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.participant_metadata_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.CreateIngressRequest.participant_metadata)
}
inline std::string* PROTOBUF_NONNULL CreateIngressRequest::mutable_participant_metadata()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_participant_metadata();
  // @@protoc_insertion_point(field_mutable:livekit.CreateIngressRequest.participant_metadata)
  return _s;
}
inline const std::string& CreateIngressRequest::_internal_participant_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.participant_metadata_.Get();
}
inline void CreateIngressRequest::_internal_set_participant_metadata(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.participant_metadata_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL CreateIngressRequest::_internal_mutable_participant_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.participant_metadata_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE CreateIngressRequest::release_participant_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.CreateIngressRequest.participant_metadata)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.participant_metadata_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.participant_metadata_.Set("", GetArena());
  }
  return released;
}
inline void CreateIngressRequest::set_allocated_participant_metadata(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.participant_metadata_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.participant_metadata_.IsDefault()) {
    _impl_.participant_metadata_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.CreateIngressRequest.participant_metadata)
}

// bool bypass_transcoding = 8 [deprecated = true];
inline void CreateIngressRequest::clear_bypass_transcoding() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bypass_transcoding_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool CreateIngressRequest::bypass_transcoding() const {
  // @@protoc_insertion_point(field_get:livekit.CreateIngressRequest.bypass_transcoding)
  return _internal_bypass_transcoding();
}
inline void CreateIngressRequest::set_bypass_transcoding(bool value) {
  _internal_set_bypass_transcoding(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:livekit.CreateIngressRequest.bypass_transcoding)
}
inline bool CreateIngressRequest::_internal_bypass_transcoding() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bypass_transcoding_;
}
inline void CreateIngressRequest::_internal_set_bypass_transcoding(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bypass_transcoding_ = value;
}

// optional bool enable_transcoding = 11;
inline bool CreateIngressRequest::has_enable_transcoding() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void CreateIngressRequest::clear_enable_transcoding() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_transcoding_ = false;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool CreateIngressRequest::enable_transcoding() const {
  // @@protoc_insertion_point(field_get:livekit.CreateIngressRequest.enable_transcoding)
  return _internal_enable_transcoding();
}
inline void CreateIngressRequest::set_enable_transcoding(bool value) {
  _internal_set_enable_transcoding(value);
  _impl_._has_bits_[0] |= 0x00000400u;
  // @@protoc_insertion_point(field_set:livekit.CreateIngressRequest.enable_transcoding)
}
inline bool CreateIngressRequest::_internal_enable_transcoding() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enable_transcoding_;
}
inline void CreateIngressRequest::_internal_set_enable_transcoding(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_transcoding_ = value;
}

// .livekit.IngressAudioOptions audio = 6;
inline bool CreateIngressRequest::has_audio() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.audio_ != nullptr);
  return value;
}
inline void CreateIngressRequest::clear_audio() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.audio_ != nullptr) _impl_.audio_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::livekit::IngressAudioOptions& CreateIngressRequest::_internal_audio() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::livekit::IngressAudioOptions* p = _impl_.audio_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::IngressAudioOptions&>(::livekit::_IngressAudioOptions_default_instance_);
}
inline const ::livekit::IngressAudioOptions& CreateIngressRequest::audio() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.CreateIngressRequest.audio)
  return _internal_audio();
}
inline void CreateIngressRequest::unsafe_arena_set_allocated_audio(
    ::livekit::IngressAudioOptions* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.audio_);
  }
  _impl_.audio_ = reinterpret_cast<::livekit::IngressAudioOptions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.CreateIngressRequest.audio)
}
inline ::livekit::IngressAudioOptions* PROTOBUF_NULLABLE CreateIngressRequest::release_audio() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::livekit::IngressAudioOptions* released = _impl_.audio_;
  _impl_.audio_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::livekit::IngressAudioOptions* PROTOBUF_NULLABLE CreateIngressRequest::unsafe_arena_release_audio() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.CreateIngressRequest.audio)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::livekit::IngressAudioOptions* temp = _impl_.audio_;
  _impl_.audio_ = nullptr;
  return temp;
}
inline ::livekit::IngressAudioOptions* PROTOBUF_NONNULL CreateIngressRequest::_internal_mutable_audio() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.audio_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::livekit::IngressAudioOptions>(GetArena());
    _impl_.audio_ = reinterpret_cast<::livekit::IngressAudioOptions*>(p);
  }
  return _impl_.audio_;
}
inline ::livekit::IngressAudioOptions* PROTOBUF_NONNULL CreateIngressRequest::mutable_audio()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000040u;
  ::livekit::IngressAudioOptions* _msg = _internal_mutable_audio();
  // @@protoc_insertion_point(field_mutable:livekit.CreateIngressRequest.audio)
  return _msg;
}
inline void CreateIngressRequest::set_allocated_audio(::livekit::IngressAudioOptions* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.audio_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.audio_ = reinterpret_cast<::livekit::IngressAudioOptions*>(value);
  // @@protoc_insertion_point(field_set_allocated:livekit.CreateIngressRequest.audio)
}

// .livekit.IngressVideoOptions video = 7;
inline bool CreateIngressRequest::has_video() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.video_ != nullptr);
  return value;
}
inline void CreateIngressRequest::clear_video() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.video_ != nullptr) _impl_.video_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::livekit::IngressVideoOptions& CreateIngressRequest::_internal_video() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::livekit::IngressVideoOptions* p = _impl_.video_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::IngressVideoOptions&>(::livekit::_IngressVideoOptions_default_instance_);
}
inline const ::livekit::IngressVideoOptions& CreateIngressRequest::video() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.CreateIngressRequest.video)
  return _internal_video();
}
inline void CreateIngressRequest::unsafe_arena_set_allocated_video(
    ::livekit::IngressVideoOptions* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.video_);
  }
  _impl_.video_ = reinterpret_cast<::livekit::IngressVideoOptions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.CreateIngressRequest.video)
}
inline ::livekit::IngressVideoOptions* PROTOBUF_NULLABLE CreateIngressRequest::release_video() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::livekit::IngressVideoOptions* released = _impl_.video_;
  _impl_.video_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::livekit::IngressVideoOptions* PROTOBUF_NULLABLE CreateIngressRequest::unsafe_arena_release_video() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.CreateIngressRequest.video)

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::livekit::IngressVideoOptions* temp = _impl_.video_;
  _impl_.video_ = nullptr;
  return temp;
}
inline ::livekit::IngressVideoOptions* PROTOBUF_NONNULL CreateIngressRequest::_internal_mutable_video() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.video_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::livekit::IngressVideoOptions>(GetArena());
    _impl_.video_ = reinterpret_cast<::livekit::IngressVideoOptions*>(p);
  }
  return _impl_.video_;
}
inline ::livekit::IngressVideoOptions* PROTOBUF_NONNULL CreateIngressRequest::mutable_video()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000080u;
  ::livekit::IngressVideoOptions* _msg = _internal_mutable_video();
  // @@protoc_insertion_point(field_mutable:livekit.CreateIngressRequest.video)
  return _msg;
}
inline void CreateIngressRequest::set_allocated_video(::livekit::IngressVideoOptions* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.video_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }

  _impl_.video_ = reinterpret_cast<::livekit::IngressVideoOptions*>(value);
  // @@protoc_insertion_point(field_set_allocated:livekit.CreateIngressRequest.video)
}

// optional bool enabled = 12;
inline bool CreateIngressRequest::has_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void CreateIngressRequest::clear_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool CreateIngressRequest::enabled() const {
  // @@protoc_insertion_point(field_get:livekit.CreateIngressRequest.enabled)
  return _internal_enabled();
}
inline void CreateIngressRequest::set_enabled(bool value) {
  _internal_set_enabled(value);
  _impl_._has_bits_[0] |= 0x00000800u;
  // @@protoc_insertion_point(field_set:livekit.CreateIngressRequest.enabled)
}
inline bool CreateIngressRequest::_internal_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enabled_;
}
inline void CreateIngressRequest::_internal_set_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enabled_ = value;
}

// -------------------------------------------------------------------

// IngressAudioOptions

// string name = 1;
inline void IngressAudioOptions::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IngressAudioOptions::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.IngressAudioOptions.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void IngressAudioOptions::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.IngressAudioOptions.name)
}
inline std::string* PROTOBUF_NONNULL IngressAudioOptions::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:livekit.IngressAudioOptions.name)
  return _s;
}
inline const std::string& IngressAudioOptions::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void IngressAudioOptions::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL IngressAudioOptions::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE IngressAudioOptions::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.IngressAudioOptions.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void IngressAudioOptions::set_allocated_name(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.IngressAudioOptions.name)
}

// .livekit.TrackSource source = 2;
inline void IngressAudioOptions::clear_source() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::livekit::TrackSource IngressAudioOptions::source() const {
  // @@protoc_insertion_point(field_get:livekit.IngressAudioOptions.source)
  return _internal_source();
}
inline void IngressAudioOptions::set_source(::livekit::TrackSource value) {
  _internal_set_source(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:livekit.IngressAudioOptions.source)
}
inline ::livekit::TrackSource IngressAudioOptions::_internal_source() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::livekit::TrackSource>(_impl_.source_);
}
inline void IngressAudioOptions::_internal_set_source(::livekit::TrackSource value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_ = value;
}

// .livekit.IngressAudioEncodingPreset preset = 3;
inline bool IngressAudioOptions::has_preset() const {
  return encoding_options_case() == kPreset;
}
inline void IngressAudioOptions::set_has_preset() {
  _impl_._oneof_case_[0] = kPreset;
}
inline void IngressAudioOptions::clear_preset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (encoding_options_case() == kPreset) {
    _impl_.encoding_options_.preset_ = 0;
    clear_has_encoding_options();
  }
}
inline ::livekit::IngressAudioEncodingPreset IngressAudioOptions::preset() const {
  // @@protoc_insertion_point(field_get:livekit.IngressAudioOptions.preset)
  return _internal_preset();
}
inline void IngressAudioOptions::set_preset(::livekit::IngressAudioEncodingPreset value) {
  if (encoding_options_case() != kPreset) {
    clear_encoding_options();
    set_has_preset();
  }
  _impl_.encoding_options_.preset_ = value;
  // @@protoc_insertion_point(field_set:livekit.IngressAudioOptions.preset)
}
inline ::livekit::IngressAudioEncodingPreset IngressAudioOptions::_internal_preset() const {
  if (encoding_options_case() == kPreset) {
    return static_cast<::livekit::IngressAudioEncodingPreset>(_impl_.encoding_options_.preset_);
  }
  return static_cast<::livekit::IngressAudioEncodingPreset>(0);
}

// .livekit.IngressAudioEncodingOptions options = 4;
inline bool IngressAudioOptions::has_options() const {
  return encoding_options_case() == kOptions;
}
inline bool IngressAudioOptions::_internal_has_options() const {
  return encoding_options_case() == kOptions;
}
inline void IngressAudioOptions::set_has_options() {
  _impl_._oneof_case_[0] = kOptions;
}
inline void IngressAudioOptions::clear_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (encoding_options_case() == kOptions) {
    if (GetArena() == nullptr) {
      delete _impl_.encoding_options_.options_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.encoding_options_.options_);
    }
    clear_has_encoding_options();
  }
}
inline ::livekit::IngressAudioEncodingOptions* PROTOBUF_NULLABLE IngressAudioOptions::release_options() {
  // @@protoc_insertion_point(field_release:livekit.IngressAudioOptions.options)
  if (encoding_options_case() == kOptions) {
    clear_has_encoding_options();
    auto* temp = _impl_.encoding_options_.options_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.encoding_options_.options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::IngressAudioEncodingOptions& IngressAudioOptions::_internal_options() const {
  return encoding_options_case() == kOptions ? *_impl_.encoding_options_.options_ : reinterpret_cast<::livekit::IngressAudioEncodingOptions&>(::livekit::_IngressAudioEncodingOptions_default_instance_);
}
inline const ::livekit::IngressAudioEncodingOptions& IngressAudioOptions::options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.IngressAudioOptions.options)
  return _internal_options();
}
inline ::livekit::IngressAudioEncodingOptions* PROTOBUF_NULLABLE IngressAudioOptions::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.IngressAudioOptions.options)
  if (encoding_options_case() == kOptions) {
    clear_has_encoding_options();
    auto* temp = _impl_.encoding_options_.options_;
    _impl_.encoding_options_.options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void IngressAudioOptions::unsafe_arena_set_allocated_options(
    ::livekit::IngressAudioEncodingOptions* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_encoding_options();
  if (value) {
    set_has_options();
    _impl_.encoding_options_.options_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.IngressAudioOptions.options)
}
inline ::livekit::IngressAudioEncodingOptions* PROTOBUF_NONNULL IngressAudioOptions::_internal_mutable_options() {
  if (encoding_options_case() != kOptions) {
    clear_encoding_options();
    set_has_options();
    _impl_.encoding_options_.options_ = 
        ::google::protobuf::Message::DefaultConstruct<::livekit::IngressAudioEncodingOptions>(GetArena());
  }
  return _impl_.encoding_options_.options_;
}
inline ::livekit::IngressAudioEncodingOptions* PROTOBUF_NONNULL IngressAudioOptions::mutable_options()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::IngressAudioEncodingOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:livekit.IngressAudioOptions.options)
  return _msg;
}

inline bool IngressAudioOptions::has_encoding_options() const {
  return encoding_options_case() != ENCODING_OPTIONS_NOT_SET;
}
inline void IngressAudioOptions::clear_has_encoding_options() {
  _impl_._oneof_case_[0] = ENCODING_OPTIONS_NOT_SET;
}
inline IngressAudioOptions::EncodingOptionsCase IngressAudioOptions::encoding_options_case() const {
  return IngressAudioOptions::EncodingOptionsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// IngressVideoOptions

// string name = 1;
inline void IngressVideoOptions::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IngressVideoOptions::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.IngressVideoOptions.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void IngressVideoOptions::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.IngressVideoOptions.name)
}
inline std::string* PROTOBUF_NONNULL IngressVideoOptions::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:livekit.IngressVideoOptions.name)
  return _s;
}
inline const std::string& IngressVideoOptions::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void IngressVideoOptions::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL IngressVideoOptions::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE IngressVideoOptions::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.IngressVideoOptions.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void IngressVideoOptions::set_allocated_name(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.IngressVideoOptions.name)
}

// .livekit.TrackSource source = 2;
inline void IngressVideoOptions::clear_source() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::livekit::TrackSource IngressVideoOptions::source() const {
  // @@protoc_insertion_point(field_get:livekit.IngressVideoOptions.source)
  return _internal_source();
}
inline void IngressVideoOptions::set_source(::livekit::TrackSource value) {
  _internal_set_source(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:livekit.IngressVideoOptions.source)
}
inline ::livekit::TrackSource IngressVideoOptions::_internal_source() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::livekit::TrackSource>(_impl_.source_);
}
inline void IngressVideoOptions::_internal_set_source(::livekit::TrackSource value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_ = value;
}

// .livekit.IngressVideoEncodingPreset preset = 3;
inline bool IngressVideoOptions::has_preset() const {
  return encoding_options_case() == kPreset;
}
inline void IngressVideoOptions::set_has_preset() {
  _impl_._oneof_case_[0] = kPreset;
}
inline void IngressVideoOptions::clear_preset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (encoding_options_case() == kPreset) {
    _impl_.encoding_options_.preset_ = 0;
    clear_has_encoding_options();
  }
}
inline ::livekit::IngressVideoEncodingPreset IngressVideoOptions::preset() const {
  // @@protoc_insertion_point(field_get:livekit.IngressVideoOptions.preset)
  return _internal_preset();
}
inline void IngressVideoOptions::set_preset(::livekit::IngressVideoEncodingPreset value) {
  if (encoding_options_case() != kPreset) {
    clear_encoding_options();
    set_has_preset();
  }
  _impl_.encoding_options_.preset_ = value;
  // @@protoc_insertion_point(field_set:livekit.IngressVideoOptions.preset)
}
inline ::livekit::IngressVideoEncodingPreset IngressVideoOptions::_internal_preset() const {
  if (encoding_options_case() == kPreset) {
    return static_cast<::livekit::IngressVideoEncodingPreset>(_impl_.encoding_options_.preset_);
  }
  return static_cast<::livekit::IngressVideoEncodingPreset>(0);
}

// .livekit.IngressVideoEncodingOptions options = 4;
inline bool IngressVideoOptions::has_options() const {
  return encoding_options_case() == kOptions;
}
inline bool IngressVideoOptions::_internal_has_options() const {
  return encoding_options_case() == kOptions;
}
inline void IngressVideoOptions::set_has_options() {
  _impl_._oneof_case_[0] = kOptions;
}
inline void IngressVideoOptions::clear_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (encoding_options_case() == kOptions) {
    if (GetArena() == nullptr) {
      delete _impl_.encoding_options_.options_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.encoding_options_.options_);
    }
    clear_has_encoding_options();
  }
}
inline ::livekit::IngressVideoEncodingOptions* PROTOBUF_NULLABLE IngressVideoOptions::release_options() {
  // @@protoc_insertion_point(field_release:livekit.IngressVideoOptions.options)
  if (encoding_options_case() == kOptions) {
    clear_has_encoding_options();
    auto* temp = _impl_.encoding_options_.options_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.encoding_options_.options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::IngressVideoEncodingOptions& IngressVideoOptions::_internal_options() const {
  return encoding_options_case() == kOptions ? *_impl_.encoding_options_.options_ : reinterpret_cast<::livekit::IngressVideoEncodingOptions&>(::livekit::_IngressVideoEncodingOptions_default_instance_);
}
inline const ::livekit::IngressVideoEncodingOptions& IngressVideoOptions::options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.IngressVideoOptions.options)
  return _internal_options();
}
inline ::livekit::IngressVideoEncodingOptions* PROTOBUF_NULLABLE IngressVideoOptions::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.IngressVideoOptions.options)
  if (encoding_options_case() == kOptions) {
    clear_has_encoding_options();
    auto* temp = _impl_.encoding_options_.options_;
    _impl_.encoding_options_.options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void IngressVideoOptions::unsafe_arena_set_allocated_options(
    ::livekit::IngressVideoEncodingOptions* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_encoding_options();
  if (value) {
    set_has_options();
    _impl_.encoding_options_.options_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.IngressVideoOptions.options)
}
inline ::livekit::IngressVideoEncodingOptions* PROTOBUF_NONNULL IngressVideoOptions::_internal_mutable_options() {
  if (encoding_options_case() != kOptions) {
    clear_encoding_options();
    set_has_options();
    _impl_.encoding_options_.options_ = 
        ::google::protobuf::Message::DefaultConstruct<::livekit::IngressVideoEncodingOptions>(GetArena());
  }
  return _impl_.encoding_options_.options_;
}
inline ::livekit::IngressVideoEncodingOptions* PROTOBUF_NONNULL IngressVideoOptions::mutable_options()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::livekit::IngressVideoEncodingOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:livekit.IngressVideoOptions.options)
  return _msg;
}

inline bool IngressVideoOptions::has_encoding_options() const {
  return encoding_options_case() != ENCODING_OPTIONS_NOT_SET;
}
inline void IngressVideoOptions::clear_has_encoding_options() {
  _impl_._oneof_case_[0] = ENCODING_OPTIONS_NOT_SET;
}
inline IngressVideoOptions::EncodingOptionsCase IngressVideoOptions::encoding_options_case() const {
  return IngressVideoOptions::EncodingOptionsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// IngressAudioEncodingOptions

// .livekit.AudioCodec audio_codec = 1;
inline void IngressAudioEncodingOptions::clear_audio_codec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.audio_codec_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::livekit::AudioCodec IngressAudioEncodingOptions::audio_codec() const {
  // @@protoc_insertion_point(field_get:livekit.IngressAudioEncodingOptions.audio_codec)
  return _internal_audio_codec();
}
inline void IngressAudioEncodingOptions::set_audio_codec(::livekit::AudioCodec value) {
  _internal_set_audio_codec(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:livekit.IngressAudioEncodingOptions.audio_codec)
}
inline ::livekit::AudioCodec IngressAudioEncodingOptions::_internal_audio_codec() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::livekit::AudioCodec>(_impl_.audio_codec_);
}
inline void IngressAudioEncodingOptions::_internal_set_audio_codec(::livekit::AudioCodec value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.audio_codec_ = value;
}

// uint32 bitrate = 2;
inline void IngressAudioEncodingOptions::clear_bitrate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bitrate_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t IngressAudioEncodingOptions::bitrate() const {
  // @@protoc_insertion_point(field_get:livekit.IngressAudioEncodingOptions.bitrate)
  return _internal_bitrate();
}
inline void IngressAudioEncodingOptions::set_bitrate(::uint32_t value) {
  _internal_set_bitrate(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:livekit.IngressAudioEncodingOptions.bitrate)
}
inline ::uint32_t IngressAudioEncodingOptions::_internal_bitrate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bitrate_;
}
inline void IngressAudioEncodingOptions::_internal_set_bitrate(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bitrate_ = value;
}

// bool disable_dtx = 3;
inline void IngressAudioEncodingOptions::clear_disable_dtx() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.disable_dtx_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool IngressAudioEncodingOptions::disable_dtx() const {
  // @@protoc_insertion_point(field_get:livekit.IngressAudioEncodingOptions.disable_dtx)
  return _internal_disable_dtx();
}
inline void IngressAudioEncodingOptions::set_disable_dtx(bool value) {
  _internal_set_disable_dtx(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:livekit.IngressAudioEncodingOptions.disable_dtx)
}
inline bool IngressAudioEncodingOptions::_internal_disable_dtx() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.disable_dtx_;
}
inline void IngressAudioEncodingOptions::_internal_set_disable_dtx(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.disable_dtx_ = value;
}

// uint32 channels = 4;
inline void IngressAudioEncodingOptions::clear_channels() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channels_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t IngressAudioEncodingOptions::channels() const {
  // @@protoc_insertion_point(field_get:livekit.IngressAudioEncodingOptions.channels)
  return _internal_channels();
}
inline void IngressAudioEncodingOptions::set_channels(::uint32_t value) {
  _internal_set_channels(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:livekit.IngressAudioEncodingOptions.channels)
}
inline ::uint32_t IngressAudioEncodingOptions::_internal_channels() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.channels_;
}
inline void IngressAudioEncodingOptions::_internal_set_channels(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channels_ = value;
}

// -------------------------------------------------------------------

// IngressVideoEncodingOptions

// .livekit.VideoCodec video_codec = 1;
inline void IngressVideoEncodingOptions::clear_video_codec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.video_codec_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::livekit::VideoCodec IngressVideoEncodingOptions::video_codec() const {
  // @@protoc_insertion_point(field_get:livekit.IngressVideoEncodingOptions.video_codec)
  return _internal_video_codec();
}
inline void IngressVideoEncodingOptions::set_video_codec(::livekit::VideoCodec value) {
  _internal_set_video_codec(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:livekit.IngressVideoEncodingOptions.video_codec)
}
inline ::livekit::VideoCodec IngressVideoEncodingOptions::_internal_video_codec() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::livekit::VideoCodec>(_impl_.video_codec_);
}
inline void IngressVideoEncodingOptions::_internal_set_video_codec(::livekit::VideoCodec value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.video_codec_ = value;
}

// double frame_rate = 2;
inline void IngressVideoEncodingOptions::clear_frame_rate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frame_rate_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double IngressVideoEncodingOptions::frame_rate() const {
  // @@protoc_insertion_point(field_get:livekit.IngressVideoEncodingOptions.frame_rate)
  return _internal_frame_rate();
}
inline void IngressVideoEncodingOptions::set_frame_rate(double value) {
  _internal_set_frame_rate(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:livekit.IngressVideoEncodingOptions.frame_rate)
}
inline double IngressVideoEncodingOptions::_internal_frame_rate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.frame_rate_;
}
inline void IngressVideoEncodingOptions::_internal_set_frame_rate(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frame_rate_ = value;
}

// repeated .livekit.VideoLayer layers = 3;
inline int IngressVideoEncodingOptions::_internal_layers_size() const {
  return _internal_layers().size();
}
inline int IngressVideoEncodingOptions::layers_size() const {
  return _internal_layers_size();
}
inline ::livekit::VideoLayer* PROTOBUF_NONNULL IngressVideoEncodingOptions::mutable_layers(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.IngressVideoEncodingOptions.layers)
  return _internal_mutable_layers()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::VideoLayer>* PROTOBUF_NONNULL IngressVideoEncodingOptions::mutable_layers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.IngressVideoEncodingOptions.layers)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_layers();
}
inline const ::livekit::VideoLayer& IngressVideoEncodingOptions::layers(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.IngressVideoEncodingOptions.layers)
  return _internal_layers().Get(index);
}
inline ::livekit::VideoLayer* PROTOBUF_NONNULL IngressVideoEncodingOptions::add_layers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::VideoLayer* _add = _internal_mutable_layers()->Add();
  // @@protoc_insertion_point(field_add:livekit.IngressVideoEncodingOptions.layers)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::VideoLayer>& IngressVideoEncodingOptions::layers() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.IngressVideoEncodingOptions.layers)
  return _internal_layers();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::VideoLayer>&
IngressVideoEncodingOptions::_internal_layers() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.layers_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::VideoLayer>* PROTOBUF_NONNULL
IngressVideoEncodingOptions::_internal_mutable_layers() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.layers_;
}

// -------------------------------------------------------------------

// IngressInfo

// string ingress_id = 1;
inline void IngressInfo::clear_ingress_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ingress_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IngressInfo::ingress_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.IngressInfo.ingress_id)
  return _internal_ingress_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void IngressInfo::set_ingress_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ingress_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.IngressInfo.ingress_id)
}
inline std::string* PROTOBUF_NONNULL IngressInfo::mutable_ingress_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ingress_id();
  // @@protoc_insertion_point(field_mutable:livekit.IngressInfo.ingress_id)
  return _s;
}
inline const std::string& IngressInfo::_internal_ingress_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ingress_id_.Get();
}
inline void IngressInfo::_internal_set_ingress_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ingress_id_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL IngressInfo::_internal_mutable_ingress_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.ingress_id_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE IngressInfo::release_ingress_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.IngressInfo.ingress_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.ingress_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.ingress_id_.Set("", GetArena());
  }
  return released;
}
inline void IngressInfo::set_allocated_ingress_id(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.ingress_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.ingress_id_.IsDefault()) {
    _impl_.ingress_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.IngressInfo.ingress_id)
}

// string name = 2;
inline void IngressInfo::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& IngressInfo::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.IngressInfo.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void IngressInfo::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.IngressInfo.name)
}
inline std::string* PROTOBUF_NONNULL IngressInfo::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:livekit.IngressInfo.name)
  return _s;
}
inline const std::string& IngressInfo::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void IngressInfo::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL IngressInfo::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE IngressInfo::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.IngressInfo.name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void IngressInfo::set_allocated_name(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.IngressInfo.name)
}

// string stream_key = 3;
inline void IngressInfo::clear_stream_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stream_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& IngressInfo::stream_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.IngressInfo.stream_key)
  return _internal_stream_key();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void IngressInfo::set_stream_key(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.stream_key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.IngressInfo.stream_key)
}
inline std::string* PROTOBUF_NONNULL IngressInfo::mutable_stream_key()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_stream_key();
  // @@protoc_insertion_point(field_mutable:livekit.IngressInfo.stream_key)
  return _s;
}
inline const std::string& IngressInfo::_internal_stream_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stream_key_.Get();
}
inline void IngressInfo::_internal_set_stream_key(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.stream_key_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL IngressInfo::_internal_mutable_stream_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.stream_key_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE IngressInfo::release_stream_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.IngressInfo.stream_key)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.stream_key_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.stream_key_.Set("", GetArena());
  }
  return released;
}
inline void IngressInfo::set_allocated_stream_key(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.stream_key_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.stream_key_.IsDefault()) {
    _impl_.stream_key_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.IngressInfo.stream_key)
}

// string url = 4;
inline void IngressInfo::clear_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& IngressInfo::url() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.IngressInfo.url)
  return _internal_url();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void IngressInfo::set_url(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.url_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.IngressInfo.url)
}
inline std::string* PROTOBUF_NONNULL IngressInfo::mutable_url()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:livekit.IngressInfo.url)
  return _s;
}
inline const std::string& IngressInfo::_internal_url() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.url_.Get();
}
inline void IngressInfo::_internal_set_url(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.url_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL IngressInfo::_internal_mutable_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.url_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE IngressInfo::release_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.IngressInfo.url)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.url_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.url_.Set("", GetArena());
  }
  return released;
}
inline void IngressInfo::set_allocated_url(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.url_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.IngressInfo.url)
}

// .livekit.IngressInput input_type = 5;
inline void IngressInfo::clear_input_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::livekit::IngressInput IngressInfo::input_type() const {
  // @@protoc_insertion_point(field_get:livekit.IngressInfo.input_type)
  return _internal_input_type();
}
inline void IngressInfo::set_input_type(::livekit::IngressInput value) {
  _internal_set_input_type(value);
  _impl_._has_bits_[0] |= 0x00000800u;
  // @@protoc_insertion_point(field_set:livekit.IngressInfo.input_type)
}
inline ::livekit::IngressInput IngressInfo::_internal_input_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::livekit::IngressInput>(_impl_.input_type_);
}
inline void IngressInfo::_internal_set_input_type(::livekit::IngressInput value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input_type_ = value;
}

// bool bypass_transcoding = 13 [deprecated = true];
inline void IngressInfo::clear_bypass_transcoding() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bypass_transcoding_ = false;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline bool IngressInfo::bypass_transcoding() const {
  // @@protoc_insertion_point(field_get:livekit.IngressInfo.bypass_transcoding)
  return _internal_bypass_transcoding();
}
inline void IngressInfo::set_bypass_transcoding(bool value) {
  _internal_set_bypass_transcoding(value);
  _impl_._has_bits_[0] |= 0x00001000u;
  // @@protoc_insertion_point(field_set:livekit.IngressInfo.bypass_transcoding)
}
inline bool IngressInfo::_internal_bypass_transcoding() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bypass_transcoding_;
}
inline void IngressInfo::_internal_set_bypass_transcoding(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bypass_transcoding_ = value;
}

// optional bool enable_transcoding = 15;
inline bool IngressInfo::has_enable_transcoding() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void IngressInfo::clear_enable_transcoding() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_transcoding_ = false;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline bool IngressInfo::enable_transcoding() const {
  // @@protoc_insertion_point(field_get:livekit.IngressInfo.enable_transcoding)
  return _internal_enable_transcoding();
}
inline void IngressInfo::set_enable_transcoding(bool value) {
  _internal_set_enable_transcoding(value);
  _impl_._has_bits_[0] |= 0x00002000u;
  // @@protoc_insertion_point(field_set:livekit.IngressInfo.enable_transcoding)
}
inline bool IngressInfo::_internal_enable_transcoding() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enable_transcoding_;
}
inline void IngressInfo::_internal_set_enable_transcoding(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_transcoding_ = value;
}

// .livekit.IngressAudioOptions audio = 6;
inline bool IngressInfo::has_audio() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.audio_ != nullptr);
  return value;
}
inline void IngressInfo::clear_audio() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.audio_ != nullptr) _impl_.audio_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::livekit::IngressAudioOptions& IngressInfo::_internal_audio() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::livekit::IngressAudioOptions* p = _impl_.audio_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::IngressAudioOptions&>(::livekit::_IngressAudioOptions_default_instance_);
}
inline const ::livekit::IngressAudioOptions& IngressInfo::audio() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.IngressInfo.audio)
  return _internal_audio();
}
inline void IngressInfo::unsafe_arena_set_allocated_audio(
    ::livekit::IngressAudioOptions* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.audio_);
  }
  _impl_.audio_ = reinterpret_cast<::livekit::IngressAudioOptions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.IngressInfo.audio)
}
inline ::livekit::IngressAudioOptions* PROTOBUF_NULLABLE IngressInfo::release_audio() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::livekit::IngressAudioOptions* released = _impl_.audio_;
  _impl_.audio_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::livekit::IngressAudioOptions* PROTOBUF_NULLABLE IngressInfo::unsafe_arena_release_audio() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.IngressInfo.audio)

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::livekit::IngressAudioOptions* temp = _impl_.audio_;
  _impl_.audio_ = nullptr;
  return temp;
}
inline ::livekit::IngressAudioOptions* PROTOBUF_NONNULL IngressInfo::_internal_mutable_audio() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.audio_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::livekit::IngressAudioOptions>(GetArena());
    _impl_.audio_ = reinterpret_cast<::livekit::IngressAudioOptions*>(p);
  }
  return _impl_.audio_;
}
inline ::livekit::IngressAudioOptions* PROTOBUF_NONNULL IngressInfo::mutable_audio()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000100u;
  ::livekit::IngressAudioOptions* _msg = _internal_mutable_audio();
  // @@protoc_insertion_point(field_mutable:livekit.IngressInfo.audio)
  return _msg;
}
inline void IngressInfo::set_allocated_audio(::livekit::IngressAudioOptions* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.audio_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }

  _impl_.audio_ = reinterpret_cast<::livekit::IngressAudioOptions*>(value);
  // @@protoc_insertion_point(field_set_allocated:livekit.IngressInfo.audio)
}

// .livekit.IngressVideoOptions video = 7;
inline bool IngressInfo::has_video() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.video_ != nullptr);
  return value;
}
inline void IngressInfo::clear_video() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.video_ != nullptr) _impl_.video_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::livekit::IngressVideoOptions& IngressInfo::_internal_video() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::livekit::IngressVideoOptions* p = _impl_.video_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::IngressVideoOptions&>(::livekit::_IngressVideoOptions_default_instance_);
}
inline const ::livekit::IngressVideoOptions& IngressInfo::video() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.IngressInfo.video)
  return _internal_video();
}
inline void IngressInfo::unsafe_arena_set_allocated_video(
    ::livekit::IngressVideoOptions* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.video_);
  }
  _impl_.video_ = reinterpret_cast<::livekit::IngressVideoOptions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.IngressInfo.video)
}
inline ::livekit::IngressVideoOptions* PROTOBUF_NULLABLE IngressInfo::release_video() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::livekit::IngressVideoOptions* released = _impl_.video_;
  _impl_.video_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::livekit::IngressVideoOptions* PROTOBUF_NULLABLE IngressInfo::unsafe_arena_release_video() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.IngressInfo.video)

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::livekit::IngressVideoOptions* temp = _impl_.video_;
  _impl_.video_ = nullptr;
  return temp;
}
inline ::livekit::IngressVideoOptions* PROTOBUF_NONNULL IngressInfo::_internal_mutable_video() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.video_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::livekit::IngressVideoOptions>(GetArena());
    _impl_.video_ = reinterpret_cast<::livekit::IngressVideoOptions*>(p);
  }
  return _impl_.video_;
}
inline ::livekit::IngressVideoOptions* PROTOBUF_NONNULL IngressInfo::mutable_video()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000200u;
  ::livekit::IngressVideoOptions* _msg = _internal_mutable_video();
  // @@protoc_insertion_point(field_mutable:livekit.IngressInfo.video)
  return _msg;
}
inline void IngressInfo::set_allocated_video(::livekit::IngressVideoOptions* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.video_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }

  _impl_.video_ = reinterpret_cast<::livekit::IngressVideoOptions*>(value);
  // @@protoc_insertion_point(field_set_allocated:livekit.IngressInfo.video)
}

// string room_name = 8;
inline void IngressInfo::clear_room_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.room_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& IngressInfo::room_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.IngressInfo.room_name)
  return _internal_room_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void IngressInfo::set_room_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.room_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.IngressInfo.room_name)
}
inline std::string* PROTOBUF_NONNULL IngressInfo::mutable_room_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_room_name();
  // @@protoc_insertion_point(field_mutable:livekit.IngressInfo.room_name)
  return _s;
}
inline const std::string& IngressInfo::_internal_room_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.room_name_.Get();
}
inline void IngressInfo::_internal_set_room_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.room_name_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL IngressInfo::_internal_mutable_room_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.room_name_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE IngressInfo::release_room_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.IngressInfo.room_name)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.room_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.room_name_.Set("", GetArena());
  }
  return released;
}
inline void IngressInfo::set_allocated_room_name(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.room_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.room_name_.IsDefault()) {
    _impl_.room_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.IngressInfo.room_name)
}

// string participant_identity = 9;
inline void IngressInfo::clear_participant_identity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.participant_identity_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& IngressInfo::participant_identity() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.IngressInfo.participant_identity)
  return _internal_participant_identity();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void IngressInfo::set_participant_identity(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.participant_identity_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.IngressInfo.participant_identity)
}
inline std::string* PROTOBUF_NONNULL IngressInfo::mutable_participant_identity()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_participant_identity();
  // @@protoc_insertion_point(field_mutable:livekit.IngressInfo.participant_identity)
  return _s;
}
inline const std::string& IngressInfo::_internal_participant_identity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.participant_identity_.Get();
}
inline void IngressInfo::_internal_set_participant_identity(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.participant_identity_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL IngressInfo::_internal_mutable_participant_identity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.participant_identity_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE IngressInfo::release_participant_identity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.IngressInfo.participant_identity)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.participant_identity_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.participant_identity_.Set("", GetArena());
  }
  return released;
}
inline void IngressInfo::set_allocated_participant_identity(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.participant_identity_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.IngressInfo.participant_identity)
}

// string participant_name = 10;
inline void IngressInfo::clear_participant_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.participant_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& IngressInfo::participant_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.IngressInfo.participant_name)
  return _internal_participant_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void IngressInfo::set_participant_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.participant_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.IngressInfo.participant_name)
}
inline std::string* PROTOBUF_NONNULL IngressInfo::mutable_participant_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_participant_name();
  // @@protoc_insertion_point(field_mutable:livekit.IngressInfo.participant_name)
  return _s;
}
inline const std::string& IngressInfo::_internal_participant_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.participant_name_.Get();
}
inline void IngressInfo::_internal_set_participant_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.participant_name_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL IngressInfo::_internal_mutable_participant_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.participant_name_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE IngressInfo::release_participant_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.IngressInfo.participant_name)
  if ((_impl_._has_bits_[0] & 0x00000040u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* released = _impl_.participant_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.participant_name_.Set("", GetArena());
  }
  return released;
}
inline void IngressInfo::set_allocated_participant_name(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.participant_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.participant_name_.IsDefault()) {
    _impl_.participant_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.IngressInfo.participant_name)
}

// string participant_metadata = 14;
inline void IngressInfo::clear_participant_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.participant_metadata_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& IngressInfo::participant_metadata() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.IngressInfo.participant_metadata)
  return _internal_participant_metadata();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void IngressInfo::set_participant_metadata(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.participant_metadata_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.IngressInfo.participant_metadata)
}
inline std::string* PROTOBUF_NONNULL IngressInfo::mutable_participant_metadata()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_participant_metadata();
  // @@protoc_insertion_point(field_mutable:livekit.IngressInfo.participant_metadata)
  return _s;
}
inline const std::string& IngressInfo::_internal_participant_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.participant_metadata_.Get();
}
inline void IngressInfo::_internal_set_participant_metadata(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.participant_metadata_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL IngressInfo::_internal_mutable_participant_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.participant_metadata_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE IngressInfo::release_participant_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.IngressInfo.participant_metadata)
  if ((_impl_._has_bits_[0] & 0x00000080u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* released = _impl_.participant_metadata_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.participant_metadata_.Set("", GetArena());
  }
  return released;
}
inline void IngressInfo::set_allocated_participant_metadata(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.participant_metadata_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.participant_metadata_.IsDefault()) {
    _impl_.participant_metadata_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.IngressInfo.participant_metadata)
}

// bool reusable = 11;
inline void IngressInfo::clear_reusable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reusable_ = false;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline bool IngressInfo::reusable() const {
  // @@protoc_insertion_point(field_get:livekit.IngressInfo.reusable)
  return _internal_reusable();
}
inline void IngressInfo::set_reusable(bool value) {
  _internal_set_reusable(value);
  _impl_._has_bits_[0] |= 0x00004000u;
  // @@protoc_insertion_point(field_set:livekit.IngressInfo.reusable)
}
inline bool IngressInfo::_internal_reusable() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reusable_;
}
inline void IngressInfo::_internal_set_reusable(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reusable_ = value;
}

// .livekit.IngressState state = 12;
inline bool IngressInfo::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.state_ != nullptr);
  return value;
}
inline void IngressInfo::clear_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.state_ != nullptr) _impl_.state_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const ::livekit::IngressState& IngressInfo::_internal_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::livekit::IngressState* p = _impl_.state_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::IngressState&>(::livekit::_IngressState_default_instance_);
}
inline const ::livekit::IngressState& IngressInfo::state() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.IngressInfo.state)
  return _internal_state();
}
inline void IngressInfo::unsafe_arena_set_allocated_state(
    ::livekit::IngressState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.state_);
  }
  _impl_.state_ = reinterpret_cast<::livekit::IngressState*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.IngressInfo.state)
}
inline ::livekit::IngressState* PROTOBUF_NULLABLE IngressInfo::release_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000400u;
  ::livekit::IngressState* released = _impl_.state_;
  _impl_.state_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::livekit::IngressState* PROTOBUF_NULLABLE IngressInfo::unsafe_arena_release_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.IngressInfo.state)

  _impl_._has_bits_[0] &= ~0x00000400u;
  ::livekit::IngressState* temp = _impl_.state_;
  _impl_.state_ = nullptr;
  return temp;
}
inline ::livekit::IngressState* PROTOBUF_NONNULL IngressInfo::_internal_mutable_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.state_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::livekit::IngressState>(GetArena());
    _impl_.state_ = reinterpret_cast<::livekit::IngressState*>(p);
  }
  return _impl_.state_;
}
inline ::livekit::IngressState* PROTOBUF_NONNULL IngressInfo::mutable_state()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000400u;
  ::livekit::IngressState* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:livekit.IngressInfo.state)
  return _msg;
}
inline void IngressInfo::set_allocated_state(::livekit::IngressState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.state_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }

  _impl_.state_ = reinterpret_cast<::livekit::IngressState*>(value);
  // @@protoc_insertion_point(field_set_allocated:livekit.IngressInfo.state)
}

// optional bool enabled = 16;
inline bool IngressInfo::has_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline void IngressInfo::clear_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline bool IngressInfo::enabled() const {
  // @@protoc_insertion_point(field_get:livekit.IngressInfo.enabled)
  return _internal_enabled();
}
inline void IngressInfo::set_enabled(bool value) {
  _internal_set_enabled(value);
  _impl_._has_bits_[0] |= 0x00008000u;
  // @@protoc_insertion_point(field_set:livekit.IngressInfo.enabled)
}
inline bool IngressInfo::_internal_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enabled_;
}
inline void IngressInfo::_internal_set_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enabled_ = value;
}

// -------------------------------------------------------------------

// IngressState

// .livekit.IngressState.Status status = 1;
inline void IngressState::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::livekit::IngressState_Status IngressState::status() const {
  // @@protoc_insertion_point(field_get:livekit.IngressState.status)
  return _internal_status();
}
inline void IngressState::set_status(::livekit::IngressState_Status value) {
  _internal_set_status(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:livekit.IngressState.status)
}
inline ::livekit::IngressState_Status IngressState::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::livekit::IngressState_Status>(_impl_.status_);
}
inline void IngressState::_internal_set_status(::livekit::IngressState_Status value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// string error = 2;
inline void IngressState::clear_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IngressState::error() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.IngressState.error)
  return _internal_error();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void IngressState::set_error(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.IngressState.error)
}
inline std::string* PROTOBUF_NONNULL IngressState::mutable_error()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:livekit.IngressState.error)
  return _s;
}
inline const std::string& IngressState::_internal_error() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_.Get();
}
inline void IngressState::_internal_set_error(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL IngressState::_internal_mutable_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE IngressState::release_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.IngressState.error)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.error_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.error_.Set("", GetArena());
  }
  return released;
}
inline void IngressState::set_allocated_error(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.IngressState.error)
}

// .livekit.InputVideoState video = 3;
inline bool IngressState::has_video() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.video_ != nullptr);
  return value;
}
inline void IngressState::clear_video() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.video_ != nullptr) _impl_.video_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::livekit::InputVideoState& IngressState::_internal_video() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::livekit::InputVideoState* p = _impl_.video_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::InputVideoState&>(::livekit::_InputVideoState_default_instance_);
}
inline const ::livekit::InputVideoState& IngressState::video() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.IngressState.video)
  return _internal_video();
}
inline void IngressState::unsafe_arena_set_allocated_video(
    ::livekit::InputVideoState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.video_);
  }
  _impl_.video_ = reinterpret_cast<::livekit::InputVideoState*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.IngressState.video)
}
inline ::livekit::InputVideoState* PROTOBUF_NULLABLE IngressState::release_video() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::livekit::InputVideoState* released = _impl_.video_;
  _impl_.video_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::livekit::InputVideoState* PROTOBUF_NULLABLE IngressState::unsafe_arena_release_video() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.IngressState.video)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::livekit::InputVideoState* temp = _impl_.video_;
  _impl_.video_ = nullptr;
  return temp;
}
inline ::livekit::InputVideoState* PROTOBUF_NONNULL IngressState::_internal_mutable_video() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.video_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::livekit::InputVideoState>(GetArena());
    _impl_.video_ = reinterpret_cast<::livekit::InputVideoState*>(p);
  }
  return _impl_.video_;
}
inline ::livekit::InputVideoState* PROTOBUF_NONNULL IngressState::mutable_video()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::livekit::InputVideoState* _msg = _internal_mutable_video();
  // @@protoc_insertion_point(field_mutable:livekit.IngressState.video)
  return _msg;
}
inline void IngressState::set_allocated_video(::livekit::InputVideoState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.video_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.video_ = reinterpret_cast<::livekit::InputVideoState*>(value);
  // @@protoc_insertion_point(field_set_allocated:livekit.IngressState.video)
}

// .livekit.InputAudioState audio = 4;
inline bool IngressState::has_audio() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.audio_ != nullptr);
  return value;
}
inline void IngressState::clear_audio() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.audio_ != nullptr) _impl_.audio_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::livekit::InputAudioState& IngressState::_internal_audio() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::livekit::InputAudioState* p = _impl_.audio_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::InputAudioState&>(::livekit::_InputAudioState_default_instance_);
}
inline const ::livekit::InputAudioState& IngressState::audio() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.IngressState.audio)
  return _internal_audio();
}
inline void IngressState::unsafe_arena_set_allocated_audio(
    ::livekit::InputAudioState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.audio_);
  }
  _impl_.audio_ = reinterpret_cast<::livekit::InputAudioState*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.IngressState.audio)
}
inline ::livekit::InputAudioState* PROTOBUF_NULLABLE IngressState::release_audio() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::livekit::InputAudioState* released = _impl_.audio_;
  _impl_.audio_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::livekit::InputAudioState* PROTOBUF_NULLABLE IngressState::unsafe_arena_release_audio() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.IngressState.audio)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::livekit::InputAudioState* temp = _impl_.audio_;
  _impl_.audio_ = nullptr;
  return temp;
}
inline ::livekit::InputAudioState* PROTOBUF_NONNULL IngressState::_internal_mutable_audio() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.audio_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::livekit::InputAudioState>(GetArena());
    _impl_.audio_ = reinterpret_cast<::livekit::InputAudioState*>(p);
  }
  return _impl_.audio_;
}
inline ::livekit::InputAudioState* PROTOBUF_NONNULL IngressState::mutable_audio()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::livekit::InputAudioState* _msg = _internal_mutable_audio();
  // @@protoc_insertion_point(field_mutable:livekit.IngressState.audio)
  return _msg;
}
inline void IngressState::set_allocated_audio(::livekit::InputAudioState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.audio_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.audio_ = reinterpret_cast<::livekit::InputAudioState*>(value);
  // @@protoc_insertion_point(field_set_allocated:livekit.IngressState.audio)
}

// string room_id = 5;
inline void IngressState::clear_room_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.room_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& IngressState::room_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.IngressState.room_id)
  return _internal_room_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void IngressState::set_room_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.room_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.IngressState.room_id)
}
inline std::string* PROTOBUF_NONNULL IngressState::mutable_room_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_room_id();
  // @@protoc_insertion_point(field_mutable:livekit.IngressState.room_id)
  return _s;
}
inline const std::string& IngressState::_internal_room_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.room_id_.Get();
}
inline void IngressState::_internal_set_room_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.room_id_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL IngressState::_internal_mutable_room_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.room_id_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE IngressState::release_room_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.IngressState.room_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.room_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.room_id_.Set("", GetArena());
  }
  return released;
}
inline void IngressState::set_allocated_room_id(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.room_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.room_id_.IsDefault()) {
    _impl_.room_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.IngressState.room_id)
}

// int64 started_at = 7;
inline void IngressState::clear_started_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.started_at_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int64_t IngressState::started_at() const {
  // @@protoc_insertion_point(field_get:livekit.IngressState.started_at)
  return _internal_started_at();
}
inline void IngressState::set_started_at(::int64_t value) {
  _internal_set_started_at(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:livekit.IngressState.started_at)
}
inline ::int64_t IngressState::_internal_started_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.started_at_;
}
inline void IngressState::_internal_set_started_at(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.started_at_ = value;
}

// int64 ended_at = 8;
inline void IngressState::clear_ended_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ended_at_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int64_t IngressState::ended_at() const {
  // @@protoc_insertion_point(field_get:livekit.IngressState.ended_at)
  return _internal_ended_at();
}
inline void IngressState::set_ended_at(::int64_t value) {
  _internal_set_ended_at(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:livekit.IngressState.ended_at)
}
inline ::int64_t IngressState::_internal_ended_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ended_at_;
}
inline void IngressState::_internal_set_ended_at(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ended_at_ = value;
}

// int64 updated_at = 10;
inline void IngressState::clear_updated_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.updated_at_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::int64_t IngressState::updated_at() const {
  // @@protoc_insertion_point(field_get:livekit.IngressState.updated_at)
  return _internal_updated_at();
}
inline void IngressState::set_updated_at(::int64_t value) {
  _internal_set_updated_at(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:livekit.IngressState.updated_at)
}
inline ::int64_t IngressState::_internal_updated_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.updated_at_;
}
inline void IngressState::_internal_set_updated_at(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.updated_at_ = value;
}

// string resource_id = 9;
inline void IngressState::clear_resource_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resource_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& IngressState::resource_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.IngressState.resource_id)
  return _internal_resource_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void IngressState::set_resource_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.resource_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.IngressState.resource_id)
}
inline std::string* PROTOBUF_NONNULL IngressState::mutable_resource_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_resource_id();
  // @@protoc_insertion_point(field_mutable:livekit.IngressState.resource_id)
  return _s;
}
inline const std::string& IngressState::_internal_resource_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.resource_id_.Get();
}
inline void IngressState::_internal_set_resource_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.resource_id_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL IngressState::_internal_mutable_resource_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.resource_id_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE IngressState::release_resource_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.IngressState.resource_id)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.resource_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.resource_id_.Set("", GetArena());
  }
  return released;
}
inline void IngressState::set_allocated_resource_id(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.resource_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.resource_id_.IsDefault()) {
    _impl_.resource_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.IngressState.resource_id)
}

// repeated .livekit.TrackInfo tracks = 6;
inline int IngressState::_internal_tracks_size() const {
  return _internal_tracks().size();
}
inline int IngressState::tracks_size() const {
  return _internal_tracks_size();
}
inline ::livekit::TrackInfo* PROTOBUF_NONNULL IngressState::mutable_tracks(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.IngressState.tracks)
  return _internal_mutable_tracks()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::TrackInfo>* PROTOBUF_NONNULL IngressState::mutable_tracks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.IngressState.tracks)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_tracks();
}
inline const ::livekit::TrackInfo& IngressState::tracks(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.IngressState.tracks)
  return _internal_tracks().Get(index);
}
inline ::livekit::TrackInfo* PROTOBUF_NONNULL IngressState::add_tracks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::TrackInfo* _add = _internal_mutable_tracks()->Add();
  // @@protoc_insertion_point(field_add:livekit.IngressState.tracks)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::TrackInfo>& IngressState::tracks() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.IngressState.tracks)
  return _internal_tracks();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::TrackInfo>&
IngressState::_internal_tracks() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tracks_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::TrackInfo>* PROTOBUF_NONNULL
IngressState::_internal_mutable_tracks() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.tracks_;
}

// -------------------------------------------------------------------

// InputVideoState

// string mime_type = 1;
inline void InputVideoState::clear_mime_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mime_type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InputVideoState::mime_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.InputVideoState.mime_type)
  return _internal_mime_type();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void InputVideoState::set_mime_type(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mime_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.InputVideoState.mime_type)
}
inline std::string* PROTOBUF_NONNULL InputVideoState::mutable_mime_type()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_mime_type();
  // @@protoc_insertion_point(field_mutable:livekit.InputVideoState.mime_type)
  return _s;
}
inline const std::string& InputVideoState::_internal_mime_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.mime_type_.Get();
}
inline void InputVideoState::_internal_set_mime_type(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mime_type_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL InputVideoState::_internal_mutable_mime_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.mime_type_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE InputVideoState::release_mime_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.InputVideoState.mime_type)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.mime_type_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.mime_type_.Set("", GetArena());
  }
  return released;
}
inline void InputVideoState::set_allocated_mime_type(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.mime_type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.mime_type_.IsDefault()) {
    _impl_.mime_type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.InputVideoState.mime_type)
}

// uint32 average_bitrate = 2;
inline void InputVideoState::clear_average_bitrate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.average_bitrate_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t InputVideoState::average_bitrate() const {
  // @@protoc_insertion_point(field_get:livekit.InputVideoState.average_bitrate)
  return _internal_average_bitrate();
}
inline void InputVideoState::set_average_bitrate(::uint32_t value) {
  _internal_set_average_bitrate(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:livekit.InputVideoState.average_bitrate)
}
inline ::uint32_t InputVideoState::_internal_average_bitrate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.average_bitrate_;
}
inline void InputVideoState::_internal_set_average_bitrate(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.average_bitrate_ = value;
}

// uint32 width = 3;
inline void InputVideoState::clear_width() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t InputVideoState::width() const {
  // @@protoc_insertion_point(field_get:livekit.InputVideoState.width)
  return _internal_width();
}
inline void InputVideoState::set_width(::uint32_t value) {
  _internal_set_width(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:livekit.InputVideoState.width)
}
inline ::uint32_t InputVideoState::_internal_width() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.width_;
}
inline void InputVideoState::_internal_set_width(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_ = value;
}

// uint32 height = 4;
inline void InputVideoState::clear_height() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t InputVideoState::height() const {
  // @@protoc_insertion_point(field_get:livekit.InputVideoState.height)
  return _internal_height();
}
inline void InputVideoState::set_height(::uint32_t value) {
  _internal_set_height(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:livekit.InputVideoState.height)
}
inline ::uint32_t InputVideoState::_internal_height() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.height_;
}
inline void InputVideoState::_internal_set_height(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = value;
}

// double framerate = 5;
inline void InputVideoState::clear_framerate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.framerate_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double InputVideoState::framerate() const {
  // @@protoc_insertion_point(field_get:livekit.InputVideoState.framerate)
  return _internal_framerate();
}
inline void InputVideoState::set_framerate(double value) {
  _internal_set_framerate(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:livekit.InputVideoState.framerate)
}
inline double InputVideoState::_internal_framerate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.framerate_;
}
inline void InputVideoState::_internal_set_framerate(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.framerate_ = value;
}

// -------------------------------------------------------------------

// InputAudioState

// string mime_type = 1;
inline void InputAudioState::clear_mime_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mime_type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InputAudioState::mime_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.InputAudioState.mime_type)
  return _internal_mime_type();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void InputAudioState::set_mime_type(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mime_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.InputAudioState.mime_type)
}
inline std::string* PROTOBUF_NONNULL InputAudioState::mutable_mime_type()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_mime_type();
  // @@protoc_insertion_point(field_mutable:livekit.InputAudioState.mime_type)
  return _s;
}
inline const std::string& InputAudioState::_internal_mime_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.mime_type_.Get();
}
inline void InputAudioState::_internal_set_mime_type(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mime_type_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL InputAudioState::_internal_mutable_mime_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.mime_type_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE InputAudioState::release_mime_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.InputAudioState.mime_type)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.mime_type_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.mime_type_.Set("", GetArena());
  }
  return released;
}
inline void InputAudioState::set_allocated_mime_type(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.mime_type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.mime_type_.IsDefault()) {
    _impl_.mime_type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.InputAudioState.mime_type)
}

// uint32 average_bitrate = 2;
inline void InputAudioState::clear_average_bitrate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.average_bitrate_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t InputAudioState::average_bitrate() const {
  // @@protoc_insertion_point(field_get:livekit.InputAudioState.average_bitrate)
  return _internal_average_bitrate();
}
inline void InputAudioState::set_average_bitrate(::uint32_t value) {
  _internal_set_average_bitrate(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:livekit.InputAudioState.average_bitrate)
}
inline ::uint32_t InputAudioState::_internal_average_bitrate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.average_bitrate_;
}
inline void InputAudioState::_internal_set_average_bitrate(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.average_bitrate_ = value;
}

// uint32 channels = 3;
inline void InputAudioState::clear_channels() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channels_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t InputAudioState::channels() const {
  // @@protoc_insertion_point(field_get:livekit.InputAudioState.channels)
  return _internal_channels();
}
inline void InputAudioState::set_channels(::uint32_t value) {
  _internal_set_channels(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:livekit.InputAudioState.channels)
}
inline ::uint32_t InputAudioState::_internal_channels() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.channels_;
}
inline void InputAudioState::_internal_set_channels(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channels_ = value;
}

// uint32 sample_rate = 4;
inline void InputAudioState::clear_sample_rate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sample_rate_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t InputAudioState::sample_rate() const {
  // @@protoc_insertion_point(field_get:livekit.InputAudioState.sample_rate)
  return _internal_sample_rate();
}
inline void InputAudioState::set_sample_rate(::uint32_t value) {
  _internal_set_sample_rate(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:livekit.InputAudioState.sample_rate)
}
inline ::uint32_t InputAudioState::_internal_sample_rate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sample_rate_;
}
inline void InputAudioState::_internal_set_sample_rate(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sample_rate_ = value;
}

// -------------------------------------------------------------------

// UpdateIngressRequest

// string ingress_id = 1;
inline void UpdateIngressRequest::clear_ingress_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ingress_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UpdateIngressRequest::ingress_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.UpdateIngressRequest.ingress_id)
  return _internal_ingress_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UpdateIngressRequest::set_ingress_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ingress_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.UpdateIngressRequest.ingress_id)
}
inline std::string* PROTOBUF_NONNULL UpdateIngressRequest::mutable_ingress_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ingress_id();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateIngressRequest.ingress_id)
  return _s;
}
inline const std::string& UpdateIngressRequest::_internal_ingress_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ingress_id_.Get();
}
inline void UpdateIngressRequest::_internal_set_ingress_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ingress_id_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL UpdateIngressRequest::_internal_mutable_ingress_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.ingress_id_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE UpdateIngressRequest::release_ingress_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.UpdateIngressRequest.ingress_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.ingress_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.ingress_id_.Set("", GetArena());
  }
  return released;
}
inline void UpdateIngressRequest::set_allocated_ingress_id(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.ingress_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.ingress_id_.IsDefault()) {
    _impl_.ingress_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateIngressRequest.ingress_id)
}

// string name = 2;
inline void UpdateIngressRequest::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UpdateIngressRequest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.UpdateIngressRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UpdateIngressRequest::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.UpdateIngressRequest.name)
}
inline std::string* PROTOBUF_NONNULL UpdateIngressRequest::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateIngressRequest.name)
  return _s;
}
inline const std::string& UpdateIngressRequest::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void UpdateIngressRequest::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL UpdateIngressRequest::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE UpdateIngressRequest::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.UpdateIngressRequest.name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void UpdateIngressRequest::set_allocated_name(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateIngressRequest.name)
}

// string room_name = 3;
inline void UpdateIngressRequest::clear_room_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.room_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& UpdateIngressRequest::room_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.UpdateIngressRequest.room_name)
  return _internal_room_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UpdateIngressRequest::set_room_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.room_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.UpdateIngressRequest.room_name)
}
inline std::string* PROTOBUF_NONNULL UpdateIngressRequest::mutable_room_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_room_name();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateIngressRequest.room_name)
  return _s;
}
inline const std::string& UpdateIngressRequest::_internal_room_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.room_name_.Get();
}
inline void UpdateIngressRequest::_internal_set_room_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.room_name_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL UpdateIngressRequest::_internal_mutable_room_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.room_name_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE UpdateIngressRequest::release_room_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.UpdateIngressRequest.room_name)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.room_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.room_name_.Set("", GetArena());
  }
  return released;
}
inline void UpdateIngressRequest::set_allocated_room_name(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.room_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.room_name_.IsDefault()) {
    _impl_.room_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateIngressRequest.room_name)
}

// string participant_identity = 4;
inline void UpdateIngressRequest::clear_participant_identity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.participant_identity_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& UpdateIngressRequest::participant_identity() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.UpdateIngressRequest.participant_identity)
  return _internal_participant_identity();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UpdateIngressRequest::set_participant_identity(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.participant_identity_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.UpdateIngressRequest.participant_identity)
}
inline std::string* PROTOBUF_NONNULL UpdateIngressRequest::mutable_participant_identity()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_participant_identity();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateIngressRequest.participant_identity)
  return _s;
}
inline const std::string& UpdateIngressRequest::_internal_participant_identity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.participant_identity_.Get();
}
inline void UpdateIngressRequest::_internal_set_participant_identity(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.participant_identity_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL UpdateIngressRequest::_internal_mutable_participant_identity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.participant_identity_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE UpdateIngressRequest::release_participant_identity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.UpdateIngressRequest.participant_identity)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.participant_identity_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.participant_identity_.Set("", GetArena());
  }
  return released;
}
inline void UpdateIngressRequest::set_allocated_participant_identity(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.participant_identity_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateIngressRequest.participant_identity)
}

// string participant_name = 5;
inline void UpdateIngressRequest::clear_participant_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.participant_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& UpdateIngressRequest::participant_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.UpdateIngressRequest.participant_name)
  return _internal_participant_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UpdateIngressRequest::set_participant_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.participant_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.UpdateIngressRequest.participant_name)
}
inline std::string* PROTOBUF_NONNULL UpdateIngressRequest::mutable_participant_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_participant_name();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateIngressRequest.participant_name)
  return _s;
}
inline const std::string& UpdateIngressRequest::_internal_participant_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.participant_name_.Get();
}
inline void UpdateIngressRequest::_internal_set_participant_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.participant_name_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL UpdateIngressRequest::_internal_mutable_participant_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.participant_name_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE UpdateIngressRequest::release_participant_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.UpdateIngressRequest.participant_name)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.participant_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.participant_name_.Set("", GetArena());
  }
  return released;
}
inline void UpdateIngressRequest::set_allocated_participant_name(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.participant_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.participant_name_.IsDefault()) {
    _impl_.participant_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateIngressRequest.participant_name)
}

// string participant_metadata = 9;
inline void UpdateIngressRequest::clear_participant_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.participant_metadata_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& UpdateIngressRequest::participant_metadata() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.UpdateIngressRequest.participant_metadata)
  return _internal_participant_metadata();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UpdateIngressRequest::set_participant_metadata(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.participant_metadata_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.UpdateIngressRequest.participant_metadata)
}
inline std::string* PROTOBUF_NONNULL UpdateIngressRequest::mutable_participant_metadata()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_participant_metadata();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateIngressRequest.participant_metadata)
  return _s;
}
inline const std::string& UpdateIngressRequest::_internal_participant_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.participant_metadata_.Get();
}
inline void UpdateIngressRequest::_internal_set_participant_metadata(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.participant_metadata_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL UpdateIngressRequest::_internal_mutable_participant_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.participant_metadata_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE UpdateIngressRequest::release_participant_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.UpdateIngressRequest.participant_metadata)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.participant_metadata_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.participant_metadata_.Set("", GetArena());
  }
  return released;
}
inline void UpdateIngressRequest::set_allocated_participant_metadata(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.participant_metadata_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.participant_metadata_.IsDefault()) {
    _impl_.participant_metadata_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateIngressRequest.participant_metadata)
}

// optional bool bypass_transcoding = 8 [deprecated = true];
inline bool UpdateIngressRequest::has_bypass_transcoding() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void UpdateIngressRequest::clear_bypass_transcoding() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bypass_transcoding_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool UpdateIngressRequest::bypass_transcoding() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateIngressRequest.bypass_transcoding)
  return _internal_bypass_transcoding();
}
inline void UpdateIngressRequest::set_bypass_transcoding(bool value) {
  _internal_set_bypass_transcoding(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:livekit.UpdateIngressRequest.bypass_transcoding)
}
inline bool UpdateIngressRequest::_internal_bypass_transcoding() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bypass_transcoding_;
}
inline void UpdateIngressRequest::_internal_set_bypass_transcoding(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bypass_transcoding_ = value;
}

// optional bool enable_transcoding = 10;
inline bool UpdateIngressRequest::has_enable_transcoding() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void UpdateIngressRequest::clear_enable_transcoding() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_transcoding_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool UpdateIngressRequest::enable_transcoding() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateIngressRequest.enable_transcoding)
  return _internal_enable_transcoding();
}
inline void UpdateIngressRequest::set_enable_transcoding(bool value) {
  _internal_set_enable_transcoding(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:livekit.UpdateIngressRequest.enable_transcoding)
}
inline bool UpdateIngressRequest::_internal_enable_transcoding() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enable_transcoding_;
}
inline void UpdateIngressRequest::_internal_set_enable_transcoding(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_transcoding_ = value;
}

// .livekit.IngressAudioOptions audio = 6;
inline bool UpdateIngressRequest::has_audio() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.audio_ != nullptr);
  return value;
}
inline void UpdateIngressRequest::clear_audio() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.audio_ != nullptr) _impl_.audio_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::livekit::IngressAudioOptions& UpdateIngressRequest::_internal_audio() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::livekit::IngressAudioOptions* p = _impl_.audio_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::IngressAudioOptions&>(::livekit::_IngressAudioOptions_default_instance_);
}
inline const ::livekit::IngressAudioOptions& UpdateIngressRequest::audio() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.UpdateIngressRequest.audio)
  return _internal_audio();
}
inline void UpdateIngressRequest::unsafe_arena_set_allocated_audio(
    ::livekit::IngressAudioOptions* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.audio_);
  }
  _impl_.audio_ = reinterpret_cast<::livekit::IngressAudioOptions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.UpdateIngressRequest.audio)
}
inline ::livekit::IngressAudioOptions* PROTOBUF_NULLABLE UpdateIngressRequest::release_audio() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::livekit::IngressAudioOptions* released = _impl_.audio_;
  _impl_.audio_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::livekit::IngressAudioOptions* PROTOBUF_NULLABLE UpdateIngressRequest::unsafe_arena_release_audio() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.UpdateIngressRequest.audio)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::livekit::IngressAudioOptions* temp = _impl_.audio_;
  _impl_.audio_ = nullptr;
  return temp;
}
inline ::livekit::IngressAudioOptions* PROTOBUF_NONNULL UpdateIngressRequest::_internal_mutable_audio() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.audio_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::livekit::IngressAudioOptions>(GetArena());
    _impl_.audio_ = reinterpret_cast<::livekit::IngressAudioOptions*>(p);
  }
  return _impl_.audio_;
}
inline ::livekit::IngressAudioOptions* PROTOBUF_NONNULL UpdateIngressRequest::mutable_audio()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000040u;
  ::livekit::IngressAudioOptions* _msg = _internal_mutable_audio();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateIngressRequest.audio)
  return _msg;
}
inline void UpdateIngressRequest::set_allocated_audio(::livekit::IngressAudioOptions* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.audio_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.audio_ = reinterpret_cast<::livekit::IngressAudioOptions*>(value);
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateIngressRequest.audio)
}

// .livekit.IngressVideoOptions video = 7;
inline bool UpdateIngressRequest::has_video() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.video_ != nullptr);
  return value;
}
inline void UpdateIngressRequest::clear_video() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.video_ != nullptr) _impl_.video_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::livekit::IngressVideoOptions& UpdateIngressRequest::_internal_video() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::livekit::IngressVideoOptions* p = _impl_.video_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::IngressVideoOptions&>(::livekit::_IngressVideoOptions_default_instance_);
}
inline const ::livekit::IngressVideoOptions& UpdateIngressRequest::video() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.UpdateIngressRequest.video)
  return _internal_video();
}
inline void UpdateIngressRequest::unsafe_arena_set_allocated_video(
    ::livekit::IngressVideoOptions* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.video_);
  }
  _impl_.video_ = reinterpret_cast<::livekit::IngressVideoOptions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.UpdateIngressRequest.video)
}
inline ::livekit::IngressVideoOptions* PROTOBUF_NULLABLE UpdateIngressRequest::release_video() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::livekit::IngressVideoOptions* released = _impl_.video_;
  _impl_.video_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::livekit::IngressVideoOptions* PROTOBUF_NULLABLE UpdateIngressRequest::unsafe_arena_release_video() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.UpdateIngressRequest.video)

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::livekit::IngressVideoOptions* temp = _impl_.video_;
  _impl_.video_ = nullptr;
  return temp;
}
inline ::livekit::IngressVideoOptions* PROTOBUF_NONNULL UpdateIngressRequest::_internal_mutable_video() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.video_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::livekit::IngressVideoOptions>(GetArena());
    _impl_.video_ = reinterpret_cast<::livekit::IngressVideoOptions*>(p);
  }
  return _impl_.video_;
}
inline ::livekit::IngressVideoOptions* PROTOBUF_NONNULL UpdateIngressRequest::mutable_video()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000080u;
  ::livekit::IngressVideoOptions* _msg = _internal_mutable_video();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateIngressRequest.video)
  return _msg;
}
inline void UpdateIngressRequest::set_allocated_video(::livekit::IngressVideoOptions* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.video_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }

  _impl_.video_ = reinterpret_cast<::livekit::IngressVideoOptions*>(value);
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateIngressRequest.video)
}

// optional bool enabled = 11;
inline bool UpdateIngressRequest::has_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void UpdateIngressRequest::clear_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool UpdateIngressRequest::enabled() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateIngressRequest.enabled)
  return _internal_enabled();
}
inline void UpdateIngressRequest::set_enabled(bool value) {
  _internal_set_enabled(value);
  _impl_._has_bits_[0] |= 0x00000400u;
  // @@protoc_insertion_point(field_set:livekit.UpdateIngressRequest.enabled)
}
inline bool UpdateIngressRequest::_internal_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enabled_;
}
inline void UpdateIngressRequest::_internal_set_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enabled_ = value;
}

// -------------------------------------------------------------------

// ListIngressRequest

// string room_name = 1;
inline void ListIngressRequest::clear_room_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.room_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ListIngressRequest::room_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.ListIngressRequest.room_name)
  return _internal_room_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ListIngressRequest::set_room_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.room_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.ListIngressRequest.room_name)
}
inline std::string* PROTOBUF_NONNULL ListIngressRequest::mutable_room_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_room_name();
  // @@protoc_insertion_point(field_mutable:livekit.ListIngressRequest.room_name)
  return _s;
}
inline const std::string& ListIngressRequest::_internal_room_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.room_name_.Get();
}
inline void ListIngressRequest::_internal_set_room_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.room_name_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL ListIngressRequest::_internal_mutable_room_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.room_name_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE ListIngressRequest::release_room_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.ListIngressRequest.room_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.room_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.room_name_.Set("", GetArena());
  }
  return released;
}
inline void ListIngressRequest::set_allocated_room_name(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.room_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.room_name_.IsDefault()) {
    _impl_.room_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.ListIngressRequest.room_name)
}

// string ingress_id = 2;
inline void ListIngressRequest::clear_ingress_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ingress_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ListIngressRequest::ingress_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.ListIngressRequest.ingress_id)
  return _internal_ingress_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ListIngressRequest::set_ingress_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ingress_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.ListIngressRequest.ingress_id)
}
inline std::string* PROTOBUF_NONNULL ListIngressRequest::mutable_ingress_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ingress_id();
  // @@protoc_insertion_point(field_mutable:livekit.ListIngressRequest.ingress_id)
  return _s;
}
inline const std::string& ListIngressRequest::_internal_ingress_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ingress_id_.Get();
}
inline void ListIngressRequest::_internal_set_ingress_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ingress_id_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL ListIngressRequest::_internal_mutable_ingress_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.ingress_id_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE ListIngressRequest::release_ingress_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.ListIngressRequest.ingress_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.ingress_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.ingress_id_.Set("", GetArena());
  }
  return released;
}
inline void ListIngressRequest::set_allocated_ingress_id(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.ingress_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.ingress_id_.IsDefault()) {
    _impl_.ingress_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.ListIngressRequest.ingress_id)
}

// -------------------------------------------------------------------

// ListIngressResponse

// repeated .livekit.IngressInfo items = 1;
inline int ListIngressResponse::_internal_items_size() const {
  return _internal_items().size();
}
inline int ListIngressResponse::items_size() const {
  return _internal_items_size();
}
inline void ListIngressResponse::clear_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.items_.Clear();
}
inline ::livekit::IngressInfo* PROTOBUF_NONNULL ListIngressResponse::mutable_items(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:livekit.ListIngressResponse.items)
  return _internal_mutable_items()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::livekit::IngressInfo>* PROTOBUF_NONNULL ListIngressResponse::mutable_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:livekit.ListIngressResponse.items)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_items();
}
inline const ::livekit::IngressInfo& ListIngressResponse::items(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.ListIngressResponse.items)
  return _internal_items().Get(index);
}
inline ::livekit::IngressInfo* PROTOBUF_NONNULL ListIngressResponse::add_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::livekit::IngressInfo* _add = _internal_mutable_items()->Add();
  // @@protoc_insertion_point(field_add:livekit.ListIngressResponse.items)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::IngressInfo>& ListIngressResponse::items() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:livekit.ListIngressResponse.items)
  return _internal_items();
}
inline const ::google::protobuf::RepeatedPtrField<::livekit::IngressInfo>&
ListIngressResponse::_internal_items() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.items_;
}
inline ::google::protobuf::RepeatedPtrField<::livekit::IngressInfo>* PROTOBUF_NONNULL
ListIngressResponse::_internal_mutable_items() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.items_;
}

// -------------------------------------------------------------------

// DeleteIngressRequest

// string ingress_id = 1;
inline void DeleteIngressRequest::clear_ingress_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ingress_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeleteIngressRequest::ingress_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:livekit.DeleteIngressRequest.ingress_id)
  return _internal_ingress_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DeleteIngressRequest::set_ingress_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ingress_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:livekit.DeleteIngressRequest.ingress_id)
}
inline std::string* PROTOBUF_NONNULL DeleteIngressRequest::mutable_ingress_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ingress_id();
  // @@protoc_insertion_point(field_mutable:livekit.DeleteIngressRequest.ingress_id)
  return _s;
}
inline const std::string& DeleteIngressRequest::_internal_ingress_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ingress_id_.Get();
}
inline void DeleteIngressRequest::_internal_set_ingress_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ingress_id_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL DeleteIngressRequest::_internal_mutable_ingress_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.ingress_id_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE DeleteIngressRequest::release_ingress_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:livekit.DeleteIngressRequest.ingress_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.ingress_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.ingress_id_.Set("", GetArena());
  }
  return released;
}
inline void DeleteIngressRequest::set_allocated_ingress_id(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.ingress_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.ingress_id_.IsDefault()) {
    _impl_.ingress_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.DeleteIngressRequest.ingress_id)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace livekit


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::livekit::IngressState_Status> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::livekit::IngressState_Status>() {
  return ::livekit::IngressState_Status_descriptor();
}
template <>
struct is_proto_enum<::livekit::IngressInput> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::livekit::IngressInput>() {
  return ::livekit::IngressInput_descriptor();
}
template <>
struct is_proto_enum<::livekit::IngressAudioEncodingPreset> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::livekit::IngressAudioEncodingPreset>() {
  return ::livekit::IngressAudioEncodingPreset_descriptor();
}
template <>
struct is_proto_enum<::livekit::IngressVideoEncodingPreset> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::livekit::IngressVideoEncodingPreset>() {
  return ::livekit::IngressVideoEncodingPreset_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // livekit_5fingress_2eproto_2epb_2eh
